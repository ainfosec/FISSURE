#!/usr/bin/env python3

import sys
from PyQt5 import QtCore, QtGui, uic, QtWidgets
import os
form_class = uic.loadUiType(os.path.dirname(os.path.realpath(__file__)) + "/UI/dashboard.ui")[0]
form_class3 = uic.loadUiType(os.path.dirname(os.path.realpath(__file__)) + "/UI/options.ui")[0]
form_class5 = uic.loadUiType(os.path.dirname(os.path.realpath(__file__)) + "/UI/hardware_select.ui")[0]
form_class6 = uic.loadUiType(os.path.dirname(os.path.realpath(__file__)) + "/UI/help.ui")[0]
form_class7 = uic.loadUiType(os.path.dirname(os.path.realpath(__file__)) + "/UI/status.ui")[0]
form_class8 = uic.loadUiType(os.path.dirname(os.path.realpath(__file__)) + "/UI/chooser.ui")[0]
form_class9 = uic.loadUiType(os.path.dirname(os.path.realpath(__file__)) + "/UI/new_soi.ui")[0]
import time
import threading
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.figure import Figure
# ~ from matplotlib.backends.backend_qt4agg import FigureCanvasQTAgg as FigureCanvas
# ~ from matplotlib.backends.backend_qt4agg import NavigationToolbar2QT as NavigationToolbar
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
from matplotlib import cm
from matplotlib.widgets import Cursor
import random
import yaml
import zmq
import signal
from fissureclass import fissure_listener 
from fissureclass import fissure_server    
import logging
import logging.config
import matplotlib.patches as patches
import subprocess
import binascii
from scipy import signal as signal2
from scipy.signal import hilbert, lfilter, butter, filtfilt
from scipy import fromfile, complex64
import scipy.fftpack
import shutil
import struct
from fissure_libutils import *  # FIX
from scapy.all import Dot11,RadioTap,sendp,ls,wrpcap,Dot11Deauth,Dot11ProbeReq,IP,UDP,LLC,SNAP,ARP,Ether,ICMP
from io import StringIO #from StringIO import StringIO
from tempfile import mkstemp
import ast
import math
from random import randint, shuffle
import warnings
from matplotlib import rc
rc('font',family='DejaVu Sans') 
import webbrowser
import crcmod
from PyQt5.QtCore import pyqtSignal
logging.getLogger('matplotlib').setLevel(logging.WARNING) 

sys.path.append(os.path.dirname(os.path.realpath(__file__)) + '/Flow Graph Library/Sniffer Flow Graphs')
sys.path.append(os.path.dirname(os.path.realpath(__file__)) + '/Flow Graph Library/Single-Stage Flow Graphs')
    
class MainWindow(QtWidgets.QMainWindow, form_class):
    
    signal_addWideband = pyqtSignal(tuple, name="addWideband")
    signal_addNarrowband = pyqtSignal(name="addNarrowband")
    signal_flowGraphFinished = pyqtSignal(str, name="flowGraphFinished")
    signal_flowGraphStarted = pyqtSignal(str, name="flowGraphStarted")
    signal_detectorFlowGraphError = pyqtSignal(str, name="detectorFlowGraphError")
    signal_flowGraphError = pyqtSignal(str, name="flowGraphError")
    signal_setRecommendedFlowGraphs = pyqtSignal(str, name="setRecommendedFG")
    signal_setFullLibrary = pyqtSignal(str, name="setFullLib")  # FIX - dict or string?
    signal_PD_AddStatus = pyqtSignal(str, name="PD_AddStatus")
    signal_SOI_Chosen = pyqtSignal(str, name="soiChosen")
    signal_flowGraphFinishedIQ = pyqtSignal(name="flowGraphFinishedIQ")
    signal_flowGraphFinishedIQ_Playback = pyqtSignal(name="flowGraphFinishedIQ_Playback")
    signal_flowGraphFinishedIQ_Inspection = pyqtSignal(name="flowGraphFinishedIQ_Inspection")
    signal_flowGraphFinishedSniffer = pyqtSignal(str, name="flowGraphFinishedSniffer")
    signal_flowGraphStartedIQ = pyqtSignal(name="flowGraphStartedIQ")
    signal_flowGraphStartedIQ_Playback = pyqtSignal(name="flowGraphStartedIQ_Playback")
    signal_flowGraphStartedIQ_Inspection = pyqtSignal(name="flowGraphStartedIQ_Inspection")
    signal_flowGraphStartedSniffer = pyqtSignal(str, name="flowGraphStartedSniffer")
    signal_multiStageAttackFinished = pyqtSignal(name="multiStageAttackFinished")
    signal_archivePlaylistFinished = pyqtSignal(name="archivePlaylistFinished")        
    signal_pdBitSlicingLibraryLookupReturned = pyqtSignal(str, name="pdBitSlicingLibraryLookupReturned")
    signal_pdBitSlicingPreamblesReturned = pyqtSignal(str, name="pdBitSlicingPreamblesReturned")
    signal_pdBitSlicingSliceByPreambleReturn = pyqtSignal(str, name="pdBitSlicingSliceByPreambleReturn")
    signal_pdBufferSize = pyqtSignal(str, name="pdBufferSize")
    signal_pdBitSlicingEntropyReturn = pyqtSignal(str, name="pdBitSlicingEntropyReturn")
    signal_bandID = pyqtSignal(str, name="bandID")
    signal_archivePlaylistPosition = pyqtSignal(str, name="archivePlaylistPosition")
    signal_HIPRFISR_Offline = pyqtSignal(name="hiprfisrOffline")
    signal_HIPRFISR_Online = pyqtSignal(name="hiprfisrOnline")
    signal_TSI_Offline = pyqtSignal(name="tsiOffline")
    signal_TSI_Online = pyqtSignal(name="tsiOnline")
    signal_PD_Offline = pyqtSignal(name="pdOffline")
    signal_PD_Online = pyqtSignal(name="pdOnline")
    signal_FGE_Offline = pyqtSignal(name="fgeOffline")
    signal_FGE_Online = pyqtSignal(name="fgeOnline")     
    
    
    def __init__(self, parent=None):
        """ First thing that executes
        """
        QtWidgets.QMainWindow.__init__(self)
        self.setupUi(self)
        
        # Disable Unused Menu Items
        self.menuView.menuAction().setVisible(True)
        self.menuOptions.menuAction().setVisible(True)
        self.menuFile.menuAction().setVisible(True)
            
        # Do SIGNAL/Slot Connections   
        self._connectSlots()
                
        # Check for Remember Configuration
        get_remember = False
        with open(os.path.dirname(os.path.realpath(__file__)) + "/YAML/fissure_config.yaml") as f:
            if "remember_configuration: 'True'" in f.read():
                get_remember = True
                self.actionRemember_Configuration.setChecked(True)
        if get_remember == False:
            os.system('cp "' + os.path.dirname(os.path.realpath(__file__)) + '/YAML/User Configs/default.yaml' + '" "' + os.path.dirname(os.path.realpath(__file__)) + '/YAML/fissure_config.yaml"')
        
        # Load FISSURE Configuration from YAML File
        self.loadConfiguration()   
        
        # Load "library.yaml"
        filename = os.path.dirname(os.path.realpath(__file__)) + "/YAML/library.yaml"
        with open(filename) as yaml_library_file:
            self.pd_library = yaml.load(yaml_library_file, yaml.FullLoader)     
            
        # Create Tuning Matplotlib Widget
        self.tuning_matplotlib_widget = MyTuningMplCanvas(self.tab_tsi_sweep, dpi=100, title='Tuning', ylim=400)
        self.tuning_matplotlib_widget.move(self.frame_tsi_search_bands.pos())
        self.tuning_matplotlib_widget.setGeometry(self.frame_tsi_search_bands.geometry())  

        # Create Wideband Matplotlib Widget
        self.wideband_width = 1201
        self.wideband_height = 801
        self.wideband_data = np.ones((self.wideband_height,self.wideband_width,3))
        self.matplotlib_widget = MyMplCanvas(self.tab_tsi_sweep, dpi=100, title='Detector History', ylim=400, width=self.wideband_width, height=self.wideband_height, border=[0.08,0.90,0.05,1,0,0], colorbar_fraction=0.038, xlabels=['0', '','1000', '', '2000', '', '3000', '', '4000', '', '5000', '', '6000'], ylabels=['0', '5', '10', '15', '20','25', '30', '35', '40', '45'])
        self.matplotlib_widget.move(self.frame_tsi_detector.pos())
        self.matplotlib_widget.setGeometry(self.frame_tsi_detector.geometry())    
        self.matplotlib_widget.axes.cla()
        self.matplotlib_widget.axes.imshow(self.wideband_data, cmap='rainbow', clim=(-100,30), extent=[0,1201,801,0])
        self.matplotlib_widget.configureAxes(title='Detector History',xlabel='Frequency (MHz)',ylabel='Time Elapsed (s)', xlabels=['0', '','1000', '', '2000', '', '3000', '', '4000', '', '5000', '', '6000'],ylabels=['0', '5', '10', '15', '20', '25', '30', '35', '40'],ylim=self.wideband_height)
        self.matplotlib_widget.draw()

        # Create Narrowband Matplotlib Widget
        # self.narrowband_width = 2401
        # self.narrowband_height = 401
        # self.narrowband_data =  np.ones((self.narrowband_height,self.narrowband_width,3))
        # self.nb_matplotlib_widget = MyMplCanvas(self.tab_classifier, dpi=100, title='Classifier History', ylim=400, width=self.narrowband_width, height=self.narrowband_height, border = [0.05,0.94,0,1.05,0,0], colorbar_fraction=0.01, xlabels=['0', '', '500', '','1000', '', '1500', '', '2000', '', '2500', '', '3000', '', '3500', '', '4000', '', '4500', '', '5000', '', '5500', '', '6000'])
        # self.nb_matplotlib_widget.move(self.frame_tsi_classifier.pos())
        # self.nb_matplotlib_widget.setGeometry(self.frame_tsi_classifier.geometry())  
        
        # Create IQ Data Matplotlib Widget
        self.iq_matplotlib_widget = MyIQ_MplCanvas(self.tab_iq_data, dpi=100, title='IQ Data', ylim=400)
        self.iq_matplotlib_widget.move(self.frame_iq.pos())
        self.iq_matplotlib_widget.setGeometry(self.frame_iq.geometry())    

        # Add a Toolbar
        self.mpl_toolbar = NavigationToolbar(self.iq_matplotlib_widget, self.tab_iq_data)
        #self.mpl_toolbar.setGeometry(QtCore.QRect(450, 815, 525, 25))  
        self.mpl_toolbar.setGeometry(QtCore.QRect(375, 282, 525, 35))  
           
        # Get Protocols
        protocols = getProtocols(self.pd_library)
        
        
        ##### Status Bar and Dialog #####
        self.status_dialog = StatusDialog(parent=self)
        self.status_dialog.move(20,795)
        self.status_dialog.hide()
        
        self.custom_statusbar = CustomStatusBar(parent=self)
        self.setStatusBar(self.custom_statusbar)        
        
        #self.statusBar_label.setText("| Dashboard: OK | HIPRFISR: XX | TSI: XX | PD: XX | FGE: XX |")
        self.statusbar_dashboard = QtWidgets.QLabel("Dashboard: OK")
        self.statusbar_hiprfisr = QtWidgets.QPushButton("HIPRFISR: XX")
        self.statusbar_hiprfisr.setStyleSheet("max-height:13px; max-width:90px")
        self.statusbar_hiprfisr.setFlat(True)
        self.statusbar_hiprfisr.setFont(QtGui.QFont("Ubuntu",10))   
        self.statusbar_tsi = QtWidgets.QPushButton("TSI: XX")
        self.statusbar_tsi.setStyleSheet("max-height:13px; max-width:50px")
        self.statusbar_tsi.setFlat(True)
        self.statusbar_tsi.setFont(QtGui.QFont("Ubuntu",10))
        self.statusbar_pd = QtWidgets.QPushButton("PD: XX")
        self.statusbar_pd.setStyleSheet("max-height:13px; max-width:50px")
        self.statusbar_pd.setFlat(True)
        self.statusbar_pd.setFont(QtGui.QFont("Ubuntu",10))
        self.statusbar_fge = QtWidgets.QPushButton("FGE: XX")
        self.statusbar_fge.setStyleSheet("max-height:13px; max-width:55px")
        self.statusbar_fge.setFlat(True)
        self.statusbar_fge.setFont(QtGui.QFont("Ubuntu",10))
        
        self.custom_statusbar.addWidget(VLine(parent=self))
        self.custom_statusbar.addWidget(self.statusbar_dashboard)        
        self.custom_statusbar.addWidget(VLine(parent=self))
        self.custom_statusbar.addWidget(self.statusbar_hiprfisr)        
        self.custom_statusbar.addWidget(VLine(parent=self))
        self.custom_statusbar.addWidget(self.statusbar_tsi)        
        self.custom_statusbar.addWidget(VLine(parent=self))
        self.custom_statusbar.addWidget(self.statusbar_pd)        
        self.custom_statusbar.addWidget(VLine(parent=self))
        self.custom_statusbar.addWidget(self.statusbar_fge)        
        self.custom_statusbar.addWidget(VLine(parent=self))
        
        self.statusbar_tsi.clicked.connect(self._slotStatusbarTSI_Clicked)
        self.statusbar_pd.clicked.connect(self._slotStatusbarPD_Clicked)
        self.statusbar_fge.clicked.connect(self._slotStatusbarFGE_Clicked)
        self.statusbar_hiprfisr.clicked.connect(self._slotStatusbarHIPRFISR_Clicked)
                
        ##### Top Ribbon #####
        self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png")) 
        self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png")) 
        self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png")) 
        self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png")) 
        self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png"))         
                
        self.guess_index = 0
             
        self.configureTSI_Hardware()
        self.configurePD_Hardware()
        self.configureAttackHardware()
        self.configureIQ_Hardware()
        self.configureArchiveHardware()
                    
                    
        ##### Automation Tab #####
        # Lock Search Band
        self._slotAutomationLockSearchBandClicked()    
        
        # Resize Table Columns and Rows for SDR Configuration Tables
        self.tableWidget_automation_scan_options.resizeColumnsToContents()  # Automation Tab
        self.tableWidget_automation_scan_options.resizeRowsToContents()
        
        # Load and Apply Automation Mode Settings
        if self.dashboard_settings_dictionary['startup_automation_mode'] == "Discovery":
            self._slotAutomationDiscoveryClicked()
        elif self.dashboard_settings_dictionary['startup_automation_mode'] == "Target":
            self._slotAutomationTargetClicked()
        elif self.dashboard_settings_dictionary['startup_automation_mode'] == "Manual":
            self._slotAutomationManualClicked()
        else:
            self._slotAutomationCustomClicked()
        
        # Load Target Protocol Protocols
        self.comboBox_automation_target_protocol.addItems(sorted(protocols))
        
        # Set up SOI List Priority Table
        self.label_soi_priority_row2.setVisible(False)
        self.label_soi_priority_row3.setVisible(False)
        
        new_combobox1 = QtWidgets.QComboBox(self)
        self.tableWidget_automation_soi_list_priority.setCellWidget(0,0,new_combobox1)
        new_combobox1.addItem("Power")
        new_combobox1.addItem("Frequency")
        new_combobox1.addItem("Modulation")
        new_combobox1.setSizeAdjustPolicy(0)
        new_combobox1.currentIndexChanged.connect(self._slotSOI_PriorityCategoryChanged)
        new_combobox1.setCurrentIndex(0)
    
        new_combobox2 = QtWidgets.QComboBox(self)
        self.tableWidget_automation_soi_list_priority.setCellWidget(0,1,new_combobox2)
        new_combobox2.addItem("Highest")
        new_combobox2.addItem("Lowest")
        new_combobox2.addItem("Nearest to")
        new_combobox2.addItem("Greater than")
        new_combobox2.addItem("Less than")
        new_combobox2.setSizeAdjustPolicy(0)        
        
        empty_item1 = QtWidgets.QTableWidgetItem("")
        self.tableWidget_automation_soi_list_priority.setItem(0,2,empty_item1)
        
        self.tableWidget_automation_soi_list_priority.resizeColumnsToContents()
        self.tableWidget_automation_soi_list_priority.resizeRowsToContents()    
        
        # Load Image in Automation Tab
        self.label_diagram.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/logo.png")) 
                
        ##### Library #####             
        # Load Protocols into Gallery ComboBox
        protocols_with_images = []
        for p in protocols:                        
            if len(self.findGalleryImages(p)) > 0:  
                protocols_with_images.append(p)
        self.comboBox_library_gallery_protocol.addItems(sorted(protocols_with_images))
           
        # Load Protocols into Add to Library ComboBox        
        self.comboBox_library_pd_protocol.addItem("-- New Protocol --")   
        self.comboBox_library_pd_protocol.addItems(sorted(protocols))              
        
        # Load Protocols into Search Library ComboBox
        self.comboBox_library_browse_protocol.addItems(sorted(protocols))
        
        # Configure PD\Construct Packet Tables
        self.tableWidget_library_pd_packet.resizeRowsToContents() 
        
        # Resize the Protocol Discovery Add to Library Table      
        self.tableWidget_library_pd_packet.setColumnWidth(0,125) 
        self.tableWidget_library_pd_packet.setColumnWidth(1,100) 
        self.tableWidget_library_pd_packet.setColumnWidth(3,75)
        self.tableWidget_library_pd_packet.setColumnWidth(4,130)
        self.tableWidget_library_pd_packet.horizontalHeader().setSectionResizeMode(2,QtWidgets.QHeaderView.Stretch) 
                
        # Hide the Searching Label
        self.label_library_search_searching.setVisible(False)   
        
        # Set up Add Attack Stacked Widget
        self.comboBox_library_attacks_subcategory.addItems(["Denial of Service","Jamming","Spoofing","Sniffing/Snooping","Probe Attacks","Installation of Malware","Misuse of Resources","File"])
        
        # Populate the Remove Attacks Tree Widget
        #self.treeWidget_library_attacks_remove
        # Configure Attack TreeWidget
        self._slotLibraryBrowseYAML_Changed()
        #self.treeWidget_library_browse.expandAll()
        #self._slotAttackProtocols()

                
        ##### TSI #####
        self.target_soi = []
        
        # Create Preset Dictionary
        self.preset_dictionary = {}        
        self.preset_count = 0
        
        # Create SOI Blacklist
        self.soi_blacklist = []
        
        # Resize Table Columns and Rows for SDR Configuration Tables
        self.tableWidget_tsi_scan_options.resizeColumnsToContents()
        self.tableWidget_tsi_scan_options.resizeRowsToContents()
        self.tableWidget_tsi_scan_options.horizontalHeader().setFixedHeight(20)
        
        # Resize Table Columns for Wideband and Narrowband Tables
        self.tableWidget_tsi_wideband.resizeColumnsToContents()
        self.tableWidget_tsi_narrowband.resizeColumnsToContents()
        
        # Put the Labels on Top of the Plots
        self.label_tsi_detector.raise_()
        self.label_tsi_classifier.raise_()   
        
        # Hide Update Configuration Label
        self.label_tsi_update_configuration.setVisible(False) 
        
        # Tab Width
        #self.tabWidget_tsi_configuration.setStyleSheet("QTabBar::tab { height: 30px; width: 130px;}")    
        
        # Axes Configuration for Detector Widget
        self.wideband_zoom = False
        self.wideband_zoom_start = 0
        self.wideband_zoom_end = 6000e6
        
        # Under Construction Labels
        self.label_under_construction1.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/under_construction.png"))
        self.label_under_construction2.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/under_construction.png"))
        self.label_under_construction3.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/under_construction.png"))
        
        # Create Tooltip
        self.tabWidget.setTabToolTip(1,"Target Signal Identification")
        
        # Update Detector Settings
        self._slotTSI_DetectorChanged()
        
        # Default Detector Simulator File
        self.textEdit_tsi_detector_csv_file.setPlainText(os.path.dirname(os.path.realpath(__file__)) +"/Tools/TSI_Detector_Sim_Data/tsi_simulator.csv")
        
        ##### Protocol Discovery #####
        # Create Tooltip
        self.tabWidget.setTabToolTip(2,"Protocol Discovery")
        
        # Disable the Tabs
        self.tabWidget_protocol.setTabEnabled(1,False)
        self.tabWidget_protocol.setTabEnabled(2,False)
        #self.tabWidget_protocol.setTabEnabled(3,False)
        #self.tabWidget_protocol.setTabEnabled(4,False)
        #self.tabWidget_protocol.setTabEnabled(5,False)
        #self.tabWidget_protocol.setTabEnabled(6,False)
        #self.tabWidget_protocol.setTabEnabled(7,False)
        
        # Refresh Inspection Widgets
        self._slotIQ_InspectionHardwareChanged()
        
        # Configure PD\Construct Packet Tables
        self.tableWidget_pd_dissectors.resizeRowsToContents()  
                                
        # Load Protocols into Dissectors Protocol Combobox
        self.comboBox_pd_dissectors_protocol.insertItem(0,"")  
        protocols_with_packet_types = []
        for p in protocols:                        
            if len(getPacketTypes(self.pd_library,p)) > 0:  
                protocols_with_packet_types.append(p)                              
        self.comboBox_pd_dissectors_protocol.addItems(sorted(protocols_with_packet_types))
        
        # Hide the Dissectors Groupbox
        self.frame_pd_dissectors_editor.setVisible(False)
        
        # Set the Number of Lines in PD Status Message Text Edit
        self.textEdit_pd_status.document().setMaximumBlockCount(18)
        
        # Resize Protocol Discovery Bit Slicing Preamble Stats Table
        self.tableWidget_pd_bit_slicing_preamble_stats.setColumnWidth(1,97)
        self.tableWidget_pd_bit_slicing_preamble_stats.setColumnWidth(2,111) 
        self.tableWidget_pd_bit_slicing_preamble_stats.setColumnWidth(3,111)
        self.tableWidget_pd_bit_slicing_preamble_stats.setColumnWidth(4,121)
        self.tableWidget_pd_bit_slicing_preamble_stats.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch) 
        
        # Resize Protocol Discovery Bit Slicing Recommended Preamble Table
        #~ self.tableWidget_pd_bit_slicing_candidate_preambles.setColumnWidth(1,97)
        #~ self.tableWidget_pd_bit_slicing_candidate_preambles.setColumnWidth(2,111) 
        #~ self.tableWidget_pd_bit_slicing_candidate_preambles.setColumnWidth(3,111)
        #~ self.tableWidget_pd_bit_slicing_candidate_preambles.setColumnWidth(4,121)
        #~ self.tableWidget_pd_bit_slicing_candidate_preambles.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch) 
        
        # Set the PD Flow Graph Lookup Not Found Label
        self.label_pd_flow_graphs_lookup_not_found.setText("")    
        
        # Hide the Calculating Label
        self.label_pd_bit_slicing_calculating.setVisible(False)    
                
        # Load "All Flow Graphs" List Widget
        self._slotPD_DemodHardwareChanged()

        # Bit Slicing Shift Counter
        self.bit_shift_counter = 0
        
        # Hide the Unused Bit Slicing Buttons
        self.pushButton_pd_bit_slicing_detect_fields.setVisible(False)
        self.pushButton_pd_bit_slicing_varying.setVisible(False)
        self.pushButton_pd_bit_slicing_recurrent.setVisible(False)
        self.pushButton_pd_bit_slicing_uniform.setVisible(False)
        
        # Initialize New Detections/Classifications Notification
        self.new_detections = 0
        self.new_classifications = 0
        
        # Sniffer Port
        self.label_pd_sniffer_zmq_port.setText(str(self.dashboard_settings_dictionary["pd_bits_port"]))
        
        # Load Sniffer Protocols
        self.comboBox_pd_sniffer_protocols.clear()
        protocols_with_demod_fgs = []
        for p in protocols:                        
            if len(getDemodulationFlowGraphs(self.pd_library,p,"","")) > 0:  
                protocols_with_demod_fgs.append(p)
        self.comboBox_pd_sniffer_protocols.addItems(sorted(protocols_with_demod_fgs))
        
        # Load Sniffer Test Folder
        self.comboBox_pd_sniffer_test_folders.addItem(str(os.path.dirname(os.path.realpath(__file__)) + '/Crafted Packets/Defaults'))  
        self.comboBox_pd_sniffer_test_folders.addItem(str(os.path.dirname(os.path.realpath(__file__)) + '/Crafted Packets'))  
        self.comboBox_pd_sniffer_test_folders.setCurrentIndex(0)
        
        # Load Protocols into Combobox
        self.comboBox_pd_bit_viewer_protocols.clear()       
        self.comboBox_pd_bit_viewer_protocols.addItems(sorted(protocols_with_packet_types))
        
        # Common CRC Algorithms
        self.crc_algorithms8 = ['Custom','CRC8','CRC8_CDMA2000','CRC8_DARC','CRC8_DVB-S2','CRC8_EBU','CRC8_I-CODE','CRC8_ITU','CRC8_MAXIM','CRC8_ROHC','CRC8_WCDMA']
        self.crc_algorithms16 = ['Custom','CRC16_CCIT_ZERO','CRC16_ARC','CRC16_AUG_CCITT (Z-Wave)','CRC16_BUYPASS','CRC16_CCITT_FALSE','CRC16_CDMA2000','CRC16_DDS_110','CRC16_DECT_R','CRC16_DECT_X','CRC16_DNP','CRC16_EN_13757','CRC16_GENIBUS','CRC16_MAXIM','CRC16_MCRF4XX','CRC16_RIELLO','CRC16_T10_DIF','CRC16_TELEDISK','CRC16_TMS37157','CRC16_USB','CRC16_A','CRC16_KERMIT','CRC16_MODBUS','CRC16_X_25','CRC16_XMODEM']
        self.crc_algorithms32 = ['Custom','CRC32','CRC32_BZIP2','CRC32_C','CRC32_D','CRC32_MPEG-2','CRC32_POSIX','CRC32-32Q','CRC32_JAMCRC','CRC32_XFER']
        self.comboBox_pd_crc_common_width.setCurrentIndex(0)

        
        ##### Attack #####
        # Load Protocols into Combobox
        self.comboBox_attack_protocols.clear()
        protocols_with_attacks = []
        for p in protocols:                        
            if len(getAttacks(self.pd_library,p)) > 0:  
                protocols_with_attacks.append(p)
        self.comboBox_attack_protocols.addItems(sorted(protocols_with_attacks))
                        
        # Configure Attack TreeWidget
        self.populateAttackTreeWidget()
        self.treeWidget_attack_attacks.expandAll()
        self._slotAttackProtocols()
        
        # Select Something in Attack Tree Widget
        self.treeWidget_attack_attacks.setCurrentItem(self.treeWidget_attack_attacks.itemAt(0,0))
        
        # Guess Interface Index
        self.guess_index_table = 0
        
        # List of Dynamic Tables
        self.table_list = []
        
        
        ##### Packet Crafter #####
        # Load Protocols into Combobox
        self.comboBox_packet_protocols.clear()
        self.comboBox_packet_protocols.addItems(sorted(protocols_with_packet_types))
        self.scapy_data = None


        ##### IQ Data  #####
        # Set up IQ Recording Table     
        self.iq_file_counter = 0   
        self.iq_first_file_name = ''
        self.label_iq_folder.setVisible(False)
        self.iq_plot_range_start = 0
        self.iq_plot_range_end = 0
        
        new_iq_combobox4 = QtWidgets.QComboBox(self)
        self.tableWidget_iq_record.setCellWidget(0,8,new_iq_combobox4)
        new_iq_combobox4.addItem("Complex")
        #new_iq_combobox4.addItem("Float/Float 32")
        #new_iq_combobox4.addItem("Int/Int 32")
        #new_iq_combobox4.addItem("Short/Int 16")
        #new_iq_combobox4.addItem("Byte/Int 8")
        new_iq_combobox4.setSizeAdjustPolicy(0)
        new_iq_combobox4.setCurrentIndex(0)   
        
        self.tableWidget_iq_record.resizeColumnsToContents()
        
        # Set up IQ Playback Table        
        new_iq_playback_combobox3 = QtWidgets.QComboBox(self)
        self.tableWidget_iq_playback.setCellWidget(0,5,new_iq_playback_combobox3)
        new_iq_playback_combobox3.addItem("Complex")
        #new_iq_combobox4.addItem("Float/Float 32")
        #new_iq_combobox4.addItem("Int/Int 32")
        #new_iq_combobox4.addItem("Short/Int 16")
        #new_iq_combobox4.addItem("Byte/Int 8")
        new_iq_playback_combobox3.setSizeAdjustPolicy(0)
        new_iq_playback_combobox3.setCurrentIndex(0)   
        
        new_iq_playback_combobox4 = QtWidgets.QComboBox(self)
        self.tableWidget_iq_playback.setCellWidget(0,6,new_iq_playback_combobox4)
        new_iq_playback_combobox4.addItem("Yes")
        new_iq_playback_combobox4.addItem("No")
        new_iq_playback_combobox4.setSizeAdjustPolicy(0)
        new_iq_playback_combobox4.setCurrentIndex(0)  
        
        self.tableWidget_iq_playback.resizeColumnsToContents()                
        
        self.pushButton_iq_cursor1.setCheckable(True)
        self.fft_data = None
        
        # Load the Files in the Listbox            
        self.textEdit_iq_record_dir.setPlainText(str(os.path.dirname(os.path.realpath(__file__)) + '/IQ Recordings'))
        self.comboBox_iq_folders.addItem(str(os.path.dirname(os.path.realpath(__file__)) + '/IQ Recordings'))    
        self.comboBox_iq_folders.addItem(str(os.path.dirname(os.path.realpath(__file__)) + '/Archive'))  
        self.comboBox_iq_folders.setCurrentIndex(0)
        
        # Hide Range Buttons
        self.pushButton_iq_plot_prev.setVisible(False)
        self.pushButton_iq_plot_next.setVisible(False)
        
        # Transfer Files
        self.label_iq_transfer_folder_success.setVisible(False)
        self.label_iq_transfer_file_success.setVisible(False)
        
        # Settings Icon
        self.pushButton_iq_FunctionsSettings.setIcon(QtGui.QIcon(os.path.dirname(os.path.realpath(__file__)) + "/Icons/settings.png"))

        
        ##### Archive #####   
        self.comboBox_archive_download_folder.addItem(str(os.path.dirname(os.path.realpath(__file__)) + '/Archive'))   
        self.comboBox_archive_download_folder.addItem(str(os.path.dirname(os.path.realpath(__file__)) + '/IQ Recordings'))   
        self._slotArchiveDownloadFoldersChanged()
        self.populateArchive()
        self.label_archive_replay_status.setVisible(False)
        self.tableWidget_archive_replay.setColumnHidden(9,True) 
        
        
        ##### Log #####   
        # Clear the Log File
        if self.dashboard_settings_dictionary['clear_log_file_on_startup'] == True:
            open(os.path.dirname(os.path.realpath(__file__)) + "/Logs/event.log", "w+").close()  
            
        # Configure Log File
        with open(os.path.dirname(os.path.realpath(__file__)) + "/YAML/logging.yaml", 'rt') as f:
            config = yaml.load(f.read(), yaml.FullLoader)
            config["handlers"]["file"]["filename"] = os.path.dirname(os.path.realpath(__file__)) + "/" + config["handlers"]["file"]["filename"]
        logging.config.dictConfig(config)   
        
        
        ##### Other #####
        # Potential Colors for Fields
        self.suitable_colors = [(204,255,255), (153,255,255), (102,255,255), (51,255,255), (0,255,255), (153,204,255), (153,204,204), \
                           (102,255,204), (102,255,153), (51,255,204), (0,255,204), (0,255,153), \
                           (204,204,153), (204,204,102), (204,204,255), (204,153,102), (204,153,51), (204,204,51), (204,204,0), \
                           (204,255,153), (153,255,204), (153,255,153), (204,255,102), (153,204,153), (51,255,153), (51,255,51), (51,255,102), (0,204,102), (102,204,153), (153,204,102), (204,255,51), (153,255,102), (153,255,51), (102,255,102), (0,238,00), (0,221,0), \
                           (238,238,238), (221,221,221), (204,204,204), (187,187,187), \
                           (255,204,102), (255,204,51), \
                           (255,204,255), (255,204,204), (255,204,153), (255,204,51), \
                           (204,204,255), \
                           (255,255,204), (255,255,153), (255,255,102), (255,255,51), (255,255,0),(255,153,102)]
        random.shuffle(self.suitable_colors)

        #~ #############################################################
        #~ Blue:       CCFFFF, 99FFFF, 66FFFF, 33FFFF, 00FFFF, 99CCFF, 99CCCC
        #~             (204,255,255), (153,255,255), (102,255,255), (51,255,255), (0,255,255), (153,204,255), (153,204,204)
        #~ Blue-Green: 66FFCC, 66FF99, 33FFCC, 00FFCC, 00FF99
        #~             (102,255,204), (102,255,153), (51,255,204), (0,255,204), (0,255,153)
        #~ Brown:      CCCC99, CCCC66, CCCCFF, CC9966, CC9933, CCCC33, CCCC00 
        #~             (204,204,153), (204,204,102), (204,204,255), (204,153,102), (204,153,51), (204,204,51), (204,204,0)
        #~ Green:      CCFF99, 99FFCC, 99FF99, CCFF66, 99CC99, 33FF99, 33FF33, 33FF66, 00CC66, 66CC99, 99CC66, CCFF33, 99FF66, 99FF33, 66FF66, 00EE00, 00DD00 
        #~             (204,255,153), (153,255,204), (153,255,153), (204,255,102), (153,204,153), (51,255,153), (51,255,51), (51,255,102), (0,204,102), (102,204,153), (153,204,102), (204,255,51), (153,255,102), (153,255,51), (102,255,102), (0,238,00), (0,221,0)
        #~ Grey:       EEEEEE, DDDDDD, CCCCCC, BBBBBB 
        #~             (238,238,238), (221,221,221), (204,204,204), (187,187,187)
        #~ Orange:     FFCC66, FFCC33
        #~             (255,204,102), (255,204,51)
        #~ Pink:       FFCCFF, FFCCCC, FFCC99, FFCC33 
        #~             (255,204,255), (255,204,204), (255,204,153), (255,204,51)
        #~ Purple:     CCCCFF 
        #~             (204,204,255)
        #~ Yellow:     FFFFCC, FFFF99, FFFF66, FFFF33, FFFF00, FF9966            
        #~             (255,255,204), (255,255,153), (255,255,102), (255,255,51), (255,255,0),(255,153,102)
        #~ #############################################################
                
        # Disable the Tabs
        self.tabWidget.setTabEnabled(1,False)
        self.tabWidget.setTabEnabled(2,False)
        self.tabWidget.setTabEnabled(3,False)
        self.tabWidget.setTabEnabled(4,False)
        self.tabWidget.setTabEnabled(5,False)
        self.tabWidget.setTabEnabled(6,False)
        self.tabWidget.setTabEnabled(7,False) 
        self.tabWidget.setTabEnabled(8,False) 
                
        # Set Heartbeat Variables
        self.hiprfisr_connected = False
        self.hiprfisr_heartbeat_time = time.time()
        self.dashboard_heartbeat_time = time.time()


        ##### Networking and Components #####   
		# Load the HIPRFISR        
        os.system("python3 " + os.path.dirname(os.path.realpath(__file__)) + "/hiprfisr.py &")
        #time.sleep(1)
                  
		# Create Connections    
        dashboard_ip_address = '127.0.0.1'
        hiprfisr_ip_address = '127.0.0.1'
        tsi_ip_address = '127.0.0.1'
        fge_ip_address = '127.0.0.1'
        pd_ip_address = '127.0.0.1'        
        dashboard_dealer_port = int(self.dashboard_settings_dictionary['dashboard_hiprfisr_dealer_port'])
        dashboard_pub_port = int(self.dashboard_settings_dictionary['dashboard_pub_port'])
        hiprfisr_pub_port = int(self.dashboard_settings_dictionary['hiprfisr_pub_port'])
        tsi_pub_port = int(self.dashboard_settings_dictionary['tsi_pub_port'])
        tsi_pub_port_id = int(self.dashboard_settings_dictionary['tsi_pub_port_id'])
        tsi_pub_port_classification = int(self.dashboard_settings_dictionary['tsi_pub_port_classification'])
        fge_pub_port = int(self.dashboard_settings_dictionary['fge_pub_port'])
        pd_pub_port = int(self.dashboard_settings_dictionary['pd_pub_port'])
        
        # Dealer-Dealer
        self.dashboard_hiprfisr_server = fissure_server(os.path.dirname(os.path.realpath(__file__)) + '/YAML/dashboard.yaml',dashboard_ip_address,dashboard_dealer_port,zmq.DEALER, logcfg = os.path.dirname(os.path.realpath(__file__)) + "/YAML/logging.yaml", logsource = "dashboard") 
        
        # Dashboard PUB
        self.dashboard_pub_server = fissure_server(os.path.dirname(os.path.realpath(__file__)) + '/YAML/dashboard.yaml',dashboard_ip_address,dashboard_pub_port,zmq.PUB, logcfg = os.path.dirname(os.path.realpath(__file__)) + "/YAML/logging.yaml", logsource = "dashboard")
       
        # Dashboard SUB to HIPRFISR PUB
        try:
            self.dashboard_sub_listener = fissure_listener(os.path.dirname(os.path.realpath(__file__)) + '/YAML/dashboard.yaml',hiprfisr_ip_address,hiprfisr_pub_port,zmq.SUB, logcfg = os.path.dirname(os.path.realpath(__file__)) + "/YAML/logging.yaml", logsource = "dashboard")
        except:
            print("Error creating Dashboard SUB and connecting to HIPRFISR PUB")
        
        # Dashboard SUB to TSI PUBs
        try:               
            self.dashboard_sub_listener.initialize_port(tsi_ip_address,tsi_pub_port) 
            self.dashboard_sub_listener.initialize_port(tsi_ip_address,tsi_pub_port_id) 
            self.dashboard_sub_listener.initialize_port(tsi_ip_address,tsi_pub_port_classification) 
   
        except:
            print("Unable to connect Dashboard SUB to TSI PUB")
            
        # Dashboard SUB to FGE PUB
        try:
            self.dashboard_sub_listener.initialize_port(fge_ip_address,fge_pub_port)
        except:
            print("Unable to connect Dashboard SUB to FGE PUB")
            
        # Dashboard SUB to PD PUB  
        try:
            self.dashboard_sub_listener.initialize_port(pd_ip_address,pd_pub_port)
        except:
            print("Unable to connect Dashboard SUB to PD PUB")                       
                
        # Make a new Thread (While Loop)
        self.startListener()
        
		# Load the HIPRFISR    
        time.sleep(1)
        os.system("python3 " + os.path.dirname(os.path.realpath(__file__)) + "/tsi_component.py &")       
        os.system("python3 " + os.path.dirname(os.path.realpath(__file__)) + "/fg_executor.py &")         
        os.system("python3 " + os.path.dirname(os.path.realpath(__file__)) + "/protocol_discovery.py &")  
        
        # Send One Heartbeat to Appear Connected While Loading
        current_time = time.time()
        self.dashboard_heartbeat_time = current_time
        self.dashboard_pub_server.sendmsg('Heartbeats', Identifier = 'Dashboard', MessageName='Heartbeat', Time=current_time)   
        

    def _myEventListener(self, stop_event):
        """ Loop for updating plots and information
        """                
        state = True
        total_time = 0
        loop_time_interval = 1  # in seconds
        wideband_time_interval = 1
        narrowband_time_interval = 60  
            
        while state and not stop_event.isSet():

            # Single Loop Start Time
            start_time = time.time()
            
            # Shift Wideband Rows Down
            if (total_time % wideband_time_interval == 0) and (total_time != 0):
                shift = 20            
                self.wideband_data[shift:self.wideband_height-1 , 0:self.wideband_width-1] = self.wideband_data[0:self.wideband_height-1-shift, 0:self.wideband_width-1]
                self.wideband_data[0:shift, 0:self.wideband_width-1] = (1,1,1)
            
            # # Shift Narrowband Rows Down
            # if (total_time % narrowband_time_interval == 0) and (total_time != 0):
                # shift = 20            
                # self.narrowband_data[shift:self.narrowband_height-1 , 0:self.narrowband_width-1] = self.narrowband_data[0:self.narrowband_height-1-shift, 0:self.narrowband_width-1]
                # self.narrowband_data[0:shift, 0:self.narrowband_width-1] = (1,1,1)
                    
            # Check the SUB
            parsed = ''
            while parsed != None:
                parsed = self.dashboard_sub_listener.recvmsg()  
                if parsed != None:   
                    # TSI Messages
                    if parsed['Identifier'] == 'TSI':
                        # Wideband Messages
                        if parsed['Type'] == 'Wideband':
                            # Add Signals to Wideband List & Plot
                            wideband_signal = (float(parsed['Frequency'])/1e6, int(parsed['Power']), float(parsed['Timestamp']))
                            self.signal_addWideband.emit(wideband_signal)
            
                        # # Narrowband Messages
                        # elif parsed['Type'] == 'SOI':                    
                            # # Check if SOI is Blacklisted
                            # blacklisted = False
                            # for soi in self.soi_blacklist:                            
                                # if soi == parsed['Frequency'] + "," + parsed['ModulationType']:
                                    # blacklisted = True
                            
                            # # Add it to the Plot & Table        
                            # if blacklisted == False:          
                                # narrowband_signal = (float(parsed['Frequency'])/1e6,int(parsed['Power']),parsed['ModulationType'], float(parsed['Bandwidth'])/1e6, parsed['Continuous'], float(parsed['StartFrequency'])/1e6, float(parsed['EndFrequency'])/1e6, float(parsed['Timestamp']), (parsed['Confidence']))
                                # self.signal_addNarrowband.emit(narrowband_signal)
                                
                        # Status Messages
                        elif parsed['Type'] == 'Status':    
                            if parsed['MessageName'] == 'Flow Graph Finished IQ':
                                self.signal_flowGraphFinishedIQ.emit()
                            elif parsed['MessageName'] == 'Flow Graph Started IQ':
                                self.signal_flowGraphStartedIQ.emit()
                            elif parsed['MessageName'] == 'Detector Flow Graph Error':
                                self.signal_detectorFlowGraphError.emit(parsed['Parameters'])
                            elif parsed['MessageName'] == 'BandID':
                                self.signal_bandID.emit(parsed['Parameters'])                                
                                                    
                    # HIPRFISR Messages
                    elif parsed['Identifier'] == 'HIPRFISR':
                        # Heartbeat Messages (HIPRFISR handles the other heartbeats)
                        if parsed['Type'] == 'Heartbeats':    
                            self.hiprfisr_heartbeat_time = parsed['Time']
                        if parsed['Type'] == 'Status':  
                            if parsed['MessageName'] == 'Full Library':                        
                                self.signal_setFullLibrary.emit(parsed['Parameters'])                             
                        
                    # FGE Messages
                    elif parsed['Identifier'] == 'FGE':    
                        if parsed['Type'] == 'Status':    
                            if parsed['MessageName'] == 'Flow Graph Finished':    
                                self.signal_flowGraphFinished.emit(parsed['Parameters'])    
                            elif parsed['MessageName'] == 'Flow Graph Started':    
                                self.signal_flowGraphStarted.emit(parsed['Parameters'])    
                            elif parsed['MessageName'] == 'Flow Graph Error':    
                                self.signal_flowGraphError.emit(parsed['Parameters'])    
                            elif parsed['MessageName'] == 'Multi-Stage Attack Finished':
                                self.signal_multiStageAttackFinished.emit()   
                            elif parsed['MessageName'] == 'Archive Playlist Finished':
                                self.signal_archivePlaylistFinished.emit()       
                            elif parsed['MessageName'] == 'Flow Graph Finished IQ':
                                self.signal_flowGraphFinishedIQ.emit()
                            elif parsed['MessageName'] == 'Flow Graph Finished IQ Playback':
                                self.signal_flowGraphFinishedIQ_Playback.emit()
                            elif parsed['MessageName'] == 'Flow Graph Finished IQ Inspection':
                                self.signal_flowGraphFinishedIQ_Inspection.emit()
                            elif parsed['MessageName'] == 'Flow Graph Finished Sniffer':
                                self.signal_flowGraphFinishedSniffer.emit(parsed['Parameters'])
                            elif parsed['MessageName'] == 'Flow Graph Started IQ':
                                self.signal_flowGraphStartedIQ.emit()    
                            elif parsed['MessageName'] == 'Flow Graph Started IQ Playback':
                                self.signal_flowGraphStartedIQ_Playback.emit()  
                            elif parsed['MessageName'] == 'Flow Graph Started IQ Inspection':
                                self.signal_flowGraphStartedIQ_Inspection.emit()  
                            elif parsed['MessageName'] == 'Flow Graph Started Sniffer':
                                self.signal_flowGraphStartedSniffer.emit(parsed['Parameters'])  
                            elif parsed['MessageName'] == 'Archive Playlist Position':    
                                self.signal_archivePlaylistPosition.emit(parsed['Parameters']) 
                        
                    # Protocol Discovery Messages
                    elif parsed['Identifier'] == 'PD':
                        if parsed['Type'] == 'Status':                                
                            if parsed['MessageName'] == 'Set Recommended Flow Graphs':
                                self.signal_setRecommendedFlowGraphs.emit(parsed['Parameters'])   
                            elif parsed['MessageName'] == 'Found Preambles':
                                status_text = time.strftime('%H:%M:%S', time.localtime()) + ": Found Preambles\n"
                                self.signal_PD_AddStatus.emit(status_text)
                                self.signal_pdBitSlicingPreamblesReturned.emit(parsed['Parameters'])
                            elif parsed['MessageName'] == 'Found Preambles in Library':
                                self.signal_PD_AddStatus.emit(time.strftime('%H:%M:%S', time.localtime()) + ": Found Preambles in Library: " + repr(parsed['Parameters']) + "\n")   
                                self.signal_pdBitSlicingLibraryLookupReturned.emit(parsed['Parameters'])    
                            elif parsed['MessageName'] == 'Slice By Preamble Return':
                                self.signal_pdBitSlicingSliceByPreambleReturn.emit(parsed['Parameters'])    
                            elif parsed['MessageName'] == 'Buffer Size':
                                self.signal_pdBufferSize.emit(parsed['Parameters'])
                            elif parsed['MessageName'] == 'Entropy Return':
                                self.signal_pdBitSlicingEntropyReturn.emit(parsed['Parameters'])                            
                                
            # Check for HIPRFISR Messages
            parsed = ''
            while parsed != None:
                parsed = self.dashboard_hiprfisr_server.recvmsg()   
                if parsed != None:   
                    # Status Messages 
                    if parsed['Type'] == 'Status':
                        # Status: Connected
                        if parsed['MessageName'] == 'Connected':
                            if parsed['Parameters'] == 'Dashboard':        
                                self.statusbar_dashboard.setText("Dashboard: OK")                        
                            elif parsed['Parameters'] == 'TSI':
                                self.signal_TSI_Online.emit()                                               
                                #self.emit(self.signal_TSI_Online)                                               
                            elif parsed['Parameters'] == 'FGE':
                                self.signal_FGE_Online.emit()  
                            elif parsed['Parameters'] == 'PD':
                                self.signal_PD_Online.emit()
                                
                        # Status: Disconnected 
                        elif parsed['MessageName'] == 'Disconnected':
                            if parsed['Parameters'] == 'Dashboard':                             
                                self.statusbar_dashboard.setText("Dashboard: XX")
                            elif parsed['Parameters'] == 'TSI':
                                self.signal_TSI_Offline.emit()
                            elif parsed['Parameters'] == 'FGE':
                                self.signal_FGE_Offline.emit()
                            elif parsed['Parameters'] == 'PD':
                                self.signal_PD_Offline.emit()
                        
                        # Status: SOI Chosen
                        elif parsed['MessageName'] == 'SOI Chosen':
                            self.signal_SOI_Chosen.emit(parsed['Parameters'])
                             
            # Plot and Draw Incoming Wideband Signals When Running Detector
            if self.pushButton_tsi_detector_start.text() == "Stop":
                self.matplotlib_widget.axes.cla()
                self.matplotlib_widget.axes.imshow(self.wideband_data, cmap='rainbow', clim=(-100,30), extent=[0,1201,801,0]) 
                if self.wideband_zoom == True:   
                    self.matplotlib_widget.configureAxesZoom1(self.wideband_zoom_start, self.wideband_zoom_end, self.wideband_height)
                else:
                    self.matplotlib_widget.configureAxes(title='Detector History',xlabel='Frequency (MHz)',ylabel='Time Elapsed (s)', xlabels=['0', '','1000', '', '2000', '', '3000', '', '4000', '', '5000', '', '6000'],ylabels=['0', '5', '10', '15', '20', '25', '30', '35', '40'],ylim=self.wideband_height)
                self.matplotlib_widget.draw()

            # # Plot and Draw Incoming Narrowband Signals
            # self.nb_matplotlib_widget.axes.imshow(self.narrowband_data, cmap='rainbow', clim=(-100,30))                            
            # self.nb_matplotlib_widget.configureAxes(title='Classifier History',xlabel='Frequency (MHz)',ylabel='Time Elapsed (min)', xlabels=['0', '', '500', '','1000', '', '1500', '', '2000', '', '2500', '', '3000', '', '3500', '', '4000', '', '4500', '', '5000', '', '5500', '', '6000'],ylabels=['0', '5', '10', '15', '20'],ylim=self.narrowband_height)
            # self.nb_matplotlib_widget.draw()   
            
            # Update Start/End Frequency Spin Boxes
            if self.tuning_matplotlib_widget.needs_update == True:
                self.spinBox_tsi_sdr_start.setValue(int(self.tuning_matplotlib_widget.first_click))
                self.spinBox_tsi_sdr_end.setValue(int(self.tuning_matplotlib_widget.second_click))
                self.tuning_matplotlib_widget.needs_update = False        
            
            # Send Heartbeats on the PUB
            current_time = time.time()
            if self.dashboard_heartbeat_time < current_time - float(self.dashboard_settings_dictionary['heartbeat_interval']):
                self.dashboard_heartbeat_time = current_time
                self.dashboard_pub_server.sendmsg('Heartbeats', Identifier = 'Dashboard', MessageName='Heartbeat', Time=current_time)
                
            # Check HIPRFISR Heartbeat
            self.checkHeartbeats()    
                        
            # Update the Total Time            
            total_time = total_time + loop_time_interval
            
            # Sleep the Remainder of the Time Interval
            time_difference = loop_time_interval-(time.time()-start_time)
            if time_difference > 0:
                time.sleep(time_difference)
            
    def startListener(self):
        """ Starts the loop
        """
        self.stop_event = threading.Event()
        self.c_thread = threading.Thread(target=self._myEventListener, args=(self.stop_event,))
        self.c_thread.start()
        
    def stopListener(self):
        """ Stops the loop
        """
        try:
            self.stop_event.set()
        except: 
            pass
        
    def _connectSlots(self):
        """ Contains the connect functions for all the signals and slots
        """
        # Push Buttons
        self.pushButton_top_tsi.clicked.connect(self._slotTopTSI_Clicked)
        self.pushButton_top_pd.clicked.connect(self._slotTopPD_Clicked)
        self.pushButton_top_attack.clicked.connect(self._slotTopAttackClicked)
        self.pushButton_top_iq.clicked.connect(self._slotTopIQ_Clicked)        
        self.pushButton_top_archive.clicked.connect(self._slotTopArchiveClicked)  
                
        self.pushButton_automation_system_start.clicked.connect(self._slotAutomationSystemStartClicked)
        self.pushButton_automation_soi_priority_add_level.clicked.connect(self._slotAutomationSOI_PriorityAddLevelClicked)
        self.pushButton_automation_soi_priority_remove_level.clicked.connect(self._slotAutomationSOI_PriorityRemoveLevelClicked)
        self.pushButton_automation_system_reset.clicked.connect(self._slotAutomationSystemResetClicked)
        self.pushButton_automation_manual.clicked.connect(self._slotAutomationManualClicked)
        self.pushButton_automation_discovery.clicked.connect(self._slotAutomationDiscoveryClicked)
        self.pushButton_automation_target.clicked.connect(self._slotAutomationTargetClicked)
        self.pushButton_automation_custom.clicked.connect(self._slotAutomationCustomClicked)
        
        self.pushButton_library_gallery_next.clicked.connect(self._slotLibraryGalleryNextClicked)
        self.pushButton_library_gallery_open.clicked.connect(self._slotLibraryGalleryOpenClicked)
        self.pushButton_library_gallery_previous.clicked.connect(self._slotLibraryGalleryPreviousClicked)
        self.pushButton_library_browse_remove_demod_fg.clicked.connect(self._slotLibraryBrowseRemoveDemodFG_Clicked)
        self.pushButton_library_browse_remove_soi.clicked.connect(self._slotLibraryBrowseRemoveSOI_Clicked)
        self.pushButton_library_browse_remove_packet_type.clicked.connect(self._slotLibraryBrowseRemovePacketTypeClicked)
        self.pushButton_library_browse_remove_modulation.clicked.connect(self._slotLibraryBrowseRemoveModulationClicked)
        self.pushButton_library_search_search_library.clicked.connect(self._slotLibrarySearchSearchLibraryClicked)
        self.pushButton_library_search_current_soi.clicked.connect(self._slotLibrarySearchCurrentSOI_Clicked)
        self.pushButton_library_pd_add_to_library.clicked.connect(self._slotLibraryAddAddToLibrary_Clicked)
        self.pushButton_library_pd_browse.clicked.connect(self._slotLibraryAddBrowseClicked)
        self.pushButton_library_pd_current_soi.clicked.connect(self._slotLibraryAddCurrentSOI_Clicked)
        self.pushButton_library_pd_add_field.clicked.connect(self._slotLibraryAddAddFieldClicked)
        self.pushButton_library_pd_remove_field.clicked.connect(self._slotLibraryAddRemoveFieldClicked)
        self.pushButton_library_pd_up.clicked.connect(self._slotLibraryAddUpClicked)
        self.pushButton_library_pd_down.clicked.connect(self._slotLibraryAddDownClicked)
        self.pushButton_library_attacks_file.clicked.connect(self._slotLibraryAddAttacksSelectClicked)
        self.pushButton_library_attacks_remove.clicked.connect(self._slotLibraryRemoveAttacksRemoveClicked) 
        self.pushButton_library_remove_protocol.clicked.connect(self._slotLibraryRemoveProtocolClicked)     
              
        self.pushButton_tsi_clear_wideband_list.clicked.connect(self._slotTSI_ClearWidebandListClicked)
        self.pushButton_tsi_clear_SOI_list.clicked.connect(self._slotTSI_ClearSOI_ListClicked)
        self.pushButton_tsi_add_band.clicked.connect(self._slotTSI_AddBandClicked)
        self.pushButton_tsi_remove_band.clicked.connect(self._slotTSI_RemoveBandClicked)
        self.pushButton_tsi_update.clicked.connect(self._slotTSI_UpdateTSI_Clicked)
        self.pushButton_tsi_save_preset.clicked.connect(self._slotTSI_SavePresetClicked)
        self.pushButton_tsi_delete_preset.clicked.connect(self._slotTSI_DeletePresetClicked)   
        self.pushButton_tsi_ignore.clicked.connect(self._slotTSI_SOI_BlacklistClicked)
        self.pushButton_tsi_soi_blacklist_remove.clicked.connect(self._slotTSI_SOI_BlacklistRemoveClicked)
        self.pushButton_tsi_untarget.clicked.connect(self._slotTSI_SOI_UntargetClicked)
        self.pushButton_tsi_blacklist_add.clicked.connect(self._slotTSI_BlacklistAddClicked)
        self.pushButton_tsi_blacklist_remove.clicked.connect(self._slotTSI_BlacklistRemoveClicked)
        self.pushButton_tsi_detector_start.clicked.connect(self._slotTSI_DetectorStartClicked)
        self.pushButton_tsi_clear_detector_plot.clicked.connect(self._slotTSI_ClearDetectorPlotClicked)
        self.pushButton_tsi_refresh.clicked.connect(self._slotTSI_RefreshPlotClicked)
        self.pushButton_tsi_zoom_in.clicked.connect(self._slotTSI_ZoomInClicked)
        self.pushButton_tsi_advanced_settings.clicked.connect(self._slotTSI_AdvancedSettingsClicked)
        self.pushButton_tsi_back1.clicked.connect(self._slotTSI_Back1_Clicked)
        self.pushButton_tsi_detector_iq_file_browse.clicked.connect(self._slotTSI_DetectorIQ_FileBrowseClicked)
        self.pushButton_tsi_detector_search.clicked.connect(self._slotTSI_DetectorSearchClicked)
        self.pushButton_tsi_detector_csv_file_browse.clicked.connect(self._slotTSI_DetectorCSV_FileBrowseClicked)
        self.pushButton_tsi_detector_csv_file_edit.clicked.connect(self._slotTSI_DetectorCSV_FileEditClicked)

        self.pushButton_pd_status_untarget.clicked.connect(self._slotTSI_SOI_UntargetClicked)
        self.pushButton_pd_status_soi_new.clicked.connect(self._slotPD_StatusSOI_NewClicked)
        self.pushButton_pd_status_search_library.clicked.connect(self._slotPD_StatusSearchLibraryClicked)
        self.pushButton_pd_status_buffer_apply.clicked.connect(self._slotPD_StatusBufferApplyClicked)
        self.pushButton_pd_status_buffer_clear.clicked.connect(self._slotPD_StatusBufferClearClicked)
        self.pushButton_pd_status_start.clicked.connect(self._slotPD_StatusStartClicked)
        self.pushButton_pd_status_blacklist_soi.clicked.connect(self._slotPD_StatusBlacklistSOI_Clicked)   
        self.pushButton_pd_status_add_pub.clicked.connect(self._slotPD_StatusAddPubClicked)
        self.pushButton_pd_status_remove_pub.clicked.connect(self._slotPD_StatusRemovePubClicked)    
        self.pushButton_pd_flow_graphs_current_soi.clicked.connect(self._slotPD_DemodulationCurrentSOI_Clicked)
        self.pushButton_pd_flow_graphs_view.clicked.connect(self._slotPD_DemodulationViewFlowGraphClicked)
        self.pushButton_pd_flow_graphs_load.clicked.connect(self._slotPD_DemodulationLoadFlowGraphClicked)
        self.pushButton_pd_flow_graphs_load_selected.clicked.connect(self._slotPD_DemodulationLoadSelectedClicked)
        self.pushButton_pd_flow_graphs_lookup_clear.clicked.connect(self._slotPD_DemodulationLookupClearClicked)
        self.pushButton_pd_flow_graphs_lookup.clicked.connect(self._slotPD_DemodulationLookupClicked)
        self.pushButton_pd_flow_graphs_start_stop.clicked.connect(self._slotPD_DemodulationStartStopClicked)
        self.pushButton_pd_flow_graphs_apply_changes.clicked.connect(self._slotPD_DemodulationApplyChangesClicked)
        self.pushButton_pd_flow_graphs_restore_defaults.clicked.connect(self._slotPD_DemodulationRestoreDefaultsClicked)
        self.pushButton_pd_flow_graphs_auto_select.clicked.connect(self._slotTSI_SOI_UntargetClicked)   
        self.pushButton_pd_flow_graphs_load_selected_all.clicked.connect(self._slotPD_DemodulationLoadSelectedAllClicked)                              
        self.pushButton_pd_bit_slicing_find_preambles.clicked.connect(self._slotPD_BitSlicingFindPreamblesClicked)
        self.pushButton_pd_bit_slicing_slice_by_preamble.clicked.connect(self._slotPD_BitSlicingSliceByPreambleClicked)
        self.pushButton_pd_bit_slicing_detect_fields.clicked.connect(self._slotPD_BitSlicingDetectFieldsClicked)
        self.pushButton_pd_bit_slicing_refresh.clicked.connect(self._slotPD_BitSlicingRefreshClicked)
        self.pushButton_pd_bit_slicing_remove_field.clicked.connect(self._slotPD_BitSlicingRemoveFieldClicked)
        self.pushButton_pd_bit_slicing_insert_field.clicked.connect(self._slotPD_BitSlicingInsertFieldClicked)
        self.pushButton_pd_bit_slicing_add_to_library.clicked.connect(self._slotPD_BitSlicingAddToLibraryClicked)
        self.pushButton_pd_bit_slicing_clear_buffer.clicked.connect(self._slotPD_StatusBufferClearClicked)        
        self.pushButton_pd_bit_slicing_search_library.clicked.connect(self._slotPD_BitSlicingSearchLibraryClicked)
        self.pushButton_pd_bit_slicing_reset.clicked.connect(self._slotPD_BitSlicingLengthsChanged)
        self.pushButton_pd_bit_slicing_slice.clicked.connect(self._slotPD_BitSlicingSliceClicked)
        self.pushButton_pd_bit_slicing_merge_fields.clicked.connect(self._slotPD_BitSlicingMergeFieldsClicked)
        self.pushButton_pd_bit_slicing_split_fields.clicked.connect(self._slotPD_BitSlicingSplitFieldsClicked)
        self.pushButton_pd_bit_slicing_plot_entropy.clicked.connect(self._slotPD_BitSlicingPlotEntropyClicked)
        self.pushButton_pd_bit_slicing_shift_left.clicked.connect(self._slotPD_BitSlicingShiftLeftClicked)
        self.pushButton_pd_bit_slicing_shift_right.clicked.connect(self._slotPD_BitSlicingShiftRightClicked)      
        self.pushButton_pd_bit_viewer_hex.clicked.connect(self._slotPD_BitViewerHexClicked)
        self.pushButton_pd_bit_viewer_sort.clicked.connect(self._slotPD_BitViewerSortClicked)
        self.pushButton_pd_bit_viewer_send_to_buffer.clicked.connect(self._slotPD_BitViewerSendToBufferClicked)
        self.pushButton_pd_bit_viewer_table_sort.clicked.connect(self._slotPD_BitViewerTableSortClicked)
        self.pushButton_pd_bit_viewer_fill_table.clicked.connect(self._slotPD_BitViewerFillTableClicked)
        self.pushButton_pd_bit_viewer_apply.clicked.connect(self._slotPD_BitViewerApplyClicked)
        self.pushButton_pd_bit_viewer_invert.clicked.connect(self._slotPD_BitViewerInvertClicked)
        self.pushButton_pd_bit_viewer_differential.clicked.connect(self._slotPD_BitViewerDifferentialClicked)
        self.pushButton_pd_bit_viewer_man_enc.clicked.connect(self._slotPD_BitViewerManEncClicked)
        self.pushButton_pd_bit_viewer_man_dec.clicked.connect(self._slotPD_BitViewerManDecClicked)
        self.pushButton_pd_bit_viewer_undiff0.clicked.connect(self._slotPD_BitViewerUnDiff0Clicked)
        self.pushButton_pd_bit_viewer_undiff1.clicked.connect(self._slotPD_BitViewerUnDiff1Clicked)
        self.pushButton_pd_bit_viewer_bin.clicked.connect(self._slotPD_BitViewerBinClicked)          
        self.pushButton_pd_dissectors_new.clicked.connect(self._slotPD_DissectorsNewClicked)
        self.pushButton_pd_dissectors_edit.clicked.connect(self._slotPD_DissectorsEditClicked)
        self.pushButton_pd_dissectors_add_field.clicked.connect(self._slotPD_DissectorsAddFieldClicked)
        self.pushButton_pd_dissectors_remove_field.clicked.connect(self._slotPD_DissectorsRemoveFieldClicked)
        self.pushButton_pd_dissectors_up.clicked.connect(self._slotPD_DissectorsUpClicked)
        self.pushButton_pd_dissectors_down.clicked.connect(self._slotPD_DissectorsDownClicked)
        self.pushButton_pd_dissectors_construct.clicked.connect(lambda: self._slotPD_DissectorsConstructClicked(preview = False))
        self.pushButton_pd_dissectors_preview.clicked.connect(self._slotPD_DissectorsPreviewClicked)
        self.pushButton_pd_dissectors_update_all.clicked.connect(self._slotPD_DissectorsUpdateAllClicked)
        self.pushButton_pd_dissectors_remove.clicked.connect(self._slotPD_DissectorRemoveClicked)
        self.pushButton_pd_dissectors_apply.clicked.connect(self._slotPD_DissectorApplyClicked)
        self.pushButton_pd_sniffer_stream.clicked.connect(self._slotPD_SnifferStreamClicked)
        self.pushButton_pd_sniffer_wireshark_80211.clicked.connect(self._slotPD_SnifferWireshark80211Clicked)
        self.pushButton_pd_sniffer_guess.clicked.connect(self._slotPD_SnifferGuessClicked)
        self.pushButton_pd_sniffer_netcat.clicked.connect(self._slotPD_SnifferNetcatClicked)
        self.pushButton_pd_sniffer_tagged_stream.clicked.connect(self._slotPD_SnifferTaggedStreamClicked)
        self.pushButton_pd_sniffer_msg_pdu.clicked.connect(self._slotPD_SnifferMsgPduClicked)
        self.pushButton_pd_sniffer_test_folder.clicked.connect(self._slotPD_SnifferTestFolderClicked)
        self.pushButton_pd_sniffer_test_send.clicked.connect(self._slotPD_SnifferTestSendClicked)        
        self.pushButton_pd_crc_start.clicked.connect(self._slotPD_CRC_StartClicked)
        self.pushButton_pd_crc_calculate_common.clicked.connect(self._slotPD_CRC_CalculateClicked)
                        
        self.pushButton_attack_view_flow_graph.clicked.connect(self._slotAttackViewFlowGraph)
        self.pushButton_attack_start_stop.clicked.connect(self._slotAttackStartStopAttack)
        self.pushButton_attack_restore_defaults.clicked.connect(self._slotAttackRestoreDefaults)
        self.pushButton_attack_apply_changes.clicked.connect(self._slotAttackApplyChangesClicked)  
        self.pushButton_attack_history_delete.clicked.connect(self._slotAttackHistoryDeleteClicked)
        self.pushButton_attack_fuzzing_start.clicked.connect(self._slotAttackFuzzingStartClicked)
        self.pushButton_attack_fuzzing_apply_changes.clicked.connect(self._slotAttackFuzzingApplyChangesClicked) 
        self.pushButton_attack_fuzzing_restore_defaults.clicked.connect(self._slotAttackFuzzingRestoreDefaultsClicked)
        self.pushButton_attack_fuzzing_all_hex.clicked.connect(self._slotAttackFuzzingAllHexClicked)
        self.pushButton_attack_fuzzing_all_binary.clicked.connect(self._slotAttackFuzzingAllBinaryClicked) 
        self.pushButton_attack_fuzzing_select_file.clicked.connect(self._slotAttackFuzzingSelectFileClicked)
        self.pushButton_attack_multi_stage_add.clicked.connect(self._slotAttackMultiStageAdd)
        self.pushButton_attack_multi_stage_remove.clicked.connect(self._slotAttackMultiStageRemove)
        self.pushButton_attack_multi_stage_generate.clicked.connect(self._slotAttackMultiStageGenerate)
        self.pushButton_attack_multi_stage_up.clicked.connect(self._slotAttackMultiStageUpClicked)
        self.pushButton_attack_multi_stage_down.clicked.connect(self._slotAttackMultiStageDownClicked)
        self.pushButton_attack_multi_stage_start.clicked.connect(self._slotAttackMultiStageStartClicked)
        self.pushButton_attack_multi_stage_load.clicked.connect(lambda: self._slotAttackMultiStageLoadClicked(fname=""))
        self.pushButton_attack_multi_stage_save.clicked.connect(self._slotAttackMultiStageSaveClicked)
        self.pushButton_attack_multi_stage_clear.clicked.connect(self._slotAttackMultiStageClearClicked)   
                        
        self.pushButton_packet_restore_defaults.clicked.connect(self._slotPacketRestoreDefaultsClicked)
        self.pushButton_packet_assemble.clicked.connect(self._slotPacketAssembleClicked)
        self.pushButton_packet_save_as.clicked.connect(self._slotPacketSaveAs)
        self.pushButton_packet_calculate_crcs.clicked.connect(self._slotPacketCalculateCRCsClicked)
        self.pushButton_packet_all_hex.clicked.connect(self._slotPacketAllHexClicked)
        self.pushButton_packet_all_binary.clicked.connect(self._slotPacketAllBinaryClicked)
        self.pushButton_packet_open.clicked.connect(self._slotPacketOpenClicked)
        self.pushButton_packet_append.clicked.connect(self._slotPacketAppendClicked)
        self.pushButton_packet_scapy_show.clicked.connect(self._slotPacketScapyShowClicked)
        self.pushButton_packet_scapy_refresh.clicked.connect(self._slotPacketScapyRefreshClicked)
        self.pushButton_packet_scapy_start.clicked.connect(self._slotPacketScapyStartClicked)
        self.pushButton_packet_scapy_load.clicked.connect(self._slotPacketScapyLoadClicked)
        self.pushButton_packet_scapy_ls.clicked.connect(self._slotPacketScapyLsClicked)
        self.pushButton_packet_comma_separated.clicked.connect(self._slotPacketCommaSeparatedClicked)
        self.pushButton_packet_comma_separated2.clicked.connect(self._slotPacketCommaSeparatedClicked2)
        self.pushButton_packet_pattern1.clicked.connect(self._slotPacketPattern1Clicked)
        
        self.pushButton_iq_load_file.clicked.connect(self._slotIQ_LoadIQ_Data)
        self.pushButton_iq_dir1.clicked.connect(self._slotIQ_Dir1_Clicked)
        self.pushButton_iq_dir2.clicked.connect(self._slotIQ_Dir2_Clicked)
        self.pushButton_iq_transfer.clicked.connect(self._slotIQ_TransferClicked)
        self.pushButton_iq_plot.clicked.connect(self._slotIQ_PlotClicked)
        self.pushButton_iq_record_dir.clicked.connect(self._slotIQ_RecordDirClicked)
        self.pushButton_iq_record.clicked.connect(self._slotIQ_RecordClicked)
        self.pushButton_iq_refresh.clicked.connect(self._slotIQ_RefreshClicked)
        self.pushButton_iq_crop.clicked.connect(self._slotIQ_CropClicked)
        self.pushButton_iq_plot_all.clicked.connect(self._slotIQ_PlotAllClicked)
        self.pushButton_iq_magnitude.clicked.connect(self._slotIQ_PlotMagnitudeClicked)
        self.pushButton_iq_if.clicked.connect(self._slotIQ_PlotIF_Clicked)
        self.pushButton_iq_append_select1.clicked.connect(self._slotIQ_AppendSelect1Clicked)
        self.pushButton_iq_append_select2.clicked.connect(self._slotIQ_AppendSelect2Clicked)
        self.pushButton_iq_append_select3.clicked.connect(self._slotIQ_AppendSelect3Clicked)
        self.pushButton_iq_append_load1.clicked.connect(self._slotIQ_AppendLoad1Clicked)
        self.pushButton_iq_append_load2.clicked.connect(self._slotIQ_AppendLoad2Clicked)
        self.pushButton_iq_append_load3.clicked.connect(self._slotIQ_AppendLoad3Clicked)
        self.pushButton_iq_append_append.clicked.connect(self._slotIQ_AppendAppendClicked)
        self.pushButton_iq_delete.clicked.connect(self._slotIQ_DeleteClicked)
        self.pushButton_iq_cursor1.clicked.connect(self._slotIQ_Cursor1Clicked)
        self.pushButton_iq_get_range.clicked.connect(self._slotIQ_GetRangeClicked)
        self.pushButton_iq_overlap_store1.clicked.connect(self._slotIQ_OverlapStore1Clicked)
        self.pushButton_iq_overlap_store2.clicked.connect(self._slotIQ_OverlapStore2Clicked)
        self.pushButton_iq_overlap_plot.clicked.connect(self._slotIQ_OverlapPlotClicked)
        self.pushButton_iq_ofdm_plot_symbol_cp.clicked.connect(self._slotIQ_OFDM_PlotSymbolCP_Clicked)
        self.pushButton_iq_ofdm_magnitude.clicked.connect(self._slotIQ_OFDM_MagnitudeClicked)
        self.pushButton_iq_ofdm_cycle_adjustment.clicked.connect(self._slotIQ_OFDM_CycleAdjustmentClicked)
        self.pushButton_iq_ofdm_phase.clicked.connect(self._slotIQ_OFDM_PhaseClicked)
        self.pushButton_iq_ofdm_polar.clicked.connect(self._slotIQ_OFDM_PolarClicked)
        self.pushButton_iq_ofdm_subcarrier_add.clicked.connect(self._slotIQ_OFDM_SubcarrierAddClicked)
        self.pushButton_iq_ofdm_subcarrier_remove.clicked.connect(self._slotIQ_OFDM_SubcarrierRemoveClicked)
        self.pushButton_iq_ofdm_magnitude2.clicked.connect(self._slotIQ_OFDM_Magnitude2Clicked)
        self.pushButton_iq_ofdm_phase2.clicked.connect(self._slotIQ_OFDM_Phase2Clicked)
        self.pushButton_iq_ofdm_polar2.clicked.connect(self._slotIQ_OFDM_Polar2Clicked)
        self.pushButton_iq_ofdm_subcarrier_clear.clicked.connect(self._slotIQ_OFDM_SubcarrierClearClicked)
        self.pushButton_iq_ofdm_subcarrier_add_range.clicked.connect(self._slotIQ_OFDM_SubcarrierAddRangeClicked)
        self.pushButton_iq_ofdm_cycle_adjustment2.clicked.connect(self._slotIQ_OFDM_CycleAdjustment2Clicked)
        self.pushButton_iq_spectrogram.clicked.connect(self._slotIQ_SpectrogramClicked)
        self.pushButton_iq_fft.clicked.connect(self._slotIQ_FFT_Clicked)
        self.pushButton_iq_playback.clicked.connect(self._slotIQ_PlaybackClicked)
        self.pushButton_iq_playback_record_freq.clicked.connect(self._slotIQ_PlaybackRecordFreqClicked)
        self.pushButton_iq_playback_record_gain.clicked.connect(self._slotIQ_PlaybackRecordGainClicked)
        self.pushButton_iq_playback_record_rate.clicked.connect(self._slotIQ_PlaybackRecordRateClicked)
        self.pushButton_iq_resample.clicked.connect(self._slotIQ_ResampleClicked)
        self.pushButton_iq_inspection_fg_start.clicked.connect(self._slotIQ_InspectionFG_StartClicked)
        self.pushButton_iq_inspection_fg_load.clicked.connect(self._slotIQ_InspectionFlowGraphClicked)
        self.pushButton_iq_inspection_hackrf_qspectrumanalyzer.clicked.connect(self._slotMenuQSpectrumAnalyzerClicked)
        self.pushButton_iq_inspection_hackrf_gqrx.clicked.connect(self._slotMenuGQRX_Clicked)
        self.pushButton_iq_inspection_rtl2832u_qspectrumanalyzer.clicked.connect(self._slotMenuQSpectrumAnalyzerClicked)
        self.pushButton_iq_inspection_rtl2832u_gqrx.clicked.connect(self._slotMenuGQRX_Clicked)
        self.pushButton_iq_inspection_80211_iwlist.clicked.connect(self._slotMenuIwlistScanClicked)
        self.pushButton_iq_inspection_80211_kismet.clicked.connect(self._slotMenuKismetClicked) 
        self.pushButton_iq_inspection_rtl2832u_rds_rx.clicked.connect(self._slotMenuRdsRx2Clicked)
        self.pushButton_iq_inspection_usrp_b210_gqrx.clicked.connect(self._slotMenuGQRX_Clicked)
        self.pushButton_iq_folder.clicked.connect(self._slotIQ_FolderClicked)
        self.pushButton_iq_transfer_file_select.clicked.connect(self._slotIQ_TransferFileSelectClicked)
        self.pushButton_iq_transfer_file_save_as.clicked.connect(self._slotIQ_TransferFileSaveAsClicked)
        self.pushButton_iq_transfer_file.clicked.connect(self._slotIQ_TranferFileClicked)
        self.pushButton_iq_crop_save_as.clicked.connect(self._slotIQ_CropSaveAsClicked)
        self.pushButton_iq_plot_next.clicked.connect(self._slotIQ_PlotNextClicked)
        self.pushButton_iq_plot_prev.clicked.connect(self._slotIQ_PlotPrevClicked)
        self.pushButton_iq_timeslot_select1.clicked.connect(self._slotIQ_TimeslotSelect1Clicked)
        self.pushButton_iq_timeslot_select2.clicked.connect(self._slotIQ_TimeslotSelect2Clicked)
        self.pushButton_iq_timeslot_load1.clicked.connect(self._slotIQ_TimeslotLoad1Clicked)
        self.pushButton_iq_timeslot_load2.clicked.connect(self._slotIQ_TimeslotLoad2Clicked)
        self.pushButton_iq_timeslot_pad.clicked.connect(self._slotIQ_TimeslotPadClicked)       
        self.pushButton_iq_custom.clicked.connect(self._slotIQ_CustomClicked)
        self.pushButton_iq_rename.clicked.connect(self._slotIQ_RenameClicked)
        self.pushButton_iq_if2.clicked.connect(self._slotIQ_IF2_Clicked)
        self.pushButton_iq_morse_code.clicked.connect(self._slotIQ_MorseCodeClicked)
        self.pushButton_iq_FunctionsSettings.clicked.connect(self._slotIQ_FunctionsSettingsClicked)
        self.pushButton_iq_FunctionsLeft.clicked.connect(self._slotIQ_FunctionsLeftClicked)
        self.pushButton_iq_FunctionsRight.clicked.connect(self._slotIQ_FunctionsRightClicked)
        self.pushButton_iq_moving_average.clicked.connect(self._slotIQ_MovingAverageClicked)
        self.pushButton_iq_convert_original_load.clicked.connect(self._slotIQ_ConvertOriginalLoadClicked)        
        self.pushButton_iq_convert_new_load.clicked.connect(self._slotIQ_ConvertNewLoadClicked)        
        self.pushButton_iq_convert.clicked.connect(self._slotIQ_ConvertClicked)        
        self.pushButton_iq_convert_original_select.clicked.connect(self._slotIQ_ConvertNewSelectClicked)
        self.pushButton_iq_convert_new_select.clicked.connect(self._slotIQ_ConvertOriginalSelectClicked)
        self.pushButton_iq_convert_copy.clicked.connect(self._slotIQ_ConvertCopyClicked)
        self.pushButton_iq_terminal.clicked.connect(self._slotIQ_TerminalClicked)
        self.pushButton_iq_tab_record.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_record"))
        self.pushButton_iq_tab_playback.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_playback"))
        self.pushButton_iq_tab_inspection.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_inspection"))
        self.pushButton_iq_tab_crop.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_crop"))
        self.pushButton_iq_tab_convert.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_convert"))
        self.pushButton_iq_tab_append.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_append"))
        self.pushButton_iq_tab_transfer.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_transfer"))
        self.pushButton_iq_tab_timeslot.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_timeslot"))
        self.pushButton_iq_tab_overlap.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_overlap"))
        self.pushButton_iq_tab_resample.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_resample"))
        self.pushButton_iq_tab_ofdm.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_ofdm"))
        self.pushButton_iq_tab_normalize.clicked.connect(lambda: self._slotIQ_TabClicked(button_name = "pushButton_iq_tab_normalize"))
        self.pushButton_iq_polar.clicked.connect(self._slotIQ_PolarClicked)
        self.pushButton_iq_normalize_original_load.clicked.connect(self._slotIQ_NormalizeOriginalLoadClicked)
        self.pushButton_iq_normalize_new_load.clicked.connect(self._slotIQ_NormalizeNewLoadClicked)
        self.pushButton_iq_normalize_copy.clicked.connect(self._slotIQ_NormalizeCopyClicked)
        self.pushButton_iq_normalize.clicked.connect(self._slotIQ_NormalizeClicked)
        self.pushButton_iq_resample_original_load.clicked.connect(self._slotIQ_ResampleOriginalLoadClicked)
        self.pushButton_iq_resample_new_load.clicked.connect(self._slotIQ_ResampleNewLoadClicked)
        self.pushButton_iq_resample_original_select.clicked.connect(self._slotIQ_ResampleOriginalSelectClicked)
        self.pushButton_iq_resample_new_select.clicked.connect(self._slotIQ_ResampleNewSelectClicked)
        self.pushButton_iq_resample_copy.clicked.connect(self._slotIQ_ResampleCopyClicked)
        self.pushButton_iq_normalize_original_select.clicked.connect(self._slotIQ_NormalizeOriginalSelectClicked)
        self.pushButton_iq_normalize_new_select.clicked.connect(self._slotIQ_NormalizeNewSelectClicked)
        
        self.pushButton_archive_download_folder.clicked.connect(self._slotArchiveDownloadFolderClicked)
        self.pushButton_archive_download_refresh.clicked.connect(self._slotArchiveDownloadRefreshClicked)
        self.pushButton_archive_download_delete.clicked.connect(self._slotArchiveDownloadDeleteClicked)
        self.pushButton_archive_download_plot.clicked.connect(self._slotArchiveDownloadPlotClicked)
        self.pushButton_archive_download.clicked.connect(self._slotArchiveDownloadClicked)
        self.pushButton_archive_replay_add.clicked.connect(self._slotArchiveReplayAddClicked)
        self.pushButton_archive_replay_remove.clicked.connect(self._slotArchiveReplayRemoveClicked)
        self.pushButton_archive_replay_up.clicked.connect(self._slotArchiveReplayUpClicked)
        self.pushButton_archive_replay_down.clicked.connect(self._slotArchiveReplayDownClicked)
        self.pushButton_archive_replay_start.clicked.connect(self._slotArchiveReplayStartClicked)
        
        self.pushButton_log_refresh.clicked.connect(self._slotLogRefreshClicked)
        self.pushButton_log_refresh_permit.clicked.connect(self._slotLogRefreshPermitClicked)
        self.pushButton_log_save_all.clicked.connect(self._slotLogSaveAllClicked) 

        # Check Boxes        
        self.checkBox_automation_receive_only.clicked.connect(self._slotAutomationReceiveOnlyClicked)
        self.checkBox_automation_auto_select_sois.clicked.connect(self._slotAutomationAutoSelectSOIsClicked)
        self.checkBox_automation_lock_search_band.clicked.connect(self._slotAutomationLockSearchBandClicked)
        self.checkBox_automation_auto_start_pd.clicked.connect(self._slotAutomationAutoStartPD_Clicked)
        self.checkBox_automation_auto_select_pd_flow_graphs.clicked.connect(self._slotAutomationAutoSelectPD_FlowGraphsClicked)        
        self.checkBox_pd_bit_slicing_colors.clicked.connect(self._slotPD_BitSlicingDetectFieldsClicked)
        self.checkBox_attack_show_all.clicked.connect(self._slotAttackProtocols)
        self.checkBox_iq_append_null1.clicked.connect(self._slotIQ_AppendNull1Clicked)
        self.checkBox_iq_append_null2.clicked.connect(self._slotIQ_AppendNull2Clicked)

        # Combo Boxes       
        self.comboBox_tsi_detector.currentIndexChanged.connect(self._slotTSI_DetectorChanged)
        self.comboBox_library_gallery_protocol.currentIndexChanged.connect(self._slotLibraryGalleryProtocolChanged)
        self.comboBox_library_browse_yaml.currentIndexChanged.connect(self._slotLibraryBrowseYAML_Changed)
        self.comboBox_library_browse_protocol.currentIndexChanged.connect(self._slotLibraryRemoveProtocolChanged)
        self.comboBox_library_pd_protocol.currentIndexChanged.connect(self._slotPD_AddToLibraryProtocolChanged)
        self.comboBox_library_attacks_attack_type.currentIndexChanged.connect(self._slotAttackImportAttackTypeChanged)
        self.comboBox_library_attacks_file_type.currentIndexChanged.connect(self._slotAttackImportFileTypeChanged)    
        self.comboBox_library_pd_data_type.currentIndexChanged.connect(self._slotLibraryAddDataTypeChanged)   
        self.comboBox_iq_folders.currentIndexChanged.connect(self._slotIQ_FoldersChanged)
        self.comboBox_iq_normalize_min_max.currentIndexChanged.connect(self._slotIQ_NormalizeMinMaxChanged)
        self.comboBox_pd_demod_hardware.currentIndexChanged.connect(self._slotPD_DemodHardwareChanged)
        self.comboBox_pd_dissectors_protocol.currentIndexChanged.connect(self._slotPD_DissectorsProtocolChanged)
        self.comboBox_pd_dissectors_packet_type.currentIndexChanged.connect(self._slotPD_DissectorsPacketTypeChanged)        
        self.comboBox_pd_crc_algorithm.currentIndexChanged.connect(self._slotPD_CRC_AlgorithmChanged)
        self.comboBox_pd_crc_common_width.currentIndexChanged.connect(self._slotPD_CRC_CommonWidthChanged)
        self.comboBox_pd_bit_viewer_protocols.currentIndexChanged.connect(self._slotPD_BitViewerProtocolsChanged)
        self.comboBox_pd_bit_viewer_subcategory.currentIndexChanged.connect(self._slotPD_BitViewerSubcategoryChanged)  
        self.comboBox_attack_protocols.currentIndexChanged.connect(self._slotAttackProtocols)
        self.comboBox_attack_fuzzing_subcategory.currentIndexChanged.connect(self._slotAttackFuzzingSubcategory)    
        self.comboBox_attack_modulation.currentIndexChanged.connect(self._slotAttackModulationChanged)
        self.comboBox_attack_hardware.currentIndexChanged.connect(self.slotAttackHardwareChanged)
        self.comboBox_packet_protocols.currentIndexChanged.connect(self._slotPacketProtocols)
        self.comboBox_packet_subcategory.currentIndexChanged.connect(self._slotPacketSubcategory)  
        self.comboBox_archive_download_folder.currentIndexChanged.connect(self._slotArchiveDownloadFoldersChanged)
        self.comboBox_pd_sniffer_protocols.currentIndexChanged.connect(self._slotPD_SnifferProtocolsChanged)
        self.comboBox_pd_sniffer_packet_type.currentIndexChanged.connect(self._slotPD_SnifferPacketTypeChanged)
        self.comboBox_pd_sniffer_test_folders.currentIndexChanged.connect(self._slotPD_SnifferTestFoldersChanged)        
        
        # Radio Buttons
        self.radioButton_library_search_binary.clicked.connect(self._slotLibrarySearchBinaryClicked)
        self.radioButton_library_search_hex.clicked.connect(self._slotLibrarySearchHexClicked)        

        # Double Spin Boxes
        self.doubleSpinBox_pd_bit_slicing_window_size.valueChanged.connect(self._slotPD_BitSlicingSpinboxWindowChanged)
        self.doubleSpinBox_pd_bit_slicing_window_size_candidates.valueChanged.connect(self._slotPD_BitSlicingSpinboxWindowCandidatesChanged)
        
        # Horizontal Sliders
        self.horizontalSlider_pd_bit_slicing_preamble_stats.valueChanged.connect(self._slotPD_BitSlicingSliderWindowChanged)
        self.horizontalSlider_pd_bit_slicing_preamble_stats_candidates.valueChanged.connect(self._slotPD_BitSlicingSliderWindowCandidatesChanged)
            
        # Table Widgets        
        self.tableWidget_automation_scan_options.cellChanged.connect(self._slotAutomationLockSearchBandClicked)        
        self.tableWidget_pd_flow_graphs_current_values.cellChanged.connect(self._slotPD_DemodulationCurrentValuesEdited)
        self.tableWidget_pd_bit_slicing_lengths.itemSelectionChanged.connect(self._slotPD_BitSlicingLengthsChanged)
        self.tableWidget_pd_bit_slicing_candidate_preambles.cellDoubleClicked.connect(self._slotPD_BitSlicingCandidateDoubleClicked)
        self.tableWidget_pd_bit_slicing_preamble_stats.cellDoubleClicked.connect(self._slotPD_BitSlicingAllPreamblesDoubleClicked)  
        self.tableWidget_pd_bit_slicing_packets.horizontalHeader().sectionClicked.connect(self._slotPD_BitSlicingColumnClicked)        
        self.tableWidget_attack_flow_graph_current_values.cellChanged.connect(self._slotAttackCurrentValuesEdited)
        self.tableWidget_attack_packet_editor.cellChanged.connect(self._slotPacketItemChanged)
        self.tableWidget_attack_fuzzing_data_field.cellChanged.connect(self._slotAttackFuzzingItemChanged)   
        self.tableWidget_pd_bit_viewer_hex.horizontalHeader().sectionClicked.connect(self._slotPD_BitViewerColumnClicked)  
        
        # Labels
        self.label_iq_end.mousePressEvent = self._slotIQ_EndLabelClicked

        # List Widgets
        self.listWidget_library_gallery.currentItemChanged.connect(self._slotLibraryGalleryImageChanged)
        self.listWidget_library_browse_attacks.currentItemChanged.connect(self._slotLibraryBrowseAttackChanged)
        self.listWidget_library_browse_attacks_modulation.currentItemChanged.connect(self._slotLibraryBrowseAttackModulationChanged)
        self.listWidget_library_browse_sois.currentItemChanged.connect(self._slotLibraryBrowseSOIsChanged)
        self.listWidget_library_browse_packet_types.currentItemChanged.connect(self._slotLibraryBrowsePacketTypesChanged)
        self.listWidget_library_browse_packet_types2.currentItemChanged.connect(self._slotLibraryBrowsePacketTypesFieldsChanged)
        self.listWidget_library_browse_statistics.currentItemChanged.connect(self._slotLibraryBrowseStatisticsChanged)
        self.listWidget_library_browse_demod_fgs_modulation.currentItemChanged.connect(self._slotLibraryBrowseDemodFGsModulationClicked)
        self.listWidget_library_browse_demod_fgs_hardware.currentItemChanged.connect(self._slotLibraryBrowseDemodFGsHardwareClicked)
        self.listWidget_library_browse_demod_fgs.itemClicked.connect(self._slotLibraryBrowseDemodFGsClicked)
        self.listWidget_library_browse_sois.itemClicked.connect(self._slotLibraryBrowseSOIsClicked)
        self.listWidget_library_browse_packet_types.itemClicked.connect(self._slotLibraryBrowsePacketTypesClicked)
        self.listWidget_library_browse_modulation_types.itemClicked.connect(self._slotLibraryBrowseModulationsClicked)
        self.listWidget_library_browse_attacks3.itemClicked.connect(self._slotLibraryBrowseAttacksClicked)
        self.listWidget_tsi_scan_presets.currentItemChanged.connect(self._slotTSI_ScanPresetItemChanged)
        self.listWidget_iq_inspection_flow_graphs.itemDoubleClicked.connect(self._slotIQ_InspectionFlowGraphClicked)
        self.listWidget_pd_flow_graphs_recommended_fgs.itemDoubleClicked.connect(self._slotPD_DemodulationLoadSelectedClicked)        
        self.listWidget_pd_flow_graphs_all_fgs.itemDoubleClicked.connect(self._slotPD_DemodulationLoadSelectedAllClicked)
        self.listWidget_iq_files.itemDoubleClicked.connect(self._slotIQ_LoadIQ_Data)
        self.listWidget_archive_download_files.itemDoubleClicked.connect(self._slotArchiveListWidgetDoubleClicked)
        
        # Text Edits
        self.textEdit_iq_start.textChanged.connect(self._slotIQ_StartChanged)
        self.textEdit_iq_end.textChanged.connect(self._slotIQ_EndChanged)
        self.plainTextEdit_pd_bit_viewer_hex.textChanged.connect(self._slotPD_BitViewerHexChanged)
        
        # Tree Widgets
        self.treeWidget_attack_attacks.itemDoubleClicked.connect(self._slotAttackTemplatesDoubleClicked)
        
        # Menu Items
        self.actionAll_Options.triggered.connect(self._slotMenuOptionsClicked)
        self.actionLoad_Configuration.triggered.connect(self._slotMenuLoadConfigurationClicked)
        self.actionSave_Configuration.triggered.connect(self._slotMenuSaveConfigurationClicked)
        self.actionUhd_find_devices.triggered.connect(self._slotMenuUHD_FindDevicesClicked)
        self.actionHackrf_info.triggered.connect(self._slotMenuHackrfInfoClicked)
        self.actionLsusb.triggered.connect(self._slotMenuLsusbClicked)
        self.actionIwconfig.triggered.connect(self._slotMenuIwconfigClicked)
        self.actionMonitorModeTool.triggered.connect(self._slotMenuMonitorModeToolClicked)
        self.actionLoad_bladeRF_FPGA.triggered.connect(self._slotMenuLoadBladeRF_FPGA_Clicked)
        self.actionGsm_uplink_downlink.triggered.connect(self._slotMenuGSM_UplinkDownlinkClicked)
        self.actionJ2497_demod_method1.triggered.connect(self._slotMenuJ2497_DemodMethod1Clicked)
        self.actionWifi_rx.triggered.connect(self._slotMenuWifiRxClicked)
        self.actionWifi_tx.triggered.connect(self._slotMenuWifiTxClicked)
        self.actionRds_rx.triggered.connect(self._slotMenuRdsRxClicked)
        self.actionRds_tx.triggered.connect(self._slotMenuRdsTxClicked)
        self.actionQSpectrumAnalyzer.triggered.connect(self._slotMenuQSpectrumAnalyzerClicked)
        self.actionGQRX.triggered.connect(self._slotMenuGQRX_Clicked)
        self.actionDump1090.triggered.connect(self._slotMenuDump1090_Clicked)
        self.actionRds_rx_2.triggered.connect(self._slotMenuRdsRx2Clicked)
        self.actionIwlist_scan.triggered.connect(self._slotMenuIwlistScanClicked)
        self.actionKismet.triggered.connect(self._slotMenuKismetClicked)
        self.actionLimeSuiteGUI.triggered.connect(self._slotMenuLimeSuite_Clicked)
        self.actionSrsLTE.triggered.connect(self._slotMenuSrsLTE_Clicked)
        self.actionPaint_tx.triggered.connect(self._slotMenuPaintTxClicked)
        self.actionX10_tx_rx.triggered.connect(self._slotMenuX10_TxRxClicked)
        self.actionWifi_relay.triggered.connect(self._slotMenuWifiRelayClicked)
        self.actionWireshark.triggered.connect(self._slotMenuWiresharkClicked)
        self.actionBluetoothctl.triggered.connect(self._slotMenuBluetoothctlClicked)
        self.actionNoise_source.triggered.connect(self._slotMenuNoiseSourceClicked)
        self.actionV2Verifier.triggered.connect(self._slotMenuV2VerifierClicked)
        self.actionV2Verifier_wifi_tx.triggered.connect(self._slotMenuV2VerifierWifiTxClicked)
        self.actionV2Verifier_wifi_rx.triggered.connect(self._slotMenuV2VerifierWifiRxClicked)
        self.actionHelp.triggered.connect(self._slotMenuHelpClicked)        
        self.actionHelpUploadingFlowGraphs.triggered.connect(self._slotMenuHelpUploadingFlowGraphsClicked)
        self.actionHelpUploadingPythonScripts.triggered.connect(self._slotMenuHelpUploadingPythonScriptesClicked)
        self.actionHelpNewUSRPX310.triggered.connect(self._slotMenuHelpNewUSRPX310_Clicked)
        self.actionHelpUpdatingHackRF.triggered.connect(self._slotMenuHelpUpdatingHackRFClicked)
        self.actionHelpLimeSDR.triggered.connect(self._slotMenuHelpLimeSDR_Clicked)
        self.actionHelpSupportedProtocols.triggered.connect(self._slotMenuHelpSupportedProtocolsClicked)
        self.actionHelpSoftwareAndConflicts.triggered.connect(self._slotMenuHelpSoftwareAndConflictsClicked)
        self.actionHelpBuiltWith.triggered.connect(self._slotMenuHelpBuiltWithClicked)        
        self.actionHelpAbout.triggered.connect(self._slotMenuHelpAboutClicked)
        self.actionLessonOpenBTS.triggered.connect(self._slotMenuLessonOpenBTS_Clicked)
        self.actionFALCON.triggered.connect(self._slotMenuFALCON_Clicked)
        self.actionCyberChef.triggered.connect(self._slotMenuCyberChefClicked)
        self.actionESP8266_beacon_spammer.triggered.connect(self._slotMenuESP8266BeaconSpammerClicked)
        self.actionESP32_BLEBeaconSpam.triggered.connect(self._slotMenuESP32BLE_BeaconSpamClicked)
        self.actionMinicom.triggered.connect(self._slotMenuMinicomClicked)
        self.actionPutty.triggered.connect(self._slotMenuPuttyClicked)
        self.actionOpenHAB.triggered.connect(self._slotMenuOpenHAB_Clicked)
        self.actionStart_openHAB_Service.triggered.connect(self._slotMenuStart_openHAB_ServiceClicked)
        self.actionStop_openHAB_Service.triggered.connect(self._slotMenuStop_openHAB_ServiceClicked)
        self.actionIEEE_802_15_4_transceiver_OQPSK.triggered.connect(self._slotMenuIEEE_802_15_4_transceiver_OQPSK_Clicked)
        self.actionRtl_zwave_908_42_MHz.triggered.connect(self._slotMenuRtlZwave908_Clicked)
        self.actionRtl_zwave_916_MHz.triggered.connect(self._slotMenuRtlZwave916_Clicked)
        self.actionWaving_z_908_42_MHz.triggered.connect(self._slotMenuWavingZ_908_Clicked)
        self.actionWaving_z_916_MHz.triggered.connect(self._slotMenuWavingZ_916_Clicked)
        self.actionStandaloneTpms_rx.triggered.connect(self._slotMenuStandaloneTpmsRxClicked)
        self.actionStandaloneTpms_tx.triggered.connect(self._slotMenuStandaloneTpmsTxClicked)
        self.actionZwave_tx.triggered.connect(self._slotMenuStandaloneZwaveTxClicked)
        self.actionZwave_rx.triggered.connect(self._slotMenuStandaloneZwaveRxClicked)
        self.actionExit.triggered.connect(self._slotMenuFileExitClicked)
        self.actionLimeUtilUpdate.triggered.connect(self._slotMenuLimeUtilUpdateClicked)
        self.actionBaudline.triggered.connect(self._slotMenuBaudlineClicked)
        self.actionUniversal_Radio_Hacker.triggered.connect(self._slotMenuURH_Clicked)
        self.action4G_IMSI_Catcher.triggered.connect(self._slotMenu4G_IMSI_CatcherClicked)
        self.actionInspectrum.triggered.connect(self._slotMenuInspectrumClicked)
        self.actionOpenCPN.triggered.connect(self._slotMenuOpenCPN_Clicked)
        self.actionAis_rx.triggered.connect(self._slotMenuAis_rxClicked)
        self.actionProtocol_Spreadsheet.triggered.connect(self._slotMenuProtocolSpreadsheetClicked)
        self.actionGrgsm_scanner.triggered.connect(self._slotMenuGrgsm_scannerClicked)
        self.actionKalibrate.triggered.connect(self._slotMenuKalibrateClicked)
        self.actionTower_Search.triggered.connect(self._slotMenuTowerSearchClicked)
        self.actionTower_Search_Part_2.triggered.connect(self._slotMenuTowerSearchPart2Clicked)
        self.actionRetrogram_rtlsdr.triggered.connect(self._slotMenuRetrogramRtlSdrClicked)
        self.actionRTLSDR_Airband.triggered.connect(self._slotMenuRTLSDR_AirbandClicked)
        self.actionRadio_Reference_Database.triggered.connect(self._slotMenuRadioReferenceDatabaseClicked)
        self.actionSpektrum.triggered.connect(self._slotMenuSpektrumClicked)
        self.actionRtl_test.triggered.connect(self._slotMenuRTL_TestClicked)
        self.actionSDRTrunk.triggered.connect(self._slotMenuSDR_TrunkClicked)
        self.actionAudacity.triggered.connect(self._slotMenuAudacityClicked)
        self.actionSignal_Identification_Guide.triggered.connect(self._slotMenuSignalIdentificationGuideClicked)
        self.actionSondeHub_Radiosonde_Tracker.triggered.connect(self._slotMenuSondeHubRadiosondeTrackerClicked)
        self.actionCellmapper.triggered.connect(self._slotMenuCellmapperClicked)
        self.actionAirLink.triggered.connect(self._slotMenuAirLinkClicked)
        self.actionFccID_Lookup.triggered.connect(self._slotMenuFCC_ID_LookupClicked)
        self.actionMorseGen.triggered.connect(self._slotMenuStandaloneMorseGenClicked)
        self.actionProxmark3.triggered.connect(self._slotMenuProxmark3_Clicked)
        self.actionProxmark3_Cheatsheet.triggered.connect(self._slotMenuProxmark3_CheatsheetClicked)
        self.actionEarth_Nullschool.triggered.connect(self._slotMenuEarthNullschoolClicked)
        self.actionCUSF_Landing_Predictor.triggered.connect(self._slotMenuCUSF_LandingPredictorClicked)
        self.actionFlightAware.triggered.connect(self._slotMenuFlightAwareClicked)
        self.actionRadiosonde_auto_rx.triggered.connect(self._slotMenuRadiosondeAutoRxClicked)
        self.actionRadiosonde_auto_rx_Config.triggered.connect(self._slotMenuRadiosondeAutoRxConfigClicked)
        self.actionSQ6KXY_Radiosonde_Tracker.triggered.connect(self._slotMenuSQ6KXY_RadiosondeTrackerClicked)
        self.actionSdrGlut.triggered.connect(self._slotMenuSdrGlutClicked)
        self.actionUS_Frequency_Allocations.triggered.connect(self._slotMenuUS_FrequencyAllocationsClicked)
        self.actionCyberChef_Recipes.triggered.connect(self._slotMenuCyberChefRecipesClicked)
        self.actionRehex.triggered.connect(self._slotMenuRehexClicked)
        self.actionZEPASSD.triggered.connect(self._slotMenuZEPASSD_Clicked)
        self.actionIridium_extractor.triggered.connect(self._slotMenuIridiumExtractorClicked)
        self.actionIridium_parser.triggered.connect(self._slotMenuIridiumParserClicked)
        self.actionStats_voc.triggered.connect(self._slotMenuStatsVocClicked)
        self.actionIridiumLive.triggered.connect(self._slotMenuIridiumLiveClicked)
        self.actionNETATTACK2.triggered.connect(self._slotMenuNETATTACK2_Clicked)
        self.actionWifite.triggered.connect(self._slotMenuWifiteClicked)
        self.actionRtl_433.triggered.connect(self._slotMenuRtl_433_Clicked)
        self.actionRouterSploit.triggered.connect(self._slotMenuRouterSploitClicked)
        self.actionExploit_Database.triggered.connect(self._slotMenuExploitDatabaseClicked)
        self.actionMetasploit.triggered.connect(self._slotMenuMetasploitClicked)
        self.actionMonitor_rtl433.triggered.connect(self._slotMenuMonitor_rtl433_Clicked)
        self.actionWiGLE_net.triggered.connect(self._slotMenuWiGLE_Clicked)
        self.actionScan_ssid.triggered.connect(self._slotMenuScan_SSID_Clicked)
        self.actionPySim_read.triggered.connect(self._slotMenuPySimReadClicked)
        self.actionPySim_prog.triggered.connect(self._slotMenuPySimProgClicked)
        self.actionLessonLuaDissectors.triggered.connect(self._slotMenuLessonLuaDissectorsClicked)
        self.actionMinimodem_rx.triggered.connect(self._slotMenuMinimodemRxClicked)
        self.actionMinimodem_tx.triggered.connect(self._slotMenuMinimodemTxClicked)
        self.actionWSJT_X.triggered.connect(self._slotMenuWSJTX_Clicked)
        self.actionWSPRnet_Map.triggered.connect(self._slotMenuWSPRnetMapClicked)
        self.actionAntenna_test_rx.triggered.connect(self._slotMenuAntennaTestRxClicked)
        self.actionAntenna_test_tx.triggered.connect(self._slotMenuAntennaTestTxClicked)
        self.actionLessonSound_eXchange.triggered.connect(self._slotMenuLessonSound_eXchangeClicked)
        self.actionZigbeeOpen_Sniffer.triggered.connect(self._slotMenuZigbeeOpenSnifferClicked)
        self.actionVLC.triggered.connect(self._slotMenuVLC_Clicked)
        self.actionSimpleScreenRecorder.triggered.connect(self._slotMenuSimpleScreenRecorderClicked)
        self.actionPixie_Dust_List.triggered.connect(self._slotMenuPixieDustListClicked)
        self.actionAudioRecord.triggered.connect(self._slotMenuAudioRecordClicked)
        self.actionLessonESP_Boards.triggered.connect(self._slotMenuESP_BoardClicked)
        self.actionGoogle_Earth_Pro.triggered.connect(self._slotMenuGoogleEarthProClicked)
        self.actionGr_air_modes.triggered.connect(self._slotMenuGrAirModesClicked)
        self.actionEsp8266_deauther_ino.triggered.connect(self._slotMenuESP8266_DeautherInoClicked)
        self.actionESP8266_Deauther_Web_Interface.triggered.connect(self._slotMenuESP8266_DeautherWebInterfaceClicked)
        self.actionESP8266_Deauther_Credentials.triggered.connect(self._slotMenuESP8266_DeautherCredentialsClicked)
        self.actionLow_Earth_Orbit_Visualization.triggered.connect(self._slotMenuLowEarthVisualizationClicked)
        self.actionLeoLabs_Catalog.triggered.connect(self._slotMenuLeoLabsCatalogClicked)
        self.actionCgps.triggered.connect(self._slotMenuCgpsClicked)
        self.actionGpsdecode.triggered.connect(self._slotMenuGpsdecodeClicked)
        self.actionGpsmon.triggered.connect(self._slotMenuGpsmonClicked)
        self.actionXgps.triggered.connect(self._slotMenuXgpsClicked)
        self.actionXgpsspeed.triggered.connect(self._slotMenuXgpsspeedClicked)
        self.actionViking.triggered.connect(self._slotMenuVikingClicked)       
        self.actionPyGPSClient.triggered.connect(self._slotMenuPyGPSClientClicked) 
        self.actionRadio_Station_Locator.triggered.connect(self._slotMenuRadioStationLocator)
        self.actionLiveATC_net.triggered.connect(self._slotMenuLiveATCnetClicked)
        self.actionFlightradar24.triggered.connect(self._slotMenuFlightradar24_Clicked)
        self.actionFlightStats.triggered.connect(self._slotMenuFlightStatsClicked)
        self.actionPlane_Finder.triggered.connect(self._slotMenuPlaneFinderClicked)
        self.actionUS_County_Overlays.triggered.connect(self._slotMenuUS_CountyOverlaysClicked)
        self.actionAM_Query.triggered.connect(self._slotMenuAM_QueryClicked)
        self.actionFM_Query.triggered.connect(self._slotMenuFM_QueryClicked)
        self.actionRadio_Garden.triggered.connect(self._slotMenuRadioGardenClicked)
        self.actionDiffchecker.triggered.connect(self._slotMenuDiffcheckerClicked)
        self.actionEvery_Time_Zone.triggered.connect(self._slotMenuEveryTimeZoneClicked)
        self.actionCloudConvert.triggered.connect(self._slotMenuCloudConvertClicked)
        self.actionRoundup_of_SDRs.triggered.connect(self._slotMenuRoundup_ofSDRsClicked)
        self.actionList_of_SDRs.triggered.connect(self._slotMenuList_ofSDRsClicked)
        self.actionAcars_demo.triggered.connect(self._slotMenuAcarsDemoClicked)
        self.actionGpredict.triggered.connect(self._slotMenuGpredictClicked)
        self.actionTechInfoDepot.triggered.connect(self._slotMenuTechInfoDepotClicked)
        self.actionWikiDevi.triggered.connect(self._slotMenuWikiDeviClicked)
        self.actionAPT3000.triggered.connect(self._slotMenuApt3000_Clicked)
        self.actionFSPL_Calculator.triggered.connect(self._slotMenuFSPL_CalculatorClicked)
        self.actionHabhub_tracker.triggered.connect(self._slotMenuHabhubTrackerClicked)
        self.actionFoxtrotGPS.triggered.connect(self._slotMenuFoxtrotGPS_Clicked)
        self.actionGoogle_Maps_APRS.triggered.connect(self._slotMenuGoogleMapsAPRS_Clicked)
        self.actionAPRS_multimon_ng.triggered.connect(self._slotMenuAPRSmultimon_ngClicked)
        self.actionLTE_Cell_Scanner.triggered.connect(self._slotMenuLTE_CellScannerClicked)
        self.actionEsri_Satellite_Map.triggered.connect(self._slotMenu_esriSatelliteMapClicked)
        self.actionLessonRadiosondeTracking.triggered.connect(self._slotMenuLessonRadiosondeTrackingClicked)
        self.actionBtrx.triggered.connect(self._slotMenuBtrxClicked)
        self.actionBle_dump.triggered.connect(self._slotMenuBleDumpTriggered)
        self.actionFlash_ESP32_Board.triggered.connect(self._slotMenuFlashESP32_BoardClicked)
        self.actionBTSnifferBREDR.triggered.connect(self._slotMenuBT_SnifferBREDR_Clicked)
        self.actionHcitool_scan.triggered.connect(self._slotMenuHcitoolScanClicked)
        self.actionSdptool_browse.triggered.connect(self._slotMenuSdptoolBrowseClicked)
        self.actionHcitool_inq.triggered.connect(self._slotMenuHcitoolInqClicked)
        self.actionDevice_Class_List.triggered.connect(self._slotMenuDeviceClassListClicked)
        self.actionBtclassify.triggered.connect(self._slotMenuBtclassifyClicked)
        self.actionL2ping.triggered.connect(self._slotMenuL2pingClicked)
        self.actionBtscanner.triggered.connect(self._slotMenuBtscannerClicked)
        self.actionHcidump.triggered.connect(self._slotMenuHcidumpClicked)
        self.actionLessonRFID.triggered.connect(self._slotMenuLessonRFID_Clicked)
        self.actionFM_Radio_Capture.triggered.connect(self._slotMenuStandaloneFM_RadioCaptureClicked)
        self.actionAddingCustomOptions.triggered.connect(self._slotMenuAddingCustomOptionsClicked)
        self.actionProtocol_CSV.triggered.connect(self._slotMenuProtocolCSV_Clicked)
        self.actionUhd_image_loader.triggered.connect(self._slotMenuUHD_ImageLoaderClicked)
        self.actionTinyWow.triggered.connect(self._slotMenuTinyWowClicked)
        self.actionGr_paint_Converter.triggered.connect(self._slotMenuGrPaintConverterClicked)
        self.actionModifying_Dashboard.triggered.connect(self._slotMenuModifyingDashboardClicked)
        self.actionNrsc5.triggered.connect(self._slotMenuNrsc5_Clicked)
        self.actionHd_tx_usrp.triggered.connect(self._slotMenuStandaloneHd_tx_usrpClicked)
        self.actionAntenna_Comparison.triggered.connect(self._slotMenuAntennaComparisonClicked)
        self.action2022_2026_Technician_Pool.triggered.connect(self._slotMenu2022_2026_TechnicianPoolClicked)
        self.actionLicense_Search.triggered.connect(self._slotMenuLicenseSearchClicked)
        self.actionAnki.triggered.connect(self._slotMenuAnkiClicked)
        self.actionAnki_Decks.triggered.connect(self._slotMenuAnkiDecksClicked)
        self.actionWavelength_Calculator.triggered.connect(self._slotMenuWavelengthCalculatorClicked)
        self.actionAntennaSearch.triggered.connect(self._slotMenuAntennaSearchClicked)
        self.actionCommand_Class_Specification.triggered.connect(self._slotMenuCommandClassSpecificationClicked)
        self.actionCommand_Class_List.triggered.connect(self._slotMenuCommandClassListClicked)
        self.actionSCADACore_RF_Line_of_Sight.triggered.connect(self._slotMenuSCADACoreRF_LineOfSightClicked)
        self.actionOnline_Hex_Converter.triggered.connect(self._slotMenuOnlineHexConverterClicked)
        self.actionExam_Locations.triggered.connect(self._slotMenuExamLocationsClicked)
        self.actionEchoLink_Link_Status.triggered.connect(self._slotMenuEchoLinkLinkStatusClicked)
        self.actionSolarHam.triggered.connect(self._slotMenuSolarHamClicked)
        self.actionBless.triggered.connect(self._slotMenuBlessHexEditorClicked)
        self.actionTrackerjacker.triggered.connect(self._slotMenuTrackjackerClicked)
        self.actionSanitized_IEEE_OUI_Data.triggered.connect(self._slotMenuSanitizedIEEE_OUI_DataClicked)
        self.actionMarineTraffic.triggered.connect(self._slotMenuMarineTrafficClicked)
        self.actionVesselFinder.triggered.connect(self._slotMenuVesselFinderClicked)
        self.actionBoatnerd.triggered.connect(self._slotMenuBoatnerdClicked)
        self.actionCruiseMapper.triggered.connect(self._slotMenuCruiseMapperClicked)
        self.actionLesson_Data_Types.triggered.connect(self._slotMenuLessonDataTypesClicked)
        self.actionLesson_Custom_GNU_Radio_Blocks.triggered.connect(self._slotMenuLessonCustomGNU_RadioBlocksClicked)
        self.actionADS_B_Exchange.triggered.connect(self._slotMenuADSB_ExchangeClicked)
        self.actionClapper_Plus_Transmit.triggered.connect(self._slotMenuStandaloneClapperPlusTransmitClicked)
        self.actionGarage_Door_Transmit.triggered.connect(self._slotMenuStandaloneGarageDoorTransmitClicked)
        self.actionGarage_Door_Cycle.triggered.connect(self._slotMenuStandaloneGarageDoorCycleClicked)
        self.actionLesson_TPMS.triggered.connect(self._slotMenuLessonTPMS_Clicked)
        self.actionHow_to_File.triggered.connect(self._slotMenuHowToFileClicked)
        self.actionRadioQTH_Available_Call_Signs.triggered.connect(self._slotMenuRadioQTH_Clicked)
        self.actionAE7Q_Available_Call_Signs.triggered.connect(self._slotMenuAE7Q_Clicked)
        self.actionAirgeddon.triggered.connect(self._slotMenuAirgeddonClicked)
        self.actionwhoishere_py_2.triggered.connect(self._slotMenuWhoisherePyClicked)
        self.actionwhoishere_conf.triggered.connect(self._slotMenuWhoishereConfClicked)
        self.actionHydra.triggered.connect(self._slotMenuHydraClicked)
        self.actionSecLists.triggered.connect(self._slotMenuSecListsClicked)
        self.actionssh_login.triggered.connect(self._slotMenu_ssh_loginClicked)
        self.actionMetasploit_Wordlists.triggered.connect(self._slotMenuMetasploitWordlistsClicked)
        self.actionOpenSSH_Username_Enumeration.triggered.connect(self._slotMenuOpenSSH_UsernameEnumerationClicked)
        self.actionLesson_Ham_Radio_Exams.triggered.connect(self._slotMenuLessonHamRadioExamsClicked)
        self.action2019_2023_General_Pool.triggered.connect(self._slotMenu2019_2023_GeneralPoolClicked)
        self.actionGitHub_FISSURE.triggered.connect(self._slotMenuGitHubFISSURE_Clicked)
        self.actionGitHub_cpoore1.triggered.connect(self._slotMenuGitHub_cpoore1_Clicked)
        self.actionGitHub_ainfosec.triggered.connect(self._slotMenuGitHub_ainfosecClicked)
        self.actionLesson_WiFi_Tools.triggered.connect(self._slotMenuLessonWiFiToolsClicked)
        self.actionPySDR_org.triggered.connect(self._slotMenuHelpPySDR_orgClicked)
        self.actionnrsc5_gui.triggered.connect(self._slotMenuNrsc5_GuiClicked)
        self.actionj2497_mod_hackrfdirect.triggered.connect(self._slotMenuStandaloneJ2497_ModHackRF_Direct_Clicked)
        self.actionj2497_mod_fl2k.triggered.connect(self._slotMenuStandaloneJ2497_fl2kClicked)
        self.actionj2497_mod.triggered.connect(self._slotMenuStandaloneJ2497_ModClicked)
        self.actionEnscribe.triggered.connect(self._slotMenuEnscribeClicked)
        self.actionOpen_weather.triggered.connect(self._slotMenuOpenWeatherClicked)
        self.actionLTE_ciphercheck.triggered.connect(self._slotMenuLTE_ciphercheckClicked)
        self.actionElectromagnetic_Radiation_Spectrum.triggered.connect(self._slotMenuElectromagneticRadiationSpectrumClicked)
        
        # Tab Widgets
        self.tabWidget_tsi.currentChanged.connect(self._slotTSI_TabChanged)
        
        # Custom Signals        
        self.signal_addWideband.connect(self._slotAddWidebandSignal)
        #self.connect(self, self.signal_addNarrowband, self._slotAddNarrowbandSignal)
        self.signal_flowGraphFinished.connect(self._slotFlowGraphFinished)
        self.signal_flowGraphStarted.connect(self._slotFlowGraphStarted)
        self.signal_detectorFlowGraphError.connect(self._slotDetectorFlowGraphError)
        self.signal_flowGraphError.connect(self._slotFlowGraphError)
        self.signal_setRecommendedFlowGraphs.connect(self._slotPD_DemodulationSetRecommendedFlowGraphs)
        self.signal_setFullLibrary.connect(self._slotSetFullLibrary)  
        self.signal_SOI_Chosen.connect(self._slotSOI_Chosen)   
        self.signal_flowGraphFinishedIQ.connect(self._slotIQ_FlowGraphFinished)
        self.signal_flowGraphFinishedIQ_Playback.connect(self._slotIQ_FlowGraphPlaybackFinished)
        # ~ self.connect(self, self.signal_flowGraphFinishedIQ_Inspection, self._slotIQ_InspectionFlowGraphFinished)
        self.signal_flowGraphFinishedSniffer.connect(self._slotPD_SnifferFlowGraphFinished)
        self.signal_flowGraphStartedIQ.connect(self._slotIQ_FlowGraphStarted)
        self.signal_flowGraphStartedIQ_Playback.connect(self._slotIQ_PlaybackFlowGraphStarted)
        # ~ self.connect(self, self.signal_flowGraphStartedIQ_Inspection, self._slotIQ_InspectionFlowGraphStarted)
        self.signal_flowGraphStartedSniffer.connect(self._slotPD_SnifferFlowGraphStarted)
        self.signal_multiStageAttackFinished.connect(self._slotAttackMultiStageAttackFinished)
        self.signal_archivePlaylistFinished.connect(self._slotArchivePlaylistFinished)
        self.signal_PD_AddStatus.connect(self._slotPD_AddStatus)
        self.signal_pdBitSlicingLibraryLookupReturned.connect(self._slotPD_BitSlicingLibraryLookupReturned)
        self.signal_pdBitSlicingPreamblesReturned.connect(self._slotPD_BitSlicingPreamblesReturned)
        self.signal_pdBitSlicingSliceByPreambleReturn.connect(self._slotPD_BitSlicingSliceByPreambleReturned)
        self.signal_pdBufferSize.connect(self._slotPD_BufferSizeUpdate)
        self.signal_pdBitSlicingEntropyReturn.connect(self._slotPD_BitSlicingEntropyReturn)
        self.signal_bandID.connect(self._slotTSI_BandID_Returned)
        self.signal_archivePlaylistPosition.connect(self._slotArchivePlaylistPosition)        
        self.signal_HIPRFISR_Offline.connect(self._slotHIPRFISR_Offline)
        self.signal_HIPRFISR_Online.connect(self._slotHIPRFISR_Online)
        self.signal_TSI_Offline.connect(self._slotTSI_Offline)
        self.signal_TSI_Online.connect(self._slotTSI_Online)
        self.signal_PD_Offline.connect(self._slotPD_Offline)
        self.signal_PD_Online.connect(self._slotPD_Online)
        self.signal_FGE_Offline.connect(self._slotFGE_Offline)
        self.signal_FGE_Online.connect(self._slotFGE_Online)
        
    
    def _slotLogRefreshClicked(self):
        """ Refresh is clicked in the Log tab
        """
        # Attain Keywords
        bad_words = []
        if self.checkBox_log_heartbeats.isChecked():
            bad_words.append('Heartbeat')
        if self.checkBox_log_tsi.isChecked():
            bad_words.append(' - tsi')
        if self.checkBox_log_fge.isChecked():
            bad_words.append(' - fge')
        if self.checkBox_log_dashboard.isChecked():
            bad_words.append(' - dashboard')
        if self.checkBox_log_pd.isChecked():
            bad_words.append(' - pd')
        if self.checkBox_log_hiprfisr.isChecked():
            bad_words.append(' - hiprfisr')                                    
        #wideband,narrowband,tsi,fge,dashboard,pd,hiprfisr,status,commands

        # Remove Lines with Keywords
        with open(os.path.dirname(os.path.realpath(__file__)) + '/Logs/event.log') as oldfile, open(os.path.dirname(os.path.realpath(__file__)) + '/Logs/temp.log', 'w') as newfile:
            for line in oldfile:
                if not any(bad_word in line for bad_word in bad_words):
                    newfile.write(line)
            
        # Display the Text
        with open(os.path.dirname(os.path.realpath(__file__)) + "/Logs/temp.log") as mylogfile:
            temp_log_contents = mylogfile.read()
        self.textEdit_log.setPlainText(temp_log_contents)
        self.textEdit_log.moveCursor(QtGui.QTextCursor.End)        
        
    def _slotLogRefreshPermitClicked(self):
        """ Permit refresh is clicked in the Log tab
        """        
        # Attain Keywords
        good_words = []
        if self.checkBox_log_heartbeats_permit.isChecked():
            good_words.append('Heartbeat')
        if self.checkBox_log_tsi_permit.isChecked():
            good_words.append(' - tsi')
        if self.checkBox_log_fge_permit.isChecked():
            good_words.append(' - fge')
        if self.checkBox_log_dashboard_permit.isChecked():
            good_words.append(' - dashboard')
        if self.checkBox_log_pd_permit.isChecked():
            good_words.append(' - pd')
        if self.checkBox_log_hiprfisr_permit.isChecked():
            good_words.append(' - hiprfisr')                                    
        #wideband,narrowband,tsi,fge,dashboard,pd,hiprfisr,status,commands

        # Remove Lines with Keywords
        with open(os.path.dirname(os.path.realpath(__file__)) + '/Logs/event.log') as oldfile, open(os.path.dirname(os.path.realpath(__file__)) + '/Logs/temp.log', 'w') as newfile:
            for line in oldfile:
                if any(good_word in line for good_word in good_words):
                    newfile.write(line)
            
        # Display the Text
        with open(os.path.dirname(os.path.realpath(__file__)) + "/Logs/temp.log") as mylogfile:
            temp_log_contents = mylogfile.read()
        self.textEdit_log.setPlainText(temp_log_contents)
        self.textEdit_log.moveCursor(QtGui.QTextCursor.End)        
        
    def _slotTSI_TargetClicked(self):
        """ The narrowband target radio button is clicked. The details box is updated.
        """
        # Get the Row
        button = QtWidgets.qApp.focusWidget()
        index = self.tableWidget_tsi_narrowband.indexAt(button.pos())
        
        # Check the Radio Button in Table
        radio_button = self.tableWidget_tsi_narrowband.cellWidget(index.row(),index.column())
        radio_button.setChecked(True)
        
        # Proceed
        self.targetSelected(index.row())
        
    def targetSelected(self, row):
        """ SOI target was clicked by the user or selected by auto-select.
        """  
        # Update the Text
        self.textEdit_pd_status_target.setPlainText("Frequency (MHz): " + self.tableWidget_tsi_narrowband.item(row,1).text())        
        self.textEdit_pd_status_target.append("Power (dB): " + self.tableWidget_tsi_narrowband.item(row,2).text())    
        self.textEdit_pd_status_target.append("Modulation: " + self.tableWidget_tsi_narrowband.item(row,3).text())
        self.textEdit_pd_status_target.append("Bandwidth (MHz): " + self.tableWidget_tsi_narrowband.item(row,4).text())
        self.textEdit_pd_status_target.append("Continuous: " + self.tableWidget_tsi_narrowband.item(row,5).text())
        self.textEdit_pd_status_target.append("Start Frequency (MHz): " + self.tableWidget_tsi_narrowband.item(row,6).text())
        self.textEdit_pd_status_target.append("End Frequency (MHz): " + self.tableWidget_tsi_narrowband.item(row,7).text())
        #self.textEdit_pd_status_target.append("Confidence: " + self.tableWidget_tsi_narrowband.item(row,9).text())
        
        # Assemble the Target SOI
        frequency = str(self.tableWidget_tsi_narrowband.item(row,1).text())
        modulation = str(self.tableWidget_tsi_narrowband.item(row,3).text())
        bandwidth = str(self.tableWidget_tsi_narrowband.item(row,4).text())
        continuous = str(self.tableWidget_tsi_narrowband.item(row,5).text())
        start_frequency = str(self.tableWidget_tsi_narrowband.item(row,6).text())
        end_frequency = str(self.tableWidget_tsi_narrowband.item(row,7).text())
        notes = ""
        self.target_soi = [frequency, modulation, bandwidth, continuous, start_frequency, end_frequency, notes]
        
        #~ # Send Parameters to HIPRFISR so it can Look for a Flow Graph
        #~ if self.pushButton_pd_status_start.text() == "Stop":  
            #~ self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Target SOI', Parameters = self.target_soi)    

        # Update the "Flow Graph Lookup" Tab
        self.textEdit_pd_flow_graphs_frequency.setPlainText(self.tableWidget_tsi_narrowband.item(row,1).text())          
        self.textEdit_pd_flow_graphs_modulation.setPlainText(self.tableWidget_tsi_narrowband.item(row,3).text())
        self.textEdit_pd_flow_graphs_bandwidth.setPlainText(self.tableWidget_tsi_narrowband.item(row,4).text())
        
        if str(self.tableWidget_tsi_narrowband.item(row,5).text()) == "True":
            self.comboBox_pd_flow_graphs_continuous.setCurrentIndex(0)
        else:
            self.comboBox_pd_flow_graphs_continuous.setCurrentIndex(1)
        
        self.textEdit_pd_flow_graphs_start_frequency.setPlainText(self.tableWidget_tsi_narrowband.item(row,6).text())
        self.textEdit_pd_flow_graphs_end_frequency.setPlainText(self.tableWidget_tsi_narrowband.item(row,7).text())  
                    
        # Enable the Protocol Discovery "Untarget", "Blacklist SOI", "Search Library" Pushbuttons
        self.pushButton_pd_status_untarget.setEnabled(True)
        #self.pushButton_pd_status_blacklist_soi.setEnabled(True)
        self.pushButton_pd_status_search_library.setEnabled(True)
            
        # Insert Message into the Status Window
        get_text = time.strftime('%H:%M:%S', time.localtime()) + ": Targeted SOI: " + str(self.target_soi ) +  "\n"
        self._slotPD_AddStatus(get_text)
        
        # Update the PD "Add to Library" Tab
        self.textEdit_library_pd_soi_frequency.setPlainText(self.tableWidget_tsi_narrowband.item(row,1).text())          
        self.textEdit_library_pd_soi_modulation.setPlainText(self.tableWidget_tsi_narrowband.item(row,3).text())
        self.textEdit_library_pd_soi_bandwidth.setPlainText(self.tableWidget_tsi_narrowband.item(row,4).text())
        
        if str(self.tableWidget_tsi_narrowband.item(row,5).text()) == True:
            self.comboBox_library_pd_soi_continuous.setCurrentIndex(0)
        else:
            self.comboBox_library_pd_soi_continuous.setCurrentIndex(1)
        
        self.textEdit_library_pd_soi_start_frequency.setPlainText(self.tableWidget_tsi_narrowband.item(row,6).text())
        self.textEdit_library_pd_soi_end_frequency.setPlainText(self.tableWidget_tsi_narrowband.item(row,7).text())    
        
        # Auto-Load PD Flow Graphs is Enabled
        if self.checkBox_automation_auto_select_pd_flow_graphs.isChecked():
            # Search for Flow Graphs
            self._slotPD_DemodulationLookupClicked()

        
    def closeEvent(self, event):
        """ Stop the loop when the "X" is clicked
        """
        self.stopListener()
        
        # Remember Configuration
        if self.actionRemember_Configuration.isChecked():
            self.dashboard_settings_dictionary['remember_configuration'] = 'True'
            
            # Dump Dictionary to File
            stream = open(os.path.dirname(os.path.realpath(__file__)) + '/YAML/fissure_config.yaml', 'w')
            yaml.dump(self.dashboard_settings_dictionary, stream, default_flow_style=False, indent=5)  
            
        else:
            self.dashboard_settings_dictionary['remember_configuration'] = 'False'
            
            # Dump Dictionary to File (Load a Different File on Start)
            stream = open(os.path.dirname(os.path.realpath(__file__)) + '/YAML/fissure_config.yaml', 'w')
            yaml.dump(self.dashboard_settings_dictionary, stream, default_flow_style=False, indent=5)  
            
            
        # Stop TSI
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop TSI Detector')
        
        # Stop PD
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop PD')
        
        # Close the HIPRFISR and TSI
        pid1 = os.system("pgrep -f hiprfisr.py")
        os.kill(pid1, signal.SIGKILL)
        

    
    def _slotAddWidebandSignal(self, signal):
        """ Adds a wideband signal to the plot and the list
        """
        # Plot a Point
        if self.wideband_zoom == True:
            labels = self.matplotlib_widget.axes.get_xticklabels()
            try:
                start_freq = float(str(labels[0]).split("'")[1])
                end_freq = float(str(labels[-1]).split("'")[1])
            except:
                start_freq = 0
                end_freq = 6000e6
            plot_x = 600 * (signal[0]-start_freq)/(end_freq-start_freq)
        else:
            plot_x = signal[0]/10  # Frequencies: 0 - 6000, X-Values: 0-600
                    
        self.matplotlib_widget.plotPoint(plot_x, 11, self.matplotlib_widget.computeColormapValue(signal[1]), 5, self.wideband_data)
        
        # Add it to the Table        
        self.tableWidget_tsi_wideband.setRowCount(self.tableWidget_tsi_wideband.rowCount()+1)

        # Frequency
        frequency_item = QtWidgets.QTableWidgetItem(str(signal[0]))
        frequency_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_tsi_wideband.setItem(self.tableWidget_tsi_wideband.rowCount()-1,0,frequency_item)        
        
        # Power
        power_item = QtWidgets.QTableWidgetItem(str(signal[1]))
        power_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_tsi_wideband.setItem(self.tableWidget_tsi_wideband.rowCount()-1,1,power_item)    
        
        # Time        
        get_time = time.strftime('%H:%M:%S', time.localtime(signal[2]))  # time format?
        time_item = QtWidgets.QTableWidgetItem(get_time)
        time_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_tsi_wideband.setItem(self.tableWidget_tsi_wideband.rowCount()-1,2,time_item)  # Will this cause sorting problems going from 12:59 to 1:00 or 23:59 to 0:00?
        
        # Sort by Time
        self.tableWidget_tsi_wideband.sortItems(2,order=QtCore.Qt.DescendingOrder)    
        
        # Resize Table Columns and Rows
        self.tableWidget_tsi_wideband.resizeColumnsToContents()
        self.tableWidget_tsi_wideband.resizeRowsToContents()
        self.tableWidget_tsi_wideband.horizontalHeader().setStretchLastSection(False)
        self.tableWidget_tsi_wideband.horizontalHeader().setStretchLastSection(True)
        
        # # Update New Detections Notification if on Classification Tab
        # if self.tabWidget_tsi.currentIndex() == 1:
            # self.new_detections += 1
            # self.tabWidget_tsi.setTabText(0,"Detector (" + str(self.new_detections) + ")")
        
    # def _slotAddNarrowbandSignal(self, signal):
        # """ Adds a narrowband signal to the plot and the list
        # """
        # # Check if it is Blacklisted
        # blacklisted = False
        # for row in range(0,self.listWidget_tsi_soi_blacklist.count()):
            # # Compare Frequency and Modulation
            # get_item = str(self.listWidget_tsi_soi_blacklist.item(row).text())
            # get_freq = get_item.split(',',1)[0]
            # get_mod = get_item.split(',',1)[1]
            # if (get_freq == str(signal[0])) and (get_mod == str(signal[2])):
                # blacklisted = True           
            
        # if blacklisted == False:
            # # Plot a Point
            # self.nb_matplotlib_widget.plotNarrowbandPoint(signal[0]/10, 11, self.nb_matplotlib_widget.computeColormapValue(signal[1]), 10, self.narrowband_data)
            
            # # Add it to the Table(s)
            # self.tableWidget_tsi_narrowband.insertRow(0)  
            
            # # Frequency
            # frequency_item = QtWidgets.QTableWidgetItem(str(signal[0]))
            # frequency_item.setTextAlignment(QtCore.Qt.AlignCenter)
            # self.tableWidget_tsi_narrowband.setItem(0,1,frequency_item)    
            
            # # Power
            # item = QtWidgets.QTableWidgetItem()
            # item.setData(QtCore.Qt.EditRole, signal[1])
            # item.setTextAlignment(QtCore.Qt.AlignCenter)
            # self.tableWidget_tsi_narrowband.setItem(0,2,QtWidgets.QTableWidgetItem(item))  # Convert to int for sorting    
            
            # # Modulation        
            # modulation_item = QtWidgets.QTableWidgetItem(signal[2])
            # modulation_item.setTextAlignment(QtCore.Qt.AlignCenter)
            # self.tableWidget_tsi_narrowband.setItem(0,3,modulation_item)
            
            # # Bandwidth
            # bandwidth_item = QtWidgets.QTableWidgetItem(str(signal[3]))
            # bandwidth_item.setTextAlignment(QtCore.Qt.AlignCenter)
            # self.tableWidget_tsi_narrowband.setItem(0,4,bandwidth_item)
                    
            # # Continuous
            # continuous_item = QtWidgets.QTableWidgetItem(signal[4])
            # continuous_item.setTextAlignment(QtCore.Qt.AlignCenter)
            # self.tableWidget_tsi_narrowband.setItem(0,5,continuous_item)
            
            # # Start Frequency
            # start_frequency_item = QtWidgets.QTableWidgetItem(str(signal[5]))
            # start_frequency_item.setTextAlignment(QtCore.Qt.AlignCenter)
            # self.tableWidget_tsi_narrowband.setItem(0,6,start_frequency_item)
            
            # # End Frequency
            # end_frequency_item = QtWidgets.QTableWidgetItem(str(signal[6]))
            # end_frequency_item.setTextAlignment(QtCore.Qt.AlignCenter)
            # self.tableWidget_tsi_narrowband.setItem(0,7,end_frequency_item)        
            
            # # Timestamp
            # get_time = time.strftime('%H:%M:%S', time.localtime(signal[7]))  # time format?
            # timestamp_item = QtWidgets.QTableWidgetItem(get_time)
            # timestamp_item.setTextAlignment(QtCore.Qt.AlignCenter)
            # self.tableWidget_tsi_narrowband.setItem(0,8,timestamp_item)        
            
            # # Confidence
            # confidence_item = QtWidgets.QTableWidgetItem(str(round(float(signal[8]),2)))
            # confidence_item.setTextAlignment(QtCore.Qt.AlignCenter)
            # self.tableWidget_tsi_narrowband.setItem(0,9,confidence_item)            
            
            # # Target Radio Button
            # new_button = QtWidgets.QRadioButton("",self)
            # new_button.setStyleSheet("margin-left:18%")  # doesn't center, could create a layout and put the radio button in the layout
            
            # if self.checkBox_automation_auto_select_sois.isChecked():  # Disable for everything but manual selection
                # new_button.setEnabled(False)
                
            # self.tableWidget_tsi_narrowband.setCellWidget(0,0,new_button)
            # new_button.clicked.connect(self._slotTSI_TargetClicked)
            
            # #~ # Sort by Power
            # #~ self.tableWidget_tsi_narrowband.sortItems(2,order=QtCore.Qt.DescendingOrder)
            
            # # Resize Table Columns and Rows
            # self.tableWidget_tsi_narrowband.resizeColumnsToContents()    
            # self.tableWidget_tsi_narrowband.resizeRowsToContents()
            # self.tableWidget_tsi_narrowband.horizontalHeader().setStretchLastSection(False)   
            # self.tableWidget_tsi_narrowband.horizontalHeader().setStretchLastSection(True)   
            
            # # Update New Classifications Notification if on Detection Tab
            # if self.tabWidget_tsi.currentIndex() == 0:
                # self.new_classifications += 1
                # self.tabWidget_tsi.setTabText(1,"Classifier (" + str(self.new_classifications) + ")")
                
    def _slotTSI_ClearWidebandListClicked(self):
        """ Clears the Wideband list on the Dashboard and in the HIPRFISR
        """
        
        self.tableWidget_tsi_wideband.clearContents()
        self.tableWidget_tsi_wideband.setRowCount(0)
        
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Clear Wideband List')    
        
    def _slotTSI_ClearSOI_ListClicked(self):
        """ Clears the SOI list on the Dashboard and in the HIPRFISR
        """
        # Untarget SOI if Auto-Select PD Flow Graphs is Checked
        if self.checkBox_automation_auto_select_pd_flow_graphs.isChecked():
            self._slotTSI_SOI_UntargetClicked()
            
        # Clear Tables, Labels    
        self.tableWidget_tsi_narrowband.clearContents()
        self.tableWidget_tsi_narrowband.setRowCount(0)
        self.textEdit_pd_status_target.clear()
        
        # Send Message to HIPRFISR
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Clear SOI List')    
        
    def _slotTSI_SavePresetClicked(self):
        """ Creates a new preset from the table contents and adds it to the preset list
        """
        # Create an Empty 2D Array
        value_matrix = [[0 for x in range(10)] for x in range(self.tableWidget_tsi_scan_options.rowCount())] 
        
        # Get the Values from the Table
        for col in range(0,self.tableWidget_tsi_scan_options.columnCount()):
            for row in range(0,self.tableWidget_tsi_scan_options.rowCount()):
                value_matrix[row][col] = self.tableWidget_tsi_scan_options.item(row,col).text()
        
        # Add the Values to the Dictionary and Table
        self.preset_count = self.preset_count + 1
        preset_name = "Preset " + str(self.preset_count)        
        self.preset_dictionary[preset_name] = value_matrix  # Dictionary        
        self.listWidget_tsi_scan_presets.addItem(preset_name)  # Table
        
    def _slotTSI_ScanPresetItemChanged(self):
        """ Changes the values in the scan options table whenever the preset item is changed
        """  
        if self.listWidget_tsi_scan_presets.count() > 1:  # Don't delete last preset settings
            
            self.tuning_matplotlib_widget.axes.cla()  # TEST
            
            # Clear the Table
            self.tableWidget_tsi_scan_options.clearContents()
            self.tableWidget_tsi_scan_options.setColumnCount(0)
            
            # Delete the Text Labels
            for txt in reversed(self.tuning_matplotlib_widget.axes.texts):
                if txt.get_position()[1] < 500:
                    txt.remove()
            
            # Delete the Bands
            for col in reversed(range(0,len(self.tuning_matplotlib_widget.bands))):
                self.tuning_matplotlib_widget.bands[col].remove()
                del self.tuning_matplotlib_widget.bands[col]
        
            # Add the Values to the Table
            preset_name = str(self.listWidget_tsi_scan_presets.currentItem().text())
            values = self.preset_dictionary[preset_name]                        
            for col in range(0,len(values[0])):            
                if values[0][col] != 0:
                    # Header
                    self.tableWidget_tsi_scan_options.setColumnCount(self.tableWidget_tsi_scan_options.columnCount()+1)
                    header_item = QtWidgets.QTableWidgetItem("Band " + str(self.tableWidget_tsi_scan_options.columnCount()))
                    header_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_tsi_scan_options.setHorizontalHeaderItem(self.tableWidget_tsi_scan_options.columnCount()-1,header_item)
                    
                    for row in range(0,len(values)):
                        # Other Items
                        new_item = QtWidgets.QTableWidgetItem(values[row][col])
                        new_item.setTextAlignment(QtCore.Qt.AlignCenter)        
                        self.tableWidget_tsi_scan_options.setItem(row,col,new_item)
            
                    # Draw New Rectangle    
                    h = self.tuning_matplotlib_widget.axes.add_patch(patches.Rectangle((float(values[0][col])/10, 
                        (self.tuning_matplotlib_widget.band_height*(len(self.tuning_matplotlib_widget.bands)+1))),
                            float(values[1][col])/10-float(values[0][col])/10,self.tuning_matplotlib_widget.band_height,facecolor="blue",edgecolor="Black"))
                    self.tuning_matplotlib_widget.bands.append(h)    
            
                    # Draw Text Label
                    x_offset = 10
                    band_number = str(self.tableWidget_tsi_scan_options.columnCount())
                    if band_number == "10":
                        x_offset = 15
                    self.tuning_matplotlib_widget.axes.text(float(values[0][col])/10 - x_offset,(self.tuning_matplotlib_widget.band_height*(len(self.tuning_matplotlib_widget.bands)+1)) - 5,band_number,fontsize=10)     
                    
            # Redraw the Plot
            self.tuning_matplotlib_widget.draw()            
        
            # Resize Table Columns and Rows
            self.tableWidget_tsi_scan_options.resizeColumnsToContents()
            self.tableWidget_tsi_scan_options.resizeRowsToContents()
            self.tableWidget_tsi_scan_options.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_tsi_scan_options.horizontalHeader().setStretchLastSection(True)
        
            # Enable Remove Band Pushbutton
            self.pushButton_tsi_remove_band.setEnabled(True)

    def _slotTSI_DeletePresetClicked(self):
        """ Deletes the currently selected preset from the list
        """
        # Delete from the Table
        for item in self.listWidget_tsi_scan_presets.selectedItems():
            self.listWidget_tsi_scan_presets.takeItem(self.listWidget_tsi_scan_presets.row(item))

            # Delete from Memory    
            del self.preset_dictionary[str(item.text())]
            
    def _slotMenuOptionsClicked(self):
        """ Opens the Options dialog for the current tab.
        """        
        dlg = OptionsDialog(opening_tab = self.tabWidget.tabText(self.tabWidget.currentIndex()), settings_dictionary = self.dashboard_settings_dictionary)
        dlg.show()
        dlg.exec_() 
        
        # OK Clicked
        get_value = dlg.return_value
        if len(get_value) > 0:       
            self.dashboard_settings_dictionary = dlg.settings_dictionary
            
            # Update Settings Across Components
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Update FISSURE Configuration')       

        
    def _slotPD_DemodulationViewFlowGraphClicked(self):
        """ Views the currently loaded flow graph in GNU Radio Companion
        """
        try:
            # Get the Flow Graph Name
            loaded_flow_graph = str(self.textEdit_pd_flow_graphs_filepath.toPlainText())
            loaded_flow_graph = loaded_flow_graph.replace(" ","\ ")
            loaded_flow_graph = loaded_flow_graph.rpartition('.')[0] + ".grc"

            # Open the Flow Graph in GNU Radio Companion
            osCommandString = "gnuradio-companion " + loaded_flow_graph
            os.system(osCommandString+ " &")
        
        except:    
            print("error")
        
    def _slotPD_DemodulationLoadFlowGraphClicked(self, checked, fname=""):
        """ Loads a new flow graph from the library and sends it to FGE to run
        """
        if fname == "":
            # Look for the Flow Graph
            directory = os.path.dirname(os.path.realpath(__file__)) + '/Flow Graph Library/PD Flow Graphs'  # Default Directory
            fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select Flow Graph...", directory, filter="Flow Graphs (*.py)")[0]
        
        else:
            # Flow Graph Filename was Provided
            flow_graph_directory = os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/PD Flow Graphs/"
            
            # Enable/Disable the Sniffer Buttons
            get_hardware = str(self.comboBox_pd_demod_hardware.currentText())
            get_sniffer_type = getDemodulationFlowGraphsSnifferType(self.pd_library, fname)
            self.pushButton_pd_sniffer_stream.setEnabled(False)
            self.pushButton_pd_sniffer_tagged_stream.setEnabled(False)
            self.pushButton_pd_sniffer_msg_pdu.setEnabled(False)
            if get_sniffer_type == "Stream":
                self.pushButton_pd_sniffer_stream.setEnabled(True)
            elif get_sniffer_type == "Tagged Stream":
                self.pushButton_pd_sniffer_tagged_stream.setEnabled(True)
            elif get_sniffer_type == "Message/PDU":
                self.pushButton_pd_sniffer_msg_pdu.setEnabled(True)
                
            fname = flow_graph_directory + fname

        # If a Valid File
        if fname != "":
            # Attempt to Open the File
            error_found = False
            try:
                f = open(str(fname),'r')
            except:
                error_found = True
                self.errorMessage("Flow Graph was not Found in PD Flow Graph Library!")  
            
            if error_found == False:    
                # Update the Edit Box
                self.textEdit_pd_flow_graphs_filepath.setPlainText(fname)
                
                # Update the Status Dialog 
                self.status_dialog.tableWidget_status_results.item(2,0).setText("Loaded: " + str(fname.split('/')[-1]))
                
                # Update the Protocol Tab Labels
                self.label_pd_status_loaded_flow_graph.setText(str(fname.split('/')[-1]))
                self.label_pd_status_flow_graph_status.setText("Stopped")
                
                # Update the Description and Variable Listings in "Flow Graph" tab
                temp_flow_graph_variables = {}                
                self.label_pd_flow_graphs_description.setText("")
                self.label_pd_flow_graphs_default_variables.setText("")
                self.tableWidget_pd_flow_graphs_current_values.clearContents()
                self.tableWidget_pd_flow_graphs_current_values.setRowCount(0)    
                parsing = False
                description_parsing = False
                for line in f:
                    # Description
                    if line.startswith("# Description: "):
                        description_parsing = True
                    elif line.startswith("# GNU Radio version: "):
                        description_parsing = False
                    if description_parsing:
                        # Get Text
                        get_line = line        
                        get_line = get_line.replace("# Description: ","")
                        
                        # Break it up by Keywords    
                        if "OSI Levels: " in get_line:
                            get_line = get_line.partition("OSI Levels:")[0] + "\n" + "\n" + get_line.partition("OSI Levels:")[1] + get_line.partition("OSI Levels:")[2]
                        if "Description: " in get_line:
                            get_line = get_line.partition("Description:")[0] + "\n" + "\n" + get_line.partition("Description:")[1] + get_line.partition("Description:")[2]    
                        
                        # Fill in the "Loaded Flow Graph" Label    
                        if get_line != "":                        
                            self.label_pd_flow_graphs_description.setText(self.label_pd_flow_graphs_description.text() + get_line)
                            
                    # Variables        
                    if line.startswith("        # Variables"):
                        parsing = True
                    elif line.startswith("        # Blocks"):
                        parsing = False
                    if parsing:
                        # Strip Extra Text
                        get_line = line.split('=',1)[-1]
                        get_line = get_line.split('#',1)[0]
                        get_line = get_line.lstrip()
                        
                        if get_line != "":                                                    
                            # Fill in the "Default Variables" Label
                            self.label_pd_flow_graphs_default_variables.setText(self.label_pd_flow_graphs_default_variables.text() + get_line)
                            
                            # Fill in the "Current Values" Table
                            variable_name = get_line.split(' = ')[0]
                            variable_name_item = QtWidgets.QTableWidgetItem(variable_name)
                            value_text = get_line.split(' = ')[1].rstrip('\n')
                            value_text = value_text.replace('"','')
                            
                            # Replace with Global Constants
                            if variable_name == "ip_address":
                                value_text = self.dashboard_settings_dictionary['hardware_ip_pd']
                            elif variable_name == "serial":
                                if len(self.dashboard_settings_dictionary['hardware_serial_pd']) > 0:
                                    if self.dashboard_settings_dictionary['hardware_pd'] == "HackRF":
                                        value_text = self.dashboard_settings_dictionary['hardware_serial_pd']
                                    else:
                                        value_text = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_pd']                                
                                else:
                                    if self.dashboard_settings_dictionary['hardware_pd'] == "HackRF":
                                        value_text = ""
                                    else:
                                        value_text = "False"
                            
                            # Fill in the "Current Values" Table
                            value = QtWidgets.QTableWidgetItem(value_text)
                            self.tableWidget_pd_flow_graphs_current_values.setRowCount(self.tableWidget_pd_flow_graphs_current_values.rowCount()+1)
                            self.tableWidget_pd_flow_graphs_current_values.setVerticalHeaderItem(self.tableWidget_pd_flow_graphs_current_values.rowCount()-1,variable_name_item)    
                            self.tableWidget_pd_flow_graphs_current_values.setItem(self.tableWidget_pd_flow_graphs_current_values.rowCount()-1,0,value)    

                            # Store Variables and Values to a Dictionary
                            temp_flow_graph_variables[str(variable_name_item.text())] = str(value.text())
                            
                            # Create Apply Pushbutton
                            #new_pushbutton = QtWidgets.QPushButton(self.tableWidget_pd_flow_graphs_current_values)
                            #new_pushbutton.setText("Apply")
                            #self.tableWidget_pd_flow_graphs_current_values.setCellWidget(self.tableWidget_pd_flow_graphs_current_values.rowCount()-1,1,new_pushbutton)
                            #new_pushbutton.clicked.connect(self._slotPD_DemodulationApplyChangesClicked)
                
                # Close the File
                f.close()  
                            
                # Adjust Table
                self.tableWidget_pd_flow_graphs_current_values.resizeRowsToContents()
                
                # Copy the Flow Graph Dictionary
                self.flow_graph_variables = temp_flow_graph_variables    
                
                # Enable/Disable the Push Buttons
                self.pushButton_pd_flow_graphs_view.setEnabled(True)
                self.pushButton_pd_flow_graphs_start_stop.setEnabled(True)
                self.pushButton_pd_flow_graphs_apply_changes.setEnabled(False)
                self.pushButton_pd_flow_graphs_restore_defaults.setEnabled(False)
                
                # Update Flow Graph Status Label
                self.label_pd_flow_graphs_status.setText("Not Running")
                
                # Enable Protocol Discovery
                self.pushButton_pd_status_start.setEnabled(True)
            
                # Start Protocol Discovery if "Auto-Start Protocol Discovery" is Activated
                if self.checkBox_automation_auto_start_pd.isChecked():
                    self._slotPD_StatusStartClicked()
             
                
    def _slotAutomationReceiveOnlyClicked(self):
        """ Adjusts the Dashboard and HIPRFISR settings to enable/disable transmission capabilities
        """    
        # Receive-Only (Checked)
        if self.checkBox_automation_receive_only.isChecked():
            self.tabWidget.setTabEnabled(3,False)
            
            # Stop the Running Attack;
            if self.pushButton_attack_start_stop.text() == "Stop Attack":
                self._slotAttackStartStopAttack()
            
        # Normal Operation (Unchecked)
        else:
            if self.pushButton_automation_system_start.text() == "Stop":
                self.tabWidget.setTabEnabled(3,True)
                            
    def _slotAutomationAutoSelectSOIsClicked(self):
        """ Enables/Disables the auto-selection of SOIs from the list.
        """
        # Checked
        if self.checkBox_automation_auto_select_sois.isChecked():    
            self.dashboard_settings_dictionary['process_SOIs'] = "True"
            self.label_soi_list_priority.setVisible(True)
            self.tableWidget_automation_soi_list_priority.setVisible(True)
            self.label_soi_priority_row1.setVisible(True)
            if self.tableWidget_automation_soi_list_priority.rowCount() > 1:
                self.label_soi_priority_row2.setVisible(True)
            if self.tableWidget_automation_soi_list_priority.rowCount() > 2:    
                self.label_soi_priority_row3.setVisible(True)
            self.pushButton_automation_soi_priority_add_level.setVisible(True)
            self.pushButton_automation_soi_priority_remove_level.setVisible(True)
            self.pushButton_tsi_untarget.setText("Auto-Select")
            self.pushButton_pd_flow_graphs_auto_select.setVisible(True)
                        
            # Disable Target Radio Buttons in AMC Table
            for rows in range(0,self.tableWidget_tsi_narrowband.rowCount()):
                self.tableWidget_tsi_narrowband.cellWidget(rows,0).setEnabled(False)
                
            # Send Messages to the HIPRFISR if the System is Running
            if self.pushButton_automation_system_start.text() == "Stop":
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Process SOIs', Parameters = [False,None,None,None])        
                self.dashboard_settings_dictionary['SOI_trigger_mode'] = "2"
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'SOI Selection Mode', Parameters = int(self.dashboard_settings_dictionary['SOI_trigger_mode']))    

                # Search for SOIs if None are Checked
                checked = False
                for x in range(0,self.tableWidget_tsi_narrowband.rowCount()):
                    if self.tableWidget_tsi_narrowband.cellWidget(x,0).isChecked():
                        checked = True
                        break
                if checked == False:
                    self.autoSelectSOI()
            
        # Unchecked    
        else:
            self.dashboard_settings_dictionary['process_SOIs'] = "False"
            self.label_soi_list_priority.setVisible(False)
            self.tableWidget_automation_soi_list_priority.setVisible(False)
            self.label_soi_priority_row1.setVisible(False)
            self.label_soi_priority_row2.setVisible(False)
            self.label_soi_priority_row3.setVisible(False)
            self.pushButton_automation_soi_priority_add_level.setVisible(False)
            self.pushButton_automation_soi_priority_remove_level.setVisible(False)
            self.pushButton_tsi_untarget.setText("Untarget")
            self.pushButton_pd_flow_graphs_auto_select.setVisible(False)    
            
            # Enable Target Radio Buttons in AMC Table
            for rows in range(0,self.tableWidget_tsi_narrowband.rowCount()):
                self.tableWidget_tsi_narrowband.cellWidget(rows,0).setEnabled(True)            
                
            # Send Messages to the HIPRFISR if the System is Running
            if self.pushButton_automation_system_start.text() == "Stop":
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Process SOIs', Parameters = [False,None,None,None])        
                self.dashboard_settings_dictionary['SOI_trigger_mode'] = "0"
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'SOI Selection Mode', Parameters = int(self.dashboard_settings_dictionary['SOI_trigger_mode']))            
            
    def _slotPD_DemodulationSetRecommendedFlowGraphs(self, same_modulation_list_names):        
        """ Updates the list of recommended flow graphs in the "Flow Graph" tab. This function is a callback from the HIPRFISR.
        """            
        # Clear the List(s)
        self.listWidget_pd_flow_graphs_recommended_fgs.clear()
        
        # Format the String
        modulation_list = yaml.load(same_modulation_list_names, yaml.FullLoader)

        # Add the Filenames to the List            
        self.listWidget_pd_flow_graphs_recommended_fgs.addItems(modulation_list)
            
        # Select the First File
        self.listWidget_pd_flow_graphs_recommended_fgs.setCurrentRow(0)    
        
        # Auto-Load PD Flow Graphs is Selected
        if self.checkBox_automation_auto_select_pd_flow_graphs.isChecked():
            # Target Protocol if Targeting
            target_protocol = str(self.comboBox_automation_target_protocol.currentText()) 
            
            # Protocol Flow Graph
            match_found = False
            if target_protocol != "None":              
                for n in range(0,len(modulation_list)):
                    if target_protocol in modulation_list[n]:
                        # Select Flow Graph
                        self.listWidget_pd_flow_graphs_recommended_fgs.setCurrentRow(n)
                        self._slotPD_DemodulationLoadSelectedClicked() 
                        match_found = True
                
            # Generic Flow Graph
            if match_found == False:
                get_modulation = str(self.textEdit_pd_flow_graphs_modulation.toPlainText()).upper()                
                for n in range(0,len(modulation_list)):
                    if get_modulation in modulation_list[n]:
                        # Select Flow Graph                        
                        self.listWidget_pd_flow_graphs_recommended_fgs.setCurrentRow(n)
                        self._slotPD_DemodulationLoadSelectedClicked() 
        
        # Insert Message into the Status Window
        get_text = time.strftime('%H:%M:%S', time.localtime()) + ": Recommended Flow Graphs: " + str(modulation_list) +  "\n"
        self._slotPD_AddStatus(get_text)
        
        # Show/Hide the PD Flow Graph Lookup Not Found Label
        if len(modulation_list) == 0:
            self.label_pd_flow_graphs_lookup_not_found.setText("Not Found!")
        else:
            self.label_pd_flow_graphs_lookup_not_found.setText("Found!")     
        
    def _slotSOI_Chosen(self, target_SOI):
        """ The HIPRFISR returned a SOI to target. This checks the radio button of the chosen SOI
        """
        target_SOI = target_SOI.replace("(","")
        target_SOI = target_SOI.replace(")","")
        target_SOI = target_SOI.replace("'","")
        target_SOI = target_SOI.replace(" ","")
        target_SOI_label = ""
        
        # Search the Table
        for row in range(0,self.tableWidget_tsi_narrowband.rowCount()):
            # A Match is Found            
            if target_SOI == self.tableWidget_tsi_narrowband.item(row,3).text() + "," + self.tableWidget_tsi_narrowband.item(row,1).text() + "," + self.tableWidget_tsi_narrowband.item(row,2).text():
                target_SOI_label = "(" + self.tableWidget_tsi_narrowband.item(row,3).text() + "," + self.tableWidget_tsi_narrowband.item(row,1).text() + "," + self.tableWidget_tsi_narrowband.item(row,2).text() + ")"
                get_radio_button = self.tableWidget_tsi_narrowband.cellWidget(row,0)
                get_radio_button.setChecked(True)  # Check the radiobutton    
                print("CALLING TARGET SELECTED")
                self.targetSelected(row)
                                
                # Update the Text
                self.textEdit_pd_status_target.setPlainText("Frequency (MHz): " + self.tableWidget_tsi_narrowband.item(row,1).text())        
                self.textEdit_pd_status_target.append("Power (dB): " + self.tableWidget_tsi_narrowband.item(row,2).text())    
                self.textEdit_pd_status_target.append("Modulation: " + self.tableWidget_tsi_narrowband.item(row,3).text())
                self.textEdit_pd_status_target.append("Bandwidth (MHz): " + self.tableWidget_tsi_narrowband.item(row,4).text())
                self.textEdit_pd_status_target.append("Continuous: " + self.tableWidget_tsi_narrowband.item(row,5).text())
                self.textEdit_pd_status_target.append("Start Frequency (MHz): " + self.tableWidget_tsi_narrowband.item(row,6).text())
                self.textEdit_pd_status_target.append("End Frequency (MHz): " + self.tableWidget_tsi_narrowband.item(row,7).text())
                self.textEdit_pd_status_target.append("Confidence: " + self.tableWidget_tsi_narrowband.item(row,8).text())
                
                break
                
    def _slotSetFullLibrary(self,full_lib_dict):
        """ Updates the Dashboard's protocol library and loads protocols into the packet crafter.
        """
        # Save the Library to the Dashboard Copy
        full_lib_dict = yaml.load(full_lib_dict, yaml.FullLoader)
        self.pd_library = full_lib_dict    
        
        # Refresh Library-Dependent Features        
        protocols = getProtocols(self.pd_library)
        
        # Packet Crafter Protocols
        self.comboBox_packet_protocols.clear()
        protocols_with_packet_types = []
        for p in protocols:                        
            if len(getPacketTypes(self.pd_library,p)) > 0:  
                protocols_with_packet_types.append(p)
        self.comboBox_packet_protocols.addItems(sorted(protocols_with_packet_types))  
        
        # Bit Viewer Protocols
        self.comboBox_pd_bit_viewer_protocols.clear()
        self.comboBox_pd_bit_viewer_protocols.addItems(sorted(protocols_with_packet_types))  
        
        # Dissector Protocols
        self.comboBox_pd_dissectors_protocol.clear()
        self.comboBox_pd_dissectors_protocol.addItems(sorted(protocols_with_packet_types))         
          
        # Attack Tab Protocols
        self.comboBox_attack_protocols.clear()
        protocols_with_attacks = []
        for p in protocols:                        
            if len(getAttacks(self.pd_library,p)) > 0:  
                protocols_with_attacks.append(p)
        self.comboBox_attack_protocols.addItems(sorted(protocols_with_attacks))        
        
        # Gallery Protocols
        self.comboBox_library_gallery_protocol.clear()
        protocols_with_images = []
        for p in protocols:                        
            if len(self.findGalleryImages(p)) > 0:  
                protocols_with_images.append(p)
        self.comboBox_library_gallery_protocol.addItems(sorted(protocols_with_images))        
        
        self.treeWidget_attack_attacks.clear()
        self.populateAttackTreeWidget()
        self.treeWidget_attack_attacks.expandAll()
        self._slotAttackProtocols()
        
        # Library Remove Protocols
        self.comboBox_library_browse_protocol.clear()
        self.comboBox_library_browse_protocol.addItems(sorted(protocols))
        
        # Sniffer Protocols   
        self.comboBox_pd_sniffer_protocols.clear()
        protocols_with_demod_fgs = []
        for p in protocols:                        
            if len(getDemodulationFlowGraphs(self.pd_library,p,"","")) > 0:  
                protocols_with_demod_fgs.append(p)
        self.comboBox_pd_sniffer_protocols.addItems(sorted(protocols_with_demod_fgs))        
        
        # Automation Target Protocols
        get_targeted_protocol = str(self.comboBox_automation_target_protocol.currentText())  # Might want to recheck that this is ok.
        self.comboBox_automation_target_protocol.clear()
        self.comboBox_automation_target_protocol.addItems(sorted(protocols))
        index = self.comboBox_automation_target_protocol.findText(get_targeted_protocol, QtCore.Qt.MatchFixedString)
        if index >= 0:
            self.comboBox_automation_target_protocol.setCurrentIndex(index)
        
        self._slotAttackImportFileTypeChanged()
        
        # PD: Add to Library: Reset to Last Protocol Used or Added
        get_last_protocol = self.comboBox_library_pd_protocol.currentText()
        self.comboBox_library_pd_protocol.clear()
        self.comboBox_library_pd_protocol.addItem("-- New Protocol --")
        self.comboBox_library_pd_protocol.addItems(sorted(protocols))
        if get_last_protocol == "-- New Protocol --":
            get_last_protocol = self.textEdit_library_pd_new_protocol.toPlainText()
        for i in range(self.comboBox_library_pd_protocol.count()):
            if get_last_protocol == self.comboBox_library_pd_protocol.itemText(i):
                self.comboBox_library_pd_protocol.setCurrentIndex(i)
                
        # Update All Flow Graphs in Demodulation Tab
        self._slotPD_DemodHardwareChanged()
                
        # Update Browse YAML Files
        self._slotLibraryBrowseYAML_Changed()
        
        # Create a Dialog Window    
        self.errorMessage("Library updated successfully.") 
                
                        
    def _slotPD_AddStatus(self,statusmessage):
        """ Adds a new status message to the Protocol Discovery log after receiving information from the PD component.
        """
        # Add Status Message to PD Log
        get_text = self.textEdit_pd_status.toPlainText()
        get_text = get_text + statusmessage  
        self.textEdit_pd_status.setText(get_text)                           
        
    def _slotPD_DemodulationLoadSelectedClicked(self):
        """ Loads the currently selected flow graph from the "Recommended Flow Graphs" list.
        """
        if self.listWidget_pd_flow_graphs_recommended_fgs.count() > 0:
            # Get the File Name
            fname = self.listWidget_pd_flow_graphs_recommended_fgs.currentItem().text()
            
            # Stop the Current Flow Graph
            if self.pushButton_pd_flow_graphs_start_stop.text() == "Stop":
                self._slotPD_DemodulationStartStopClicked()
                
            # Load the File
            self._slotPD_DemodulationLoadFlowGraphClicked(None, fname)
            
    def _slotPD_DemodulationLoadSelectedAllClicked(self):
        """ Loads the currently selected flow graph from the "All Flow Graphs" list.
        """
        if self.listWidget_pd_flow_graphs_all_fgs.count() > 0:
            # Get the File Name
            fname = self.listWidget_pd_flow_graphs_all_fgs.currentItem().text()
            
            # Stop the Current Flow Graph
            if self.pushButton_pd_flow_graphs_start_stop.text() == "Stop":
                self._slotPD_DemodulationStartStopClicked()
                
            # Load the File
            self._slotPD_DemodulationLoadFlowGraphClicked(None, fname)            
            
    def _slotPD_DemodulationLookupClearClicked(self):
        """ Clears the values of the edit boxes in the "Flow Graph" Tab
        """
        self.textEdit_pd_flow_graphs_frequency.setPlainText("")
        self.textEdit_pd_flow_graphs_modulation.setPlainText("")
        self.textEdit_pd_flow_graphs_bandwidth.setPlainText("")
        self.comboBox_pd_flow_graphs_continuous.setCurrentIndex(1)
        self.textEdit_pd_flow_graphs_start_frequency.setPlainText("")
        self.textEdit_pd_flow_graphs_end_frequency.setPlainText("")
        
    def _slotPD_DemodulationLookupClicked(self):
        """ Sends a SOI to the HIPRFISR to look up in the signal library. Same effect as clicking the target radio button.
        """
        # Get SOI Data
        soi_data = ["","","","","","","","","",""]
        if self.checkBox_pd_flow_graphs_frequency.isChecked():
            soi_data[0] = str(self.textEdit_pd_flow_graphs_frequency.toPlainText())
            soi_data[6] = str(self.textEdit_pd_flow_graphs_frequency_margin.toPlainText())                
        if self.checkBox_pd_flow_graphs_modulation.isChecked():
            soi_data[1] = str(self.textEdit_pd_flow_graphs_modulation.toPlainText()).upper()
        if self.checkBox_pd_flow_graphs_bandwidth.isChecked():
            soi_data[2] = str(self.textEdit_pd_flow_graphs_bandwidth.toPlainText())
            soi_data[7] = str(self.textEdit_pd_flow_graphs_bandwidth_margin.toPlainText())
        if self.checkBox_pd_flow_graphs_continuous.isChecked():            
            soi_data[3] = str(self.comboBox_pd_flow_graphs_continuous.currentText())            
        if self.checkBox_pd_flow_graphs_start_frequency.isChecked():
            soi_data[4] = str(self.textEdit_pd_flow_graphs_start_frequency.toPlainText())
            soi_data[8] = str(self.textEdit_pd_flow_graphs_start_frequency_margin.toPlainText())
        if self.checkBox_pd_flow_graphs_end_frequency.isChecked():
            soi_data[5] = str(self.textEdit_pd_flow_graphs_end_frequency.toPlainText())
            soi_data[9] = str(self.textEdit_pd_flow_graphs_end_frequency_margin.toPlainText())
            
        # Get Hardware
        get_hardware = self.dashboard_settings_dictionary['hardware_pd']

        # Clear Results Table
        self.tableWidget_library_search_results.setRowCount(0)         
        
        # Send Message
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Search Library for Flow Graphs', Parameters = [soi_data, get_hardware])
        
        # Change the Label
        self.label_pd_flow_graphs_lookup_not_found.setText("Searching...")

            
    def _slotPD_DemodulationStartStopClicked(self):
        """ Signals to the HIPRFISR to stop/resume the currently running flow graph and toggles the push button text
        """
        # Send Stop Message to the HIPRFISR
        if self.pushButton_pd_flow_graphs_start_stop.text() == "Stop":
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop PD Flow Graph', Parameters = '')
            
            # Toggle the Text
            self.pushButton_pd_flow_graphs_start_stop.setText("Start")  
            
            # Enable/Disable the Pushbuttons
            self.pushButton_pd_flow_graphs_apply_changes.setEnabled(False)
            self.pushButton_pd_flow_graphs_restore_defaults.setEnabled(False)
            
            # Update Flow Graph Status Labels
            self.label_pd_flow_graphs_status.setText("Stopped")
            self.label_pd_status_flow_graph_status.setText("Stopped")
        
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(2,0).setText('Flow Graph Stopped')
            
                
        # Reset to Last Known Flow Graph Configuration        
        elif self.pushButton_pd_flow_graphs_start_stop.text() == "Start":    
            # Toggle the Text        
            self.pushButton_pd_flow_graphs_start_stop.setText("Stop") 
            
            # Enable/Disable the Pushbuttons
            self.pushButton_pd_flow_graphs_restore_defaults.setEnabled(True)
        
            # Send Message(s) to the HIPRFISR for each Variable Name and Value
            variable_names = []
            variable_values = []
            for get_row in range(self.tableWidget_pd_flow_graphs_current_values.rowCount()):                
                # Save the Variable Name and Value in the Row to a Dictionary
                variable_names.append(str(self.tableWidget_pd_flow_graphs_current_values.verticalHeaderItem(get_row).text()))
                variable_values.append(str(self.tableWidget_pd_flow_graphs_current_values.item(get_row,0).text()))
    
            # Update Flow Graph Status Labels
            self.label_pd_flow_graphs_status.setText("Starting...")
            self.pushButton_pd_flow_graphs_start_stop.setEnabled(False)  # Causes errors when stopped while loading
            self.label_pd_status_flow_graph_status.setText("Starting...")
                
            # Send "Run PD Flow Graph" Message to the HIPRFISR
            fname = self.textEdit_pd_flow_graphs_filepath.toPlainText()
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Run PD Flow Graph', Parameters = [str(fname.split('/')[-1]), variable_names, variable_values])
            
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(2,0).setText('Starting... ' + fname.split('/')[-1])
    
    def _slotPD_DemodulationApplyChangesClicked(self):
        """ Applies any changes made in the "Flow Graph Current Values" table by calling the 'set' functions in the flow graph modules
        """        
        # Send Message(s) to the HIPRFISR for each Variable Name and Value
        for get_row in range(self.tableWidget_pd_flow_graphs_current_values.rowCount()):
            
            # Determine the Variable Name and Value in the Row
            variable_name = self.tableWidget_pd_flow_graphs_current_values.verticalHeaderItem(get_row).text()
            value = self.tableWidget_pd_flow_graphs_current_values.item(get_row,0).text()
                    
            # Check and Send the "Set" Message if Value Changed
            if self.flow_graph_variables[str(variable_name)] != str(value):
                self.flow_graph_variables[str(variable_name)] = str(value)
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Variable', Parameters = ["Protocol Discovery", str(variable_name), str(value)] )
                
        # Disable the Pushbutton
        self.pushButton_pd_flow_graphs_apply_changes.setEnabled(False)

    def _slotPD_DemodulationRestoreDefaultsClicked(self):
        """ Updates the "Current Values" table with the default variables in the flow graph python file
        """
        # Get Flow Graph Filepath
        fname = self.textEdit_pd_flow_graphs_filepath.toPlainText()

        # If a Valid File
        if fname != "":                
            # Update the Variable Listings in "Flow Graph" tab
            f = open(fname,'r')
            self.tableWidget_pd_flow_graphs_current_values.clearContents()
            self.tableWidget_pd_flow_graphs_current_values.setRowCount(0)    
            parsing = False
            for line in f:
                if line.startswith("        # Variables"):
                    parsing = True
                elif line.startswith("        # Blocks"):
                    parsing = False
                if parsing:
                    # Strip Extra Text
                    get_line = line.split('=',1)[-1]
                    get_line = get_line.split('#',1)[0]
                    get_line = get_line.lstrip()
                    
                    if get_line != "":                
                        # Fill in the "Current Values" Table
                        variable_name = QtWidgets.QTableWidgetItem(get_line.split(' = ')[0])
                        value_text = get_line.split(' = ')[1].rstrip('\n')
                        value_text = value_text.replace('"','')
                        value = QtWidgets.QTableWidgetItem(value_text)
                        self.tableWidget_pd_flow_graphs_current_values.setRowCount(self.tableWidget_pd_flow_graphs_current_values.rowCount()+1)
                        self.tableWidget_pd_flow_graphs_current_values.setVerticalHeaderItem(self.tableWidget_pd_flow_graphs_current_values.rowCount()-1,variable_name)    
                        self.tableWidget_pd_flow_graphs_current_values.setItem(self.tableWidget_pd_flow_graphs_current_values.rowCount()-1,0,value)    
            
            # Close the File
            f.close()  
                            
            # Adjust Table
            self.tableWidget_pd_flow_graphs_current_values.resizeRowsToContents()    
            
            # Disable the Pushbutton
            self.pushButton_pd_flow_graphs_restore_defaults.setEnabled(False)
        
    def _slotPD_DemodulationCurrentValuesEdited(self):
        """ Enables the pushbuttons after the "Current Values" table has been edited and the flow graph is stopped
        """
        # Don't Show "Apply All" Button When Flow Graph is Stopped and Changes are Made
        if self.pushButton_pd_flow_graphs_start_stop.text() == "Stop":
            self.pushButton_pd_flow_graphs_apply_changes.setEnabled(True)
        
        self.pushButton_pd_flow_graphs_restore_defaults.setEnabled(True)    
              
    def _slotAttackTemplatesDoubleClicked(self):
        """ Loads the selected attack template for single-stage or multi-stage attacks.
        """   
        # Multi-Stage Attack
        if self.tabWidget_attack_attack.currentIndex() == 1:            
            # Determine if the Item is a Fuzzing Attack
            current_item = self.treeWidget_attack_attacks.currentItem()
            fuzzing_attack = False
            for n in self.pd_library["Attacks"]["Fuzzing Attacks"]:
                if n.split(",")[0] == current_item.text(0):
                    self._slotAttackLoadTemplateClicked() 
                    fuzzing_attack = True
                    break 
            
            if fuzzing_attack == False:
                self._slotAttackMultiStageAdd()
            
        # Single-Stage Atttack
        else:
            self._slotAttackLoadTemplateClicked()
        
                
    def _slotAttackLoadTemplateClicked(self):
        """ Loads the selected attack template configuration in the "Attack" tab
        """    
        # Attack is not Currently Running
        if self.pushButton_attack_start_stop.text() == "Start Attack" and self.pushButton_attack_fuzzing_start.text() == "Start Attack":
        
            # Get the Selected Item from the Tree Widget
            current_item = self.treeWidget_attack_attacks.currentItem()

            # Ignore "No Selection" and Expand Selected Categories
            categories = ["Single-Stage","Denial of Service","Jamming","Spoofing","Sniffing/Snooping","Probe Attacks","Fuzzing","File","Installation of Malware","Misuse of Resources","Multi-Stage"]
            if any(x == current_item.text(0) for x in categories):
                #self.treeWidget_attack_attacks.expandItem(current_item)  # Disabled to allow double clicking
                pass
                
            # Not a Category    
            else:   
                # Determine if the Item is a Single-Stage Attack
                single_stage_attack = False
                for n in self.pd_library["Attacks"]["Single-Stage Attacks"]:
                    if n.split(",")[0] == current_item.text(0):
                        single_stage_attack = True                
                
                # Determine if the Item is a Multi-Stage Attack
                multi_stage_attack = False
                for n in self.pd_library["Attacks"]["Multi-Stage Attacks"]:
                    if n.split(",")[0] == current_item.text(0):
                        multi_stage_attack = True
                        
                # Determine if the Item is a Fuzzing Attack
                fuzzing_attack = False
                for n in self.pd_library["Attacks"]["Fuzzing Attacks"]:
                    if n.split(",")[0] == current_item.text(0):
                        fuzzing_attack = True   
                                                
                # Single-Stage Attack
                if single_stage_attack == True:
          
                    # Switch to Single-Stage Tab
                    self.tabWidget_attack_attack.setCurrentIndex(0)   
                                   
                    # Update the "Selected" Labels 
                    self.label_selected_protocol.setText(self.comboBox_attack_protocols.currentText())                
                    self.label_selected_modulation.setText(self.comboBox_attack_modulation.currentText())                
                    self.label_selected_attack.setText(current_item.text(0))                    
                    
                    # Get Filename from the Library
                    get_hardware = str(self.comboBox_attack_hardware.currentText())
                    get_file_type = list(self.pd_library["Protocols"][str(self.comboBox_attack_protocols.currentText())]["Attacks"][str(current_item.text(0))][str(self.comboBox_attack_modulation.currentText())]["Hardware"][get_hardware].keys())[0]
                    fname = self.pd_library["Protocols"][str(self.comboBox_attack_protocols.currentText())]["Attacks"][str(current_item.text(0))][str(self.comboBox_attack_modulation.currentText())]["Hardware"][get_hardware][get_file_type]                   
                    
                    # Update File Type Label
                    self.label_attack_single_stage_file_type.setText(get_file_type)
                    
                    # Enable the Pushbuttons
                    self.pushButton_attack_start_stop.setEnabled(True)
                    self.pushButton_attack_view_flow_graph.setEnabled(True)
                    
                    # Load the File
                    self._slotAttackLoadFromLibraryClicked(None,fname,get_file_type)
                        
                # Multi-Stage Attack
                if multi_stage_attack == True:
                    
                    # Initialize Multi-Stage Tab
                    self.tabWidget_attack_attack.setCurrentIndex(1)
                                                            
                    # Disable Multi-Stage Buttons
                    self.pushButton_attack_multi_stage_generate.setEnabled(False)
                    self.pushButton_attack_multi_stage_save.setEnabled(False)
                    self.pushButton_attack_multi_stage_load.setEnabled(False)
                    self.pushButton_attack_multi_stage_start.setEnabled(False)
                    self.tabWidget_attack_multi_stage.setEnabled(False)
                    
                    # Clear Tables/Labels
                    self.tableWidget_attack_multi_stage_attacks.setRowCount(0)
                    self.label_selected_flow_graph.setText("")
                    self.label_attack_fuzzing_selected_flow_graph.setText("")
                    
                    # Remove Tabs
                    for n in reversed(range(0,self.tabWidget_attack_multi_stage.count())):
                        self.tabWidget_attack_multi_stage.removeTab(n)
                    
                    # Enable Load Pushbutton
                    self.pushButton_attack_multi_stage_load.setEnabled(True)
                    
                    # New Multi-Stage
                    if current_item.text(0) == "New Multi-Stage":
                        pass
                        
                    # Saved Multi-Stage Attack
                    else:
                        # Get Filename from the Library
                        get_hardware = str(self.comboBox_attack_hardware.currentText())
                        get_file_type = list(self.pd_library["Protocols"][str(self.comboBox_attack_protocols.currentText())]["Attacks"][str(current_item.text(0))][str(self.comboBox_attack_modulation.currentText())]["Hardware"][get_hardware].keys())[0]
                        fname = self.pd_library["Protocols"][str(self.comboBox_attack_protocols.currentText())]["Attacks"][str(current_item.text(0))][str(self.comboBox_attack_modulation.currentText())]["Hardware"][get_hardware][get_file_type]                   
                        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/" + fname
                        
                        # Load Multi-Stage Attack
                        self._slotAttackMultiStageLoadClicked(filepath)                    
                        
                # Fuzzing Attack
                if fuzzing_attack == True:
                    
                    # Fuzzing - Variables
                    if current_item.text(0) == "Variables":
                        self.tabWidget_attack_attack.setCurrentIndex(2)
                        self.tabWidget_attack_fuzzing.setCurrentIndex(0)
                                        
                        # Clear Tables/Labels
                        self.label_attack_fuzzing_selected_flow_graph.setText("")    
                        self.textEdit_fuzzing_from_file.setPlainText("")
                        for rows in reversed(range(0,self.tableWidget_fuzzing_variables.rowCount())):
                            self.tableWidget_fuzzing_variables.removeRow(rows)
                        for rows in reversed(range(0,self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount())):
                            self.tableWidget_attack_fuzzing_flow_graph_current_values.removeRow(rows)                
                            
                        # Update the "Selected" Labels 
                        self.label_attack_fuzzing_selected_protocol.setText(self.comboBox_attack_protocols.currentText())
                        self.label_attack_fuzzing_selected_modulation.setText(self.comboBox_attack_modulation.currentText())
                        self.label_attack_fuzzing_selected_attack.setText(current_item.text(0))        
                        
                        # Switch to Variables Tab
                        self.stackedWidget_fuzzing.setCurrentIndex(1)    
                        
                        # Enable Labels/Tables/PushButtons
                        self.label_fuzzing_variables_fg.setEnabled(True)
                        self.textEdit_fuzzing_from_file.setEnabled(True)
                        self.pushButton_attack_fuzzing_select_file.setEnabled(True)
                        self.label_fuzzing_update_period.setEnabled(True)
                        self.textEdit_fuzzing_update_period.setEnabled(True)
                        self.tableWidget_fuzzing_variables.setEnabled(True)    
                        self.pushButton_attack_fuzzing_start.setEnabled(False)
                                                                
                    # Fuzzing - Fields    
                    elif current_item.text(0).split(" - ")[1] == "Fields":
                        self.tabWidget_attack_attack.setCurrentIndex(2)    
                        self.stackedWidget_fuzzing.setCurrentIndex(0)
                        
                        # Clear the Tables/Labels
                        self.tableWidget_attack_fuzzing_data_field.clearContents()
                        
                        # Fuzzing Tab
                        self.tableWidget_attack_fuzzing_data_field.setEnabled(True)
                        self.label_attack_fuzzing_subcategory.setEnabled(True)
                        self.comboBox_attack_fuzzing_subcategory.setEnabled(True)        
                        self.pushButton_attack_fuzzing_restore_defaults.setEnabled(True)
                        self.pushButton_attack_fuzzing_all_binary.setEnabled(True)
                        self.pushButton_attack_fuzzing_all_hex.setEnabled(True)
                        self.label_attack_fuzzing_seed.setEnabled(True)
                        self.textEdit_attack_fuzzing_seed.setEnabled(True)
                        
                        self._slotAttackFuzzingSubcategory()
                        
                        # Update the "Selected" Labels 
                        self.label_attack_fuzzing_selected_protocol.setText(self.comboBox_attack_protocols.currentText())
                        self.label_attack_fuzzing_selected_modulation.setText(self.comboBox_attack_modulation.currentText())
                        self.label_attack_fuzzing_selected_attack.setText(current_item.text(0))
                        
                        # Get Filename from the Library
                        get_hardware = str(self.comboBox_attack_hardware.currentText())
                        get_file_type = list(self.pd_library["Protocols"][str(self.comboBox_attack_protocols.currentText())]["Attacks"][str(current_item.text(0))][str(self.comboBox_attack_modulation.currentText())]["Hardware"][get_hardware].keys())[0]                    
                        fname = self.pd_library["Protocols"][str(self.comboBox_attack_protocols.currentText())]["Attacks"][str(current_item.text(0))][str(self.comboBox_attack_modulation.currentText())]["Hardware"][get_hardware][get_file_type]                   
                        
                        # Load the File
                        self._slotAttackLoadFromLibraryClicked(None,fname)
                
        # Attack is Currently Running
        else:
            self.errorMessage("Please stop the attack in progress before starting a new one.")    
            
    def _slotAttackLoadFromLibraryClicked(self,checked,fname="",ftype="Flow Graph"):
        """ Loads an attack flow graph from a file
        """
        file_dialog_used = False
        if fname == "":
            # Look for the Flow Graph
            directory = os.path.dirname(os.path.realpath(__file__)) + '/Flow Graph Library/Single-Stage Flow Graphs'  # Default Directory
            fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select Attack Flow Graph...", directory, filter="Flow Graphs (*.py)")[0]
            self.label_selected_protocol.setText("")
            self.label_attack_fuzzing_selected_protocol.setText("")
            self.label_selected_modulation.setText("")
            self.label_attack_fuzzing_selected_modulation.setText("")
            self.label_selected_attack.setText("")
            self.label_attack_fuzzing_selected_attack.setText("")
            self.label_selected_notes.setText("")
            self.tabWidget_attack_attack.setCurrentIndex(0)
            file_dialog_used = True
            
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(3,0).setText("Loaded: " + fname.split('/')[-1])
        
        else:
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(3,0).setText("Loaded: " + fname)
            
        # If a Valid File
        if fname != "":                              
            #~ try:                   
            # Fuzzing (Variables)               
            if self.treeWidget_attack_attacks.currentItem().text(0) == "Variables":
                
                # Look for Flow Graphs in this Directory
                if file_dialog_used == False:
                    get_filename = fname
                    flow_graph_directory = os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/"
                    fname = flow_graph_directory + fname
                
                # Set Labels
                self.label_attack_fuzzing_selected_flow_graph.setText(fname)  
                 
                # Read Flow Graph Variables
                temp_flow_graph_variables = {}
                f = open(fname,'r')                 
                self.tableWidget_attack_fuzzing_flow_graph_current_values.setColumnCount(1)
                self.tableWidget_attack_fuzzing_flow_graph_current_values.setRowCount(0)   
                self.tableWidget_attack_fuzzing_flow_graph_current_values.clearContents()
                self.tableWidget_attack_fuzzing_flow_graph_current_values.resizeColumnsToContents()
                self.tableWidget_attack_fuzzing_flow_graph_current_values.horizontalHeader().setStretchLastSection(False)   
                self.tableWidget_attack_fuzzing_flow_graph_current_values.horizontalHeader().setStretchLastSection(True)   
                parsing = False
                for line in f:
                    if line.startswith("        # Variables"):
                        parsing = True
                    elif line.startswith("        # Blocks"):
                        parsing = False
                    if parsing:
                        # Strip Extra Text
                        get_line = line.split('=',1)[-1]
                        get_line = get_line.split('#',1)[0]
                        get_line = get_line.lstrip()
                        
                        if get_line != "":                  
                            # Fill in the "Current Values" Table
                            variable_name = get_line.split(' = ')[0]
                            variable_name_item = QtWidgets.QTableWidgetItem(variable_name)
                            
                            # Replace with Global Constants
                            if variable_name == "ip_address":
                                value_text = self.dashboard_settings_dictionary['hardware_ip_attack']
                            elif variable_name == "serial":
                                if len(self.dashboard_settings_dictionary['hardware_serial_attack']) > 0:
                                    if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                        value_text = self.dashboard_settings_dictionary['hardware_serial_attack']
                                    else:
                                        value_text = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_attack']                               
                                else:
                                    if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                        value_text = ""
                                    else:
                                        value_text = "False"   
                            else:
                                value_text = get_line.split(' = ')[1].rstrip('\n')
                                value_text = value_text.replace('"','')
                                
                            value = QtWidgets.QTableWidgetItem(value_text)

                            self.tableWidget_attack_fuzzing_flow_graph_current_values.setRowCount(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()+1)
                            self.tableWidget_attack_fuzzing_flow_graph_current_values.setVerticalHeaderItem(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()-1,variable_name_item) 
                            self.tableWidget_attack_fuzzing_flow_graph_current_values.setItem(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()-1,0,value) 

                            # Store Variables and Values to a Dictionary
                            temp_flow_graph_variables[variable_name] = str(value.text())
                            
                            # Add a Filepath Button
                            if 'filepath' in variable_name:
                                
                                # Add a New Column
                                self.tableWidget_attack_fuzzing_flow_graph_current_values.horizontalHeader().setStretchLastSection(False)
                                table_width = self.tableWidget_attack_fuzzing_flow_graph_current_values.width()
                                header_width = self.tableWidget_attack_fuzzing_flow_graph_current_values.verticalHeader().sizeHint().width()
                                col1_width = 35
                                col0_width = table_width-header_width-col1_width            
                                self.tableWidget_attack_fuzzing_flow_graph_current_values.setColumnCount(2)
                                self.tableWidget_attack_fuzzing_flow_graph_current_values.setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                                
                                # Create the PushButton
                                new_pushbutton = QtWidgets.QPushButton(self.tableWidget_attack_fuzzing_flow_graph_current_values)
                                new_pushbutton.setText("...")
                                new_pushbutton.setFixedSize(34,23)
                                self.tableWidget_attack_fuzzing_flow_graph_current_values.setCellWidget(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()-1,1,new_pushbutton)
                                get_row_number = self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()-1
                                get_default_directory = self.defaultAttackFilepathDirectory(str(get_filename),variable_name)
                                new_pushbutton.clicked.connect((lambda get_row_number,get_default_directory: lambda: self._slotAttackFuzzingSelectFilepath(get_row = get_row_number, default_directory = get_default_directory))(get_row_number,get_default_directory))  # Pass constant value, not variable value
                                    
                                # Adjust Table
                                self.tableWidget_attack_fuzzing_flow_graph_current_values.setColumnWidth(0,col0_width)
                                self.tableWidget_attack_fuzzing_flow_graph_current_values.setColumnWidth(1,col1_width)                                     
                
                # Close the File
                f.close()  
                            
                # Adjust Table
                self.tableWidget_attack_fuzzing_flow_graph_current_values.resizeRowsToContents()
                
                # Copy the Flow Graph Dictionary
                self.attack_flow_graph_variables = temp_flow_graph_variables    
                                
            # Fuzzing (Fields)          
            elif self.treeWidget_attack_attacks.currentItem().text(0).split(" - ")[1] == "Fields":
                
                # Look for Flow Graphs in this Directory
                if file_dialog_used == False:
                    get_filename = fname
                    flow_graph_directory = os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Fuzzing Flow Graphs/"
                    fname = flow_graph_directory + fname
                
                # Set Labels
                self.label_attack_fuzzing_selected_flow_graph.setText(fname)
                
                # Read Flow Graph Variables
                temp_flow_graph_variables = {}
                f = open(fname,'r')
            
                self.tableWidget_attack_fuzzing_flow_graph_current_values.setColumnCount(1)
                self.tableWidget_attack_fuzzing_flow_graph_current_values.setRowCount(0)   
                self.tableWidget_attack_fuzzing_flow_graph_current_values.clearContents()
                self.tableWidget_attack_fuzzing_flow_graph_current_values.resizeColumnsToContents()
                self.tableWidget_attack_fuzzing_flow_graph_current_values.horizontalHeader().setStretchLastSection(False)
                self.tableWidget_attack_fuzzing_flow_graph_current_values.horizontalHeader().setStretchLastSection(True)

                blocked_variables = ["fuzzing_type","fuzzing_seed","fuzzing_protocol","fuzzing_packet_type","fuzzing_min","fuzzing_max","fuzzing_interval","fuzzing_fields","fuzzing_data"]

                parsing = False
                for line in f:
                    if line.startswith("        # Variables"):
                        parsing = True
                    elif line.startswith("        # Blocks"):
                        parsing = False
                    if parsing:
                        # Strip Extra Text
                        get_line = line.split('=',1)[-1]
                        get_line = get_line.split('#',1)[0]
                        get_line = get_line.lstrip()
                        
                        if get_line != "":                  
                            # Fill in the "Current Values" Table
                            variable_name = get_line.split(' = ')[0]
                            variable_name_item = QtWidgets.QTableWidgetItem(variable_name)
                            
                            # Hide Fuzzing Variables                            
                            if variable_name not in blocked_variables:

                                # Replace with Global Constants
                                if variable_name == "ip_address":
                                    value_text = self.dashboard_settings_dictionary['hardware_ip_attack']
                                elif variable_name == "serial":
                                    if len(self.dashboard_settings_dictionary['hardware_serial_attack']) > 0:
                                        if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                            value_text = self.dashboard_settings_dictionary['hardware_serial_attack']
                                        else:
                                            value_text = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_attack']                               
                                    else:
                                        if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                            value_text = ""
                                        else:
                                            value_text = "False"   
                                else:
                                    value_text = get_line.split(' = ')[1].rstrip('\n')
                                    value_text = value_text.replace('"','')
                                    
                                value = QtWidgets.QTableWidgetItem(value_text)
                                
                                self.tableWidget_attack_fuzzing_flow_graph_current_values.setRowCount(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()+1)
                                self.tableWidget_attack_fuzzing_flow_graph_current_values.setVerticalHeaderItem(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()-1,variable_name_item) 
                                self.tableWidget_attack_fuzzing_flow_graph_current_values.setItem(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()-1,0,value) 

                                # Store Variables and Values to a Dictionary
                                temp_flow_graph_variables[variable_name] = str(value.text())
                                
                                # Add a Filepath Button
                                if 'filepath' in variable_name:
                                    
                                    # Add a New Column
                                    self.tableWidget_attack_fuzzing_flow_graph_current_values.horizontalHeader().setStretchLastSection(False)
                                    table_width = self.tableWidget_attack_fuzzing_flow_graph_current_values.width()
                                    header_width = self.tableWidget_attack_fuzzing_flow_graph_current_values.verticalHeader().sizeHint().width()
                                    col1_width = 35
                                    col0_width = table_width-header_width-col1_width            
                                    self.tableWidget_attack_fuzzing_flow_graph_current_values.setColumnCount(2)
                                    self.tableWidget_attack_fuzzing_flow_graph_current_values.setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                                    
                                    # Create the PushButton
                                    new_pushbutton = QtWidgets.QPushButton(self.tableWidget_attack_fuzzing_flow_graph_current_values)
                                    new_pushbutton.setText("...")
                                    new_pushbutton.setFixedSize(34,23)
                                    self.tableWidget_attack_fuzzing_flow_graph_current_values.setCellWidget(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()-1,1,new_pushbutton)
                                    get_row_number = self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()-1
                                    get_default_directory = self.defaultAttackFilepathDirectory(str(get_filename),variable_name)
                                    new_pushbutton.clicked.connect((lambda get_row_number,get_default_directory: lambda: self._slotAttackFuzzingSelectFilepath(get_row = get_row_number, default_directory = get_default_directory))(get_row_number,get_default_directory))  # Pass constant value, not variable value

                                    # Adjust Table
                                    self.tableWidget_attack_fuzzing_flow_graph_current_values.setColumnWidth(0,col0_width)
                                    self.tableWidget_attack_fuzzing_flow_graph_current_values.setColumnWidth(1,col1_width) 
                            
                # Close the File
                f.close()  
                
                # Adjust Table
                self.tableWidget_attack_fuzzing_flow_graph_current_values.resizeRowsToContents()
                
                # Copy the Flow Graph Dictionary
                self.attack_flow_graph_variables = temp_flow_graph_variables    
                
                # Enable the PushButton
                self.pushButton_attack_fuzzing_start.setEnabled(True)
                
            # Single-Stage
            else:
                # Look for Flow Graphs in this Directory
                if file_dialog_used == False:
                    flow_graph_directory = os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/"
                    get_file = fname
                    fname = flow_graph_directory + fname
                
                # Set Labels
                self.label_selected_flow_graph.setText(fname)
                self.label_selected_notes.setText("")
        
                # Clear Table                
                f = open(fname,'r')
                self.tableWidget_attack_flow_graph_current_values.setColumnCount(1)
                self.tableWidget_attack_flow_graph_current_values.setRowCount(0)    
                self.tableWidget_attack_flow_graph_current_values.clearContents()
                self.tableWidget_attack_flow_graph_current_values.resizeColumnsToContents()
                self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setStretchLastSection(False)
                self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setStretchLastSection(True)
                
                # Enable the Table
                self.tableWidget_attack_flow_graph_current_values.setEnabled(True)    
    
                # Flow Graph
                if ftype == "Flow Graph":
                    # Read Flow Graph Variables
                    temp_flow_graph_variables = {}
                    parsing = False
                    for line in f:
                        if line.startswith("        # Variables"):
                            parsing = True
                        elif line.startswith("        # Blocks"):
                            parsing = False
                        if parsing:
                            # Strip Extra Text
                            get_line = line.split('=',1)[-1]
                            get_line = get_line.split('#',1)[0]
                            get_line = get_line.lstrip()
                            
                            if get_line != "":       
                                # Get Default Variable Name and Value
                                variable_name = get_line.split(' = ')[0]
                                variable_name_item = QtWidgets.QTableWidgetItem(variable_name)
                                value_text = get_line.split(' = ')[1].rstrip('\n')
                                value_text = value_text.replace('"','')
                                       
                                # Ignore Notes in the Table
                                if str(variable_name_item.text()).lower() == 'notes':
                                    self.label_selected_notes.setText(value_text)
                                else:                                    
                                    # Replace with Global Constants
                                    if variable_name == "ip_address":
                                        value_text = self.dashboard_settings_dictionary['hardware_ip_attack']
                                    elif variable_name == "serial":
                                        if len(self.dashboard_settings_dictionary['hardware_serial_attack']) > 0:
                                            if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                                value_text = self.dashboard_settings_dictionary['hardware_serial_attack']
                                            else:
                                                value_text = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_attack']                               
                                        else:
                                            if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                                value_text = ""
                                            else:
                                                value_text = "False"   
                                                                                                   
                                    # Fill in the "Current Values" Table
                                    value = QtWidgets.QTableWidgetItem(value_text)
                                    self.tableWidget_attack_flow_graph_current_values.setRowCount(self.tableWidget_attack_flow_graph_current_values.rowCount()+1)
                                    self.tableWidget_attack_flow_graph_current_values.setVerticalHeaderItem(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,variable_name_item)   
                                    self.tableWidget_attack_flow_graph_current_values.setItem(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,0,value)   

                                    # Store Variables and Values to a Dictionary
                                    temp_flow_graph_variables[str(variable_name_item.text())] = str(value.text())

                                    # Add a Filepath Button
                                    if 'filepath' in variable_name:
                                        # Add a New Column
                                        self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setStretchLastSection(False)
                                        self.tableWidget_attack_flow_graph_current_values.setColumnCount(2)
                                        self.tableWidget_attack_flow_graph_current_values.setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                                        
                                        # Create the PushButton
                                        new_pushbutton = QtWidgets.QPushButton(self.tableWidget_attack_flow_graph_current_values)
                                        new_pushbutton.setText("...")
                                        new_pushbutton.setFixedSize(34,23)
                                        self.tableWidget_attack_flow_graph_current_values.setCellWidget(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,1,new_pushbutton)
                                        get_row_number = self.tableWidget_attack_flow_graph_current_values.rowCount()-1
                                        get_default_directory = self.defaultAttackFilepathDirectory(str(self.label_selected_flow_graph.text()).rsplit('/')[-1],variable_name)
                                        new_pushbutton.clicked.connect((lambda get_row_number,get_default_directory: lambda: self._slotSelectFilepath(-1, get_row = get_row_number, default_directory = get_default_directory))(get_row_number,get_default_directory))  # Pass constant value, not variable value

                                        # Adjust Table
                                        self.tableWidget_attack_flow_graph_current_values.setColumnWidth(1,35) 
                                        self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch) 
                                    
                # Flow Graph - GUI
                elif ftype == "Flow Graph - GUI":
                    # Read Flow Graph Variables
                    temp_flow_graph_variables = {}
                    parsing = False
                    for line in f:
                        if line.startswith("        # Variables"):
                            parsing = True
                        elif line.startswith("        # Blocks"):
                            parsing = False
                        if parsing:
                            # Strip Extra Text
                            get_line = line.split('=',1)[-1]
                            get_line = get_line.split('#',1)[0]
                            get_line = get_line.lstrip()
                            
                            if get_line != "":       
                                # Get Default Variable Name and Value
                                variable_name = get_line.split(' = ')[0]
                                variable_name_item = QtWidgets.QTableWidgetItem(variable_name)
                                value_text = get_line.split(' = ')[1].rstrip('\n')
                                value_text = value_text.replace('"','')
                                
                                # Ignore Notes in the Table
                                if str(variable_name_item.text()).lower() == 'notes':
                                    self.label_selected_notes.setText(value_text)
                                else:                                       
                                    # Replace with Global Constants
                                    if variable_name == "ip_address":
                                        value_text = self.dashboard_settings_dictionary['hardware_ip_attack']
                                    elif variable_name == "serial":
                                        if len(self.dashboard_settings_dictionary['hardware_serial_attack']) > 0:
                                            if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                                value_text = self.dashboard_settings_dictionary['hardware_serial_attack']
                                            else:
                                                value_text = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_attack']                               
                                        else:
                                            if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                                value_text = ""
                                            else:
                                                value_text = "False"                                        
                                                                                                   
                                    # Fill in the "Current Values" Table
                                    value = QtWidgets.QTableWidgetItem(value_text)
                                    self.tableWidget_attack_flow_graph_current_values.setRowCount(self.tableWidget_attack_flow_graph_current_values.rowCount()+1)
                                    self.tableWidget_attack_flow_graph_current_values.setVerticalHeaderItem(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,variable_name_item)   
                                    self.tableWidget_attack_flow_graph_current_values.setItem(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,0,value)   

                                    # Store Variables and Values to a Dictionary
                                    temp_flow_graph_variables[str(variable_name_item.text())] = str(value.text())

                                    # Add a Filepath Button
                                    if 'filepath' in variable_name:
                                        # Add a New Column
                                        self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setStretchLastSection(False)
                                        self.tableWidget_attack_flow_graph_current_values.setColumnCount(2)
                                        self.tableWidget_attack_flow_graph_current_values.setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                                        
                                        # Create the PushButton
                                        new_pushbutton = QtWidgets.QPushButton(self.tableWidget_attack_flow_graph_current_values)
                                        new_pushbutton.setText("...")
                                        new_pushbutton.setFixedSize(34,23)
                                        self.tableWidget_attack_flow_graph_current_values.setCellWidget(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,1,new_pushbutton)
                                        get_row_number = self.tableWidget_attack_flow_graph_current_values.rowCount()-1
                                        get_default_directory = self.defaultAttackFilepathDirectory(str(self.label_selected_flow_graph.text()).rsplit('/')[-1],variable_name)
                                        new_pushbutton.clicked.connect((lambda get_row_number,get_default_directory: lambda: self._slotSelectFilepath(-1, get_row = get_row_number, default_directory = get_default_directory))(get_row_number,get_default_directory))  # Pass constant value, not variable value

                                        # Adjust Table
                                        self.tableWidget_attack_flow_graph_current_values.setColumnWidth(1,35) 
                                        self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch)                                    
                                    
                    # Disable the Table
                    self.tableWidget_attack_flow_graph_current_values.setEnabled(False)
                                    
                # Python Script
                else:
                    # Get Python2/Python3 Variables
                    if ftype == "Python3 Script":
                        proc=subprocess.Popen("python3 python_importer.py " + get_file.replace('.py',''), shell=True, stdout=subprocess.PIPE, cwd=flow_graph_directory)
                    else:
                        proc=subprocess.Popen("python2 python_importer.py " + get_file.replace('.py',''), shell=True, stdout=subprocess.PIPE, cwd=flow_graph_directory)
                    output=ast.literal_eval(proc.communicate()[0].decode())
                    get_vars = output[0]
                    get_vals = output[1]

                    # get_module = __import__(get_file.replace('.py',''))  # Faster, but only works for the same Python version as Dashboard.py
                    # get_args = get_module.getArguments()
                    # get_vars = get_args[0]
                    # get_vals = get_args[1]
                    
                    temp_flow_graph_variables = {}
                    for n in range(0,len(get_vars)):                                    
                        # Ignore Notes in the Table
                        if str(get_vars[n]).lower() == 'notes':
                            self.label_selected_notes.setText(str(get_vals[n]))
                        else:
                            # Replace with Global Constants
                            if get_vars[n] == "iface":
                                get_vals[n] = self.dashboard_settings_dictionary['hardware_interface_attack']
                                
                            # Fill in the "Current Values" Table
                            variable_name = QtWidgets.QTableWidgetItem(get_vars[n])
                            value = QtWidgets.QTableWidgetItem(str(get_vals[n]))
                            self.tableWidget_attack_flow_graph_current_values.setRowCount(self.tableWidget_attack_flow_graph_current_values.rowCount()+1)
                            self.tableWidget_attack_flow_graph_current_values.setVerticalHeaderItem(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,variable_name)   
                            self.tableWidget_attack_flow_graph_current_values.setItem(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,0,value)   

                            # Store Variables and Values to a Dictionary
                            temp_flow_graph_variables[str(variable_name.text())] = str(value.text())

                            # Add a Filepath Button
                            if 'filepath' in str(variable_name.text()):
                                # Add a New Column
                                if self.tableWidget_attack_flow_graph_current_values.columnCount() == 1:
                                    self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setStretchLastSection(False)
                                    self.tableWidget_attack_flow_graph_current_values.setColumnCount(2)
                                    self.tableWidget_attack_flow_graph_current_values.setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                                
                                # Create the PushButton
                                new_pushbutton = QtWidgets.QPushButton(self.tableWidget_attack_flow_graph_current_values)
                                new_pushbutton.setText("...")
                                if 'iface' in get_vars:
                                    new_pushbutton.setFixedSize(64,23)
                                else:
                                    new_pushbutton.setFixedSize(34,23)
                                self.tableWidget_attack_flow_graph_current_values.setCellWidget(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,1,new_pushbutton)
                                get_row_number = self.tableWidget_attack_flow_graph_current_values.rowCount()-1
                                get_default_directory = self.defaultAttackFilepathDirectory(str(self.label_selected_flow_graph.text()).rsplit('/')[-1],str(variable_name.text()))
                                new_pushbutton.clicked.connect((lambda get_row_number,get_default_directory: lambda: self._slotSelectFilepath(-1, get_row = get_row_number, default_directory = get_default_directory))(get_row_number,get_default_directory))  # Pass constant value, not variable value

                                # Adjust Table
                                if self.tableWidget_attack_flow_graph_current_values.columnWidth(1) > 65:  # check for iface/guess column width
                                    self.tableWidget_attack_flow_graph_current_values.setColumnWidth(1,35) 
                                self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch)                                        
                                
                            # Add a Guess Interface Button
                            if str(variable_name.text()) == 'iface':
                                # Add a New Column
                                if self.tableWidget_attack_flow_graph_current_values.columnCount() == 1:
                                    self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setStretchLastSection(False)
                                    self.tableWidget_attack_flow_graph_current_values.setColumnCount(2)
                                    self.tableWidget_attack_flow_graph_current_values.setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                                
                                # Create the PushButton
                                new_pushbutton = QtWidgets.QPushButton(self.tableWidget_attack_flow_graph_current_values)
                                new_pushbutton.setText("Guess")
                                new_pushbutton.setFixedSize(64,23)
                                self.tableWidget_attack_flow_graph_current_values.setCellWidget(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,1,new_pushbutton)
                                new_pushbutton.clicked.connect(lambda: self._slotGuessInterfaceTableClicked(-1))

                                # Adjust Table
                                self.tableWidget_attack_flow_graph_current_values.setColumnWidth(1,65) 
                                self.tableWidget_attack_flow_graph_current_values.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch)     

                # Close the File
                f.close()  
                
                # Adjust Table
                self.tableWidget_attack_flow_graph_current_values.resizeRowsToContents()
                
                # Copy the Flow Graph Dictionary
                self.attack_flow_graph_variables = temp_flow_graph_variables    
                
                # Enable/Disable the Push Buttons
                self.pushButton_attack_start_stop.setEnabled(True)
                self.pushButton_attack_view_flow_graph.setEnabled(True) 
                self.pushButton_attack_apply_changes.setEnabled(False)
                self.pushButton_attack_restore_defaults.setEnabled(False)
                
                # Update Flow Graph Status Label
                self.label_attack_flow_graph_status.setText("Stopped")
            
            #~ except:
                #~ pass
                #~ self.errorMessage()               
            
    def _slotAttackViewFlowGraph(self):
        """ Opens the selected attack flow graph in GNU Radio Companion
        """    
        # File Type
        get_file_type = str(self.label_attack_single_stage_file_type.text())
        
        # Flow Graph
        if get_file_type == "Flow Graph" or get_file_type == "Flow Graph - GUI": 
            # Get the Flow Graph Name
            loaded_flow_graph = str(self.label_selected_flow_graph.text())
            loaded_flow_graph = loaded_flow_graph.replace(" ","\ ")
            loaded_flow_graph = loaded_flow_graph.rpartition('.')[0] + ".grc"
            
            # Open the Flow Graph in GNU Radio Companion
            if os.path.isfile(loaded_flow_graph.replace('\\','')):
                osCommandString = "gnuradio-companion " + loaded_flow_graph
                os.system(osCommandString+ " &")    
            else:
                self.errorMessage("Missing .grc file.") 
        
        # Python Script
        else:
            # Get the File Name
            loaded_flow_graph = str(self.label_selected_flow_graph.text())
            loaded_flow_graph = loaded_flow_graph.replace(" ","\ ")
            
            # Open the Flow Graph in Gedit
            osCommandString = "gedit " + loaded_flow_graph
            os.system(osCommandString+ " &")             
            
    def _slotAttackStartStopAttack(self):
        """ Starts and stops the selected attack flow graph     
        """
        # Stop Flow Graph
        if self.pushButton_attack_start_stop.text() == "Stop Attack":
            if str(self.label_attack_single_stage_file_type.text()) == "Flow Graph":
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Attack Flow Graph', Parameters = [''])
            elif str(self.label_attack_single_stage_file_type.text()) == "Flow Graph - GUI":
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Attack Flow Graph', Parameters = ['Flow Graph - GUI'])
            else:
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Attack Flow Graph', Parameters = ['Python Script'])
            
            # Toggle the Text
            self.pushButton_attack_start_stop.setText("Start Attack")  
            
            # Disable Apply Button
            self.pushButton_attack_apply_changes.setEnabled(False)
            
            # Enable Attack Switching
            self.comboBox_attack_protocols.setEnabled(True)
            self.comboBox_attack_modulation.setEnabled(True)
            self.comboBox_attack_hardware.setEnabled(True)  
            
            # Update Flow Graph Status Label
            self.label_attack_flow_graph_status.setText("Stopped")      
            
            # Enabled All Values for Editing
            for get_row in range(self.tableWidget_attack_flow_graph_current_values.rowCount()):   
                get_value_item = self.tableWidget_attack_flow_graph_current_values.takeItem(get_row,0)
                get_value_item.setFlags(get_value_item.flags() | QtCore.Qt.ItemIsEditable)
                get_value_item.setFlags(get_value_item.flags() | QtCore.Qt.ItemIsEnabled)
                self.tableWidget_attack_flow_graph_current_values.setItem(get_row,0,get_value_item)

        # Start Flow Graph
        elif self.pushButton_attack_start_stop.text() == "Start Attack":        
                    
            # Send Message(s) to the HIPRFISR for each Variable Name and Value
            variable_names = []
            variable_values = []
            for get_row in range(self.tableWidget_attack_flow_graph_current_values.rowCount()):             
                # Save the Variable Name in the Row to a Dictionary
                get_name = str(self.tableWidget_attack_flow_graph_current_values.verticalHeaderItem(get_row).text())
                variable_names.append(get_name)  
                
                # Disable Values with Names Matching those Listed in "fissure_config.yaml"
                if get_name in self.dashboard_settings_dictionary['disabled_running_flow_graph_variables']:
                    get_value_item = self.tableWidget_attack_flow_graph_current_values.takeItem(get_row,0)
                    get_value_item.setFlags(get_value_item.flags() & ~QtCore.Qt.ItemIsEnabled)
                    self.tableWidget_attack_flow_graph_current_values.setItem(get_row,0,get_value_item)

                # Save the Variable Value in the Row to a Dictionary   
                if get_name == "filepath":
                    if str(self.label_attack_single_stage_file_type.text()) == "Flow Graph" or str(self.label_attack_single_stage_file_type.text()) == "Flow Graph - GUI":
                        variable_values.append('"' + '"' + str(self.tableWidget_attack_flow_graph_current_values.item(get_row,0).text()) + '"' + '"')  # Needs two sets of quotes                    
                    else:
                        variable_values.append('"' + str(self.tableWidget_attack_flow_graph_current_values.item(get_row,0).text()) + '"')  # Needs one set of quotes
                else:
                    variable_values.append(str(self.tableWidget_attack_flow_graph_current_values.item(get_row,0).text()))
            
            # Update Flow Graph Status Label
            self.label_attack_flow_graph_status.setText("Starting...")
            
            # Send "Run Attack Flow Graph" Message to the HIPRFISR
            fname = self.label_selected_flow_graph.text()
            get_file_type = str(self.label_attack_single_stage_file_type.text())
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Run Attack Flow Graph', Parameters = [str(fname), variable_names, variable_values, get_file_type]) 
                
            # Toggle the Text       
            self.pushButton_attack_start_stop.setText("Stop Attack") 
            self.pushButton_attack_start_stop.setEnabled(False)
            
            # Enable Apply Button
            self.pushButton_attack_apply_changes.setEnabled(False) 
            
            # Disable Attack Switching
            self.comboBox_attack_protocols.setEnabled(False)
            self.comboBox_attack_modulation.setEnabled(False)
            self.comboBox_attack_hardware.setEnabled(False)
                
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(3,0).setText('Starting... ' + fname.split('/')[-1])
            
            # Update the Attack History Table       
            attack_name = str(self.label_selected_attack.text())
            protocol = str(self.label_selected_protocol.text())
            self.updateAttackHistory(attack_name, protocol, variable_names, variable_values)        
                
    def updateAttackHistory(self, attack_name, protocol, variable_names, variable_values):
        """ Adds a new row to the "Attack History" table
        """
        self.tableWidget_attack_attack_history.setRowCount(self.tableWidget_attack_attack_history.rowCount()+1)
        
        # Notes 
        notes_item = QtWidgets.QTableWidgetItem("")
        notes_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_attack_attack_history.setItem(self.tableWidget_attack_attack_history.rowCount()-1,0,notes_item)    
            
        # Attack Name
        #~ if self.tabWidget_attack_attack.currentIndex(1):
            #~ fname = (self.tableWidget_attack_multi_stage_attacks.item(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,0).text() + "_" + self.tableWidget_attack_multi_stage_attacks.item(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,1).text() + "_" + self.tableWidget_attack_multi_stage_attacks.item(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,2).text() + ".py").replace(" ","_")
            #~ attack_name_item = QtWidgets.QTableWidgetItem(str(self.label_selected_attack.text()))
        #~ else:    
            #~ attack_name_item = QtWidgets.QTableWidgetItem(str(self.label_selected_attack.text()))
        attack_name_item = QtWidgets.QTableWidgetItem(attack_name)  
        attack_name_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_attack_attack_history.setItem(self.tableWidget_attack_attack_history.rowCount()-1,1,attack_name_item)      
        
        # Protocol 
        #~ protocol_item = QtWidgets.QTableWidgetItem(str(self.label_selected_protocol.text()))
        protocol_item = QtWidgets.QTableWidgetItem(protocol)
        protocol_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_attack_attack_history.setItem(self.tableWidget_attack_attack_history.rowCount()-1,2,protocol_item) 
        
        # Timestamp
        timestamp = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())) 
        timestamp_item = QtWidgets.QTableWidgetItem(str(timestamp))
        timestamp_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_attack_attack_history.setItem(self.tableWidget_attack_attack_history.rowCount()-1,3,timestamp_item)    

        # Values
        all_values_string = ""
        print("SSSSSSSSSSD")
        print(len(variable_names))
        print(len(variable_names[0]))
        print(type(variable_names))
        print(type(variable_names[0]))
        print(variable_names[0])
        print(variable_names[1])
        for k in range(0,len(variable_names)):
            all_values_string = all_values_string + variable_names[k] + ": " + variable_values[k] + "; "
        all_values_string_item = QtWidgets.QTableWidgetItem(str(all_values_string))
        all_values_string_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_attack_attack_history.setItem(self.tableWidget_attack_attack_history.rowCount()-1,4,all_values_string_item)    

        # Resize Table Columns and Rows
        self.tableWidget_attack_attack_history.resizeColumnsToContents()    
        self.tableWidget_attack_attack_history.resizeRowsToContents()
        self.tableWidget_attack_attack_history.horizontalHeader().setStretchLastSection(False)
        self.tableWidget_attack_attack_history.horizontalHeader().setStretchLastSection(True)
        
        # Select First Item After it is Added (for scrolling)
        if self.tableWidget_attack_attack_history.rowCount() == 1:
            self.tableWidget_attack_attack_history.setCurrentItem(timestamp_item)
        
        # Scroll to the Newest Item if Last Item is Selected
        if self.tableWidget_attack_attack_history.currentRow() == self.tableWidget_attack_attack_history.rowCount()-2:
            self.tableWidget_attack_attack_history.setCurrentItem(timestamp_item)         
            
    def populateAttackTreeWidget(self):
        """ This adds the complete list of attacks to the Attack TreeWidget.
        """
        # Populate the Attack TreeWidget
        all_attacks = self.pd_library["Attacks"]["Single-Stage Attacks"] + self.pd_library["Attacks"]["Multi-Stage Attacks"] + self.pd_library["Attacks"]["Fuzzing Attacks"]       
        parent_item_list = []
        prev_level = 0       
        for n in range(0,len(all_attacks)):         
            # Get the Attack
            current_attack = all_attacks[n].split(",")
            
            # Create Item
            new_item = QtWidgets.QTreeWidgetItem()
            new_item.setText(0,current_attack[0])
            new_item.setDisabled(True)
            current_level = int(current_attack[1])

            # Update Parent List
            if len(parent_item_list) <= current_level:
                parent_item_list.append(new_item)
            else:    
                parent_item_list[current_level] = new_item
            
            # Add it to Tree
            if current_level == 0:
                self.treeWidget_attack_attacks.addTopLevelItem(new_item) 
            else:
                if current_level >= prev_level:                        
                    parent_item_list[current_level-1].addChild(new_item)
                elif current_level < prev_level:
                    level_difference = prev_level-current_level
                    parent_item_list[current_level-level_difference].addChild(new_item)
                
            # Update prev_level
            prev_level = current_level    
            
        # Bold Categories
        iterator = QtWidgets.QTreeWidgetItemIterator(self.treeWidget_attack_attacks)
        while iterator.value():
            item = iterator.value()
            if item.text(0) in self.pd_library['Attack Categories']:
                if item.text(0) not in ['New Multi-Stage','Variables']:
                    item.setFont(0,QtGui.QFont("Times", 11, QtGui.QFont.Bold))                    
            iterator+=1      
            
            
    def fill_item(self, item, value):
        """ Generic function for filling a treewidget with a dictionary.
        """
        item.setExpanded(True)
        if type(value) is dict:
            for key, val in sorted(value.items()):
                child = QtWidgets.QTreeWidgetItem()
                child.setText(0, str(key))
                item.addChild(child)
                self.fill_item(child, val)
        elif type(value) is list:
            for val in value:
                child = QtWidgets.QTreeWidgetItem()
                item.addChild(child)
                if type(val) is dict:      
                    child.setText(0, '[dict]')
                    self.fill_item(child, val)
                elif type(val) is list:
                    child.setText(0, '[list]')
                    self.fill_item(child, val)
                else:
                    child.setText(0, str(val))              
                child.setExpanded(True)
        else:
            child = QtWidgets.QTreeWidgetItem()
            child.setText(0, str(value))
            item.addChild(child)
        
    def _slotLibraryBrowseYAML_Changed(self):
        """ This adds the library and other YAML data to the library browse TreeWidget.
        """
        # Get the ComboBox Text
        get_file = str(self.comboBox_library_browse_yaml.currentText())
        
        # Load YAML
        if get_file == "library.yaml":
            filename = os.path.dirname(os.path.realpath(__file__)) + "/YAML/library.yaml"
        elif get_file == "logging.yaml":
            filename = os.path.dirname(os.path.realpath(__file__)) + "/YAML/logging.yaml"
        else:
            filename = os.path.dirname(os.path.realpath(__file__)) + "/YAML/" + get_file
        with open(filename) as yaml_file:
            get_yaml = yaml.load(yaml_file, yaml.FullLoader) 
        
        # Populate the Attack TreeWidget
        self.treeWidget_library_browse.clear()
        self.treeWidget_library_browse.setHeaderLabel(get_file)
        self.fill_item(self.treeWidget_library_browse.invisibleRootItem(), get_yaml)   
        self.treeWidget_library_browse.collapseAll()        
        
    def _slotAttackProtocols(self):
        """ Changes the list of potential attacks based on the protocol information from the library.
        """
        try:               
            # Clear Any Existing Attack Configurations
            self.label_attack_fuzzing_selected_flow_graph.setText("")
            self.textEdit_fuzzing_from_file.setPlainText("")
            for row in reversed(range(0,self.tableWidget_fuzzing_variables.rowCount())):
                self.tableWidget_fuzzing_variables.removeRow(row)
            for row in reversed(range(0,self.tableWidget_attack_fuzzing_data_field.rowCount())):
                self.tableWidget_attack_fuzzing_data_field.removeRow(row)          
            for row in reversed(range(0,self.tableWidget_attack_flow_graph_current_values.rowCount())):
                self.tableWidget_attack_flow_graph_current_values.removeRow(row)        
            self.label_selected_flow_graph.setText("")
            self.label_selected_attack.setText("")
            self.label_selected_modulation.setText("")  
            self.label_selected_notes.setText("")
            
            # Disable Buttons
            self.pushButton_attack_view_flow_graph.setEnabled(False)
                            
            # Get the Protocol
            current_protocol = str(self.comboBox_attack_protocols.currentText())
            self.label_attack_fuzzing_selected_protocol.setText(current_protocol)
            self.label_selected_protocol.setText(current_protocol)
            enabled_categories = [] 
            disabled_categories = []
            
            # Hide/Unhide All Attacks, Disable All Attacks
            iterator = QtWidgets.QTreeWidgetItemIterator(self.treeWidget_attack_attacks)
            while iterator.value():
                item = iterator.value()
                if self.checkBox_attack_show_all.isChecked():
                    item.setHidden(False)                
                else:
                    item.setHidden(True)    
                item.setDisabled(True)
                                
                # Update Iterator                    
                iterator+=1

            # Fuzzing Subcategories ComboBox 
            self.comboBox_attack_fuzzing_subcategory.clear()
            packet_types = getPacketTypes(self.pd_library,current_protocol)
            for packet_type in packet_types:
                self.comboBox_attack_fuzzing_subcategory.addItem(packet_type)

            # Data Field Table    
            current_packet = str(self.comboBox_attack_fuzzing_subcategory.currentText())
            if current_packet != "None":           
                self.tableWidget_attack_fuzzing_data_field.setRowCount(len(getFields(self.pd_library,current_protocol,current_packet)))    
                self.tableWidget_attack_fuzzing_data_field.clear() 
                fields =  getFields(self.pd_library,current_protocol,current_packet)            
                for n in range(0,len(fields)):
                    new_item = QtWidgets.QTableWidgetItem(fields[n])
                    self.tableWidget_attack_fuzzing_data_field.setVerticalHeaderItem(n,new_item)       
            
            # Update the Packet Editor Table Headers  # Update for Different Packet Types
            select_header_item = QtWidgets.QTableWidgetItem("Select")
            self.tableWidget_attack_fuzzing_data_field.setHorizontalHeaderItem(0,select_header_item)
            type_header_item = QtWidgets.QTableWidgetItem("Type")
            self.tableWidget_attack_fuzzing_data_field.setHorizontalHeaderItem(1,type_header_item)
            min_header_item = QtWidgets.QTableWidgetItem("Min.")
            self.tableWidget_attack_fuzzing_data_field.setHorizontalHeaderItem(2,min_header_item)
            max_header_item = QtWidgets.QTableWidgetItem("Max.")
            self.tableWidget_attack_fuzzing_data_field.setHorizontalHeaderItem(3,max_header_item)
            binary_hex_item = QtWidgets.QTableWidgetItem("Bin/Hex")
            self.tableWidget_attack_fuzzing_data_field.setHorizontalHeaderItem(4,binary_hex_item)
            data_header_item = QtWidgets.QTableWidgetItem("Data")
            self.tableWidget_attack_fuzzing_data_field.setHorizontalHeaderItem(5,data_header_item)
            length_header_item = QtWidgets.QTableWidgetItem("Length")
            self.tableWidget_attack_fuzzing_data_field.setHorizontalHeaderItem(6,length_header_item)
            default_header_item = QtWidgets.QTableWidgetItem("Default")
            self.tableWidget_attack_fuzzing_data_field.setHorizontalHeaderItem(7,default_header_item)

            # Binary/Hex ComboBoxes, Select CheckBoxes, Type ComboBoxes
            for n in range(0,self.tableWidget_attack_fuzzing_data_field.rowCount()):
                new_combobox1 = QtWidgets.QComboBox(self)
                self.tableWidget_attack_fuzzing_data_field.setCellWidget(n,4,new_combobox1)
                new_combobox1.addItem("Binary")
                new_combobox1.addItem("Hex")
                new_combobox1.setSizeAdjustPolicy(0)
                new_combobox1.currentIndexChanged.connect(lambda: self._slotPacketBinaryHex(self.tableWidget_attack_fuzzing_data_field))
                new_combobox1.setCurrentIndex(0)
                new_combobox1.setProperty("row", n)     
                
                # CheckBoxes    
                new_checkbox = QtWidgets.QCheckBox("",self)
                new_checkbox.setStyleSheet("margin-left:17%")  # doesn't center, could create a layout and put the radio button in the layout
                self.tableWidget_attack_fuzzing_data_field.setCellWidget(n,0,new_checkbox)
                #new_checkbox.stateChanged.connect(self._slotAttackFuzzingDataSelectCheckboxClicked)
                
                # ComboBoxes
                new_combobox2 = QtWidgets.QComboBox(self)
                self.tableWidget_attack_fuzzing_data_field.setCellWidget(n,1,new_combobox2)
                new_combobox2.addItem("Random")
                new_combobox2.addItem("Sequential")             
                new_combobox2.setSizeAdjustPolicy(0)
                new_combobox2.setCurrentIndex(0)

            # Resize the Table 
            self.tableWidget_attack_fuzzing_data_field.resizeRowsToContents()
            
            # Populate the ComboBox with the Associated Modulation Types
            self.comboBox_attack_modulation.clear()
            modulation_types = getModulations(self.pd_library, current_protocol)
            for n in modulation_types:
                self.comboBox_attack_modulation.addItem(n) 
            current_modulation = str(self.comboBox_attack_modulation.currentText())

            # Enable the Selections
            get_attacks = self.pd_library["Protocols"][current_protocol]["Attacks"]
            get_hardware = str(self.comboBox_attack_hardware.currentText())
            for n in get_attacks:
                if current_modulation in self.pd_library["Protocols"][current_protocol]["Attacks"][n]:
                    if get_hardware in self.pd_library["Protocols"][current_protocol]["Attacks"][n][current_modulation]["Hardware"]:
                        self.treeWidget_attack_attacks.findItems(n,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setDisabled(False)
                        self.treeWidget_attack_attacks.findItems(n,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setHidden(False)  
                        self.enableAttackTreeParents(n)
            
            # Always Enabled
            for n in ['Single-Stage', 'Multi-Stage', 'New Multi-Stage', 'Fuzzing', 'Variables']:            
                self.treeWidget_attack_attacks.findItems(n,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setDisabled(False)
                self.treeWidget_attack_attacks.findItems(n,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setHidden(False)                          

            # Expand the Tree Widget
            self.treeWidget_attack_attacks.expandAll() 
            
            # Select the Top Item
            self.treeWidget_attack_attacks.setCurrentItem(self.treeWidget_attack_attacks.topLevelItem(0))
            
        except:
            #No packet types!
            pass            

    def _slotAttackCurrentValuesEdited(self):
        """ Enables the pushbuttons after the attack "Current Values" table has been edited
        """
        get_file_type = str(self.label_attack_single_stage_file_type.text())
        
        # GUI Variables Cannot be Edited from the Dashboard
        if get_file_type != "Flow Graph - GUI":
            # Don't Show "Apply All" Button When Flow Graph is Stopped and Changes are Made
            if self.pushButton_attack_start_stop.text() == "Stop Attack":
                self.pushButton_attack_apply_changes.setEnabled(True)
            
            self.pushButton_attack_restore_defaults.setEnabled(True)        
        
    def _slotAttackRestoreDefaults(self):
        """ Updates the attack "Current Values" table with the default variables in the flow graph python file
        """
        # Get Filepath and File Type
        fname = self.label_selected_flow_graph.text()
        get_file_type = str(self.label_attack_single_stage_file_type.text())
        
        # Flow Graph Defaults
        if get_file_type == "Flow Graph":
            # If a Valid File
            if fname != "":             
                # Update the Variable Listings in "Flow Graph" tab
                f = open(fname,'r')
                self.tableWidget_attack_flow_graph_current_values.clearContents()
                self.tableWidget_attack_flow_graph_current_values.setRowCount(0)    
                parsing = False
                for line in f:
                    if line.startswith("        # Variables"):
                        parsing = True
                    elif line.startswith("        # Blocks"):
                        parsing = False
                    if parsing:
                        # Strip Extra Text
                        get_line = line.split('=',1)[-1]
                        get_line = get_line.split('#',1)[0]
                        get_line = get_line.lstrip()
                        
                        if get_line != "":              
                            # Fill in the "Current Values" Table
                            variable_name = QtWidgets.QTableWidgetItem(get_line.split(' = ')[0])
                            value_text = get_line.split(' = ')[1].rstrip('\n')
                            value_text = value_text.replace('"','')
                            value = QtWidgets.QTableWidgetItem(value_text)
                            self.tableWidget_attack_flow_graph_current_values.setRowCount(self.tableWidget_attack_flow_graph_current_values.rowCount()+1)
                            self.tableWidget_attack_flow_graph_current_values.setVerticalHeaderItem(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,variable_name)   
                            self.tableWidget_attack_flow_graph_current_values.setItem(self.tableWidget_attack_flow_graph_current_values.rowCount()-1,0,value)   
                            
                # Close the File
                f.close() 
                            
                # Adjust Table
                self.tableWidget_attack_flow_graph_current_values.resizeRowsToContents()  
                
                # Disable the Pushbutton
                self.pushButton_attack_restore_defaults.setEnabled(False)  
            
        # Python Script Defaults                
        elif get_file_type == "Python Script":
            self._slotAttackLoadFromLibraryClicked(None,str(fname.split('/')[-1]),get_file_type)
            
            # Disable the Pushbutton
            self.pushButton_attack_restore_defaults.setEnabled(False)
               
    def _slotAttackApplyChangesClicked(self):
        """ Applies any changes made in the attack "Flow Graph Current Values" table by calling the 'set' functions in the flow graph modules
        """     
        # Send Message(s) to the HIPRFISR for each Variable Name and Value
        for get_row in range(self.tableWidget_attack_flow_graph_current_values.rowCount()):
            
            # Determine the Variable Name and Value in the Row
            variable_name = self.tableWidget_attack_flow_graph_current_values.verticalHeaderItem(get_row).text()
            value = self.tableWidget_attack_flow_graph_current_values.item(get_row,0).text()
                    
            # Check and Send the "Set" Message if Value Changed
            if self.attack_flow_graph_variables[str(variable_name)] != str(value):
                self.attack_flow_graph_variables[str(variable_name)] = str(value)
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Variable', Parameters = ["Attack", str(variable_name), str(value)] )
                
        # Disable the Pushbutton
        self.pushButton_pd_flow_graphs_apply_changes.setEnabled(False)
        
        # Update the "Attack History" Table
        attack_name = str(self.label_selected_attack.text())
        protocol = str(self.label_selected_protocol.text())
        self.updateAttackHistory(attack_name, protocol, list(self.attack_flow_graph_variables.keys()), list(self.attack_flow_graph_variables.values()))
        
    def _slotTSI_AddBandClicked(self):
        """ Copies the data entered into the Wideband edit boxes to the configuration table and edits the plot
        """
        # No More than 10 Bands
        if self.tableWidget_tsi_scan_options.columnCount() < 10:    
            # Add it to the Table       
            # Header
            self.tableWidget_tsi_scan_options.setColumnCount(self.tableWidget_tsi_scan_options.columnCount()+1)
            header_item = QtWidgets.QTableWidgetItem("Band " + str(self.tableWidget_tsi_scan_options.columnCount()))
            header_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_tsi_scan_options.setHorizontalHeaderItem(self.tableWidget_tsi_scan_options.columnCount()-1,header_item)

            # Start
            start_value = self.spinBox_tsi_sdr_start.value()
            #if start_value < 1200:  # Temporary Fix
            #    start_value = 1200
            start_item = QtWidgets.QTableWidgetItem(str(start_value))
            start_item.setTextAlignment(QtCore.Qt.AlignCenter)   
            
            # End
            end_value = self.spinBox_tsi_sdr_end.value()
            #if end_value < 1200:  # Temporary Fix
            #    end_value = 1200
            end_item = QtWidgets.QTableWidgetItem(str(end_value))
            end_item.setTextAlignment(QtCore.Qt.AlignCenter)
            
            # Compare Start and End Frequencies
            if start_value <= end_value:
                self.tableWidget_tsi_scan_options.setItem(0,self.tableWidget_tsi_scan_options.columnCount()-1,start_item) 
                self.tableWidget_tsi_scan_options.setItem(1,self.tableWidget_tsi_scan_options.columnCount()-1,end_item)
            else:
                self.tableWidget_tsi_scan_options.setItem(0,self.tableWidget_tsi_scan_options.columnCount()-1,end_item) 
                self.tableWidget_tsi_scan_options.setItem(1,self.tableWidget_tsi_scan_options.columnCount()-1,start_item)
            
            # Step Size
            step_size_value = self.spinBox_tsi_sdr_step.value()
            step_size_item = QtWidgets.QTableWidgetItem(str(step_size_value))
            step_size_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_tsi_scan_options.setItem(2,self.tableWidget_tsi_scan_options.columnCount()-1,step_size_item)
            
            # Dwell
            dwell_item = QtWidgets.QTableWidgetItem(str(self.doubleSpinBox_tsi_sdr_dwell.value()))
            dwell_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_tsi_scan_options.setItem(3,self.tableWidget_tsi_scan_options.columnCount()-1,dwell_item)
                        
            # Resize Table Columns and Rows
            self.tableWidget_tsi_scan_options.resizeColumnsToContents()
            self.tableWidget_tsi_scan_options.resizeRowsToContents()
            self.tableWidget_tsi_scan_options.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_tsi_scan_options.horizontalHeader().setStretchLastSection(True)
            
            # Set Selection to the Last Column
            self.tableWidget_tsi_scan_options.setCurrentItem(start_item)
            
            # Enable Remove Band Pushbutton
            self.pushButton_tsi_remove_band.setEnabled(True)
            
            # Refresh Bands
            self._slotTSI_RefreshPlotClicked()
            
            # Enable Zoom
            self.pushButton_tsi_zoom_in.setEnabled(True)
            
            # Enable Update TSI Configuration Pushbutton 
            if self.pushButton_tsi_detector_start.text() == "Stop":
                self.pushButton_tsi_update.setEnabled(True)
                self.pushButton_tsi_update.setStyleSheet("border: 1px solid darkGray; border-radius: 6px; background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #ffff00, stop: 1 #d8d800); min-width: 80px;")
                self.label_tsi_update_configuration.setVisible(True)
        
    def _slotTSI_RemoveBandClicked(self):
        """ Removes the selected column from the Wideband SDR Configuration table and edits the plot
        """
        # At Least One Band
        if self.tableWidget_tsi_scan_options.columnCount() > 0:
            # Delete Column from Table
            get_column = self.tableWidget_tsi_scan_options.currentColumn()
            self.tableWidget_tsi_scan_options.removeColumn(get_column)
            
            # Renumber the Bands in the Table
            for col in range(get_column,self.tableWidget_tsi_scan_options.columnCount()):
                header_item = QtWidgets.QTableWidgetItem("Band " + str(col+1))
                header_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.tableWidget_tsi_scan_options.setHorizontalHeaderItem(col,header_item)      
            
            # Resize Table Columns and Rows
            self.tableWidget_tsi_scan_options.resizeColumnsToContents()
            self.tableWidget_tsi_scan_options.resizeRowsToContents()
            self.tableWidget_tsi_scan_options.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_tsi_scan_options.horizontalHeader().setStretchLastSection(True)
                        
            # Refresh the Plot
            self._slotTSI_RefreshPlotClicked()
                    
            # Disable the Pushbuttons
            if self.tableWidget_tsi_scan_options.columnCount() == 0:    
                self.pushButton_tsi_remove_band.setEnabled(False)
                self.pushButton_tsi_update.setEnabled(False)
                self.pushButton_tsi_zoom_in.setEnabled(False)
            
            # Update TSI Configuration Pushbutton Color 
            if self.pushButton_tsi_detector_start.text() == "Stop":
                self.pushButton_tsi_update.setStyleSheet("border: 1px solid darkGray; border-radius: 6px; background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #ffff00, stop: 1 #d8d800); min-width: 80px;")
                self.label_tsi_update_configuration.setVisible(True)    
        
    def _slotTSI_RefreshPlotClicked(self):
        """ Redraws the search band plot based on values from the table.
        """
        # Configure Detector Axes
        self.wideband_zoom_start = 0
        self.wideband_zoom_end = 6000e6
        self._slotTSI_ClearDetectorPlotClicked()
        self.wideband_zoom = False
        self.matplotlib_widget.configureAxes(title='Detector History',xlabel='Frequency (MHz)',ylabel='Time Elapsed (s)', xlabels=['0', '','1000', '', '2000', '', '3000', '', '4000', '', '5000', '', '6000'],ylabels=['0', '5', '10', '15', '20', '25', '30', '35', '40'],ylim=self.wideband_height)
        self.matplotlib_widget.draw()
        
        # Delete the Bands
        for n in reversed(range(0,len(self.tuning_matplotlib_widget.bands))):
            self.tuning_matplotlib_widget.bands[n].remove()    
            del self.tuning_matplotlib_widget.bands[n]           
                
        # Delete the Labels
        for n in reversed(range(0,len(self.tuning_matplotlib_widget.axes.texts))):   
            self.tuning_matplotlib_widget.axes.texts[n].remove()
                      
        # Redraw the Bands in the Table
        for col in range(0,self.tableWidget_tsi_scan_options.columnCount()):

            # Draw Band Rectangle    
            start_value = float(str(self.tableWidget_tsi_scan_options.item(0,col).text()))
            end_value = float(str(self.tableWidget_tsi_scan_options.item(1,col).text()))
            
            h = self.tuning_matplotlib_widget.axes.add_patch(patches.Rectangle((start_value/10, 
                (self.tuning_matplotlib_widget.band_height*(len(self.tuning_matplotlib_widget.bands)+1))),
                    end_value/10-start_value/10,self.tuning_matplotlib_widget.band_height,facecolor="blue",edgecolor="Black"))
            self.tuning_matplotlib_widget.bands.append(h)   
            
            # Draw Text Label
            x_offset = 10
            band_number = str(col+1)
            if band_number == "10":
                x_offset = 15
                            
            if start_value <= end_value:  # Makes it appear next to the left-most value
                x_pos = start_value
            else:
                x_pos = end_value
                
            self.tuning_matplotlib_widget.axes.text(x_pos/10 - x_offset,(self.tuning_matplotlib_widget.band_height*(len(self.tuning_matplotlib_widget.bands)+1)) - 5,band_number,fontsize=10)   
            #self.tuning_matplotlib_widget.axes.text(-10,(self.tuning_matplotlib_widget.band_height*(len(self.tuning_matplotlib_widget.bands)+1)) - 5,band_number,fontsize=10)   
            
        self.tuning_matplotlib_widget.configureAxes(title='Tuning',xlabel='Frequency (MHz)',ylabel='',ylabels='',ylim=400)
        self.tuning_matplotlib_widget.draw()
        
    def _slotTSI_UpdateTSI_Clicked(self):
        """ Signals to HIPRFISR to update the TSI settings
        """
        # Hide Update Configuration Label
        self.label_tsi_update_configuration.setVisible(False)
        self.pushButton_tsi_update.setStyleSheet("")
        
        # Refresh the Plot
        self._slotTSI_RefreshPlotClicked()
        
        # Zoom In
        self._slotTSI_ZoomInClicked()
        
        # Gather the Information
        start_frequency = []
        end_frequency = []
        step_size = []
        dwell_time = []
                    
        for col in range(0,self.tableWidget_tsi_scan_options.columnCount()):            
            start_frequency.append(str(int(int(self.tableWidget_tsi_scan_options.item(0,col).text())*1e6)))
            end_frequency.append(str(int(int(self.tableWidget_tsi_scan_options.item(1,col).text())*1e6)))
            step_size.append(str(int(int(self.tableWidget_tsi_scan_options.item(2,col).text())*1e6)))
            dwell_time.append(str(self.tableWidget_tsi_scan_options.item(3,col).text()))        
                    
        # Send the Message
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Update Configuration', Parameters = [start_frequency, end_frequency, step_size, dwell_time])
        

        
    def _slotPacketProtocols(self):
        """ Changes the Packet editor fields and subcategory combobox whenever the protocol combobox is changed
        """        
        # Get the Protocol                
        current_protocol_key = str(self.comboBox_packet_protocols.currentText())
        if current_protocol_key:  #will be false if no current protocol selected
            try:
                #return sorted list based on sort order subkey
                packet_types = getPacketTypes(self.pd_library, current_protocol_key)
                self.comboBox_packet_subcategory.clear()
                self.comboBox_packet_subcategory.addItems(packet_types)           
                self.comboBox_packet_subcategory.setEnabled(True)   
                self.tableWidget_attack_packet_editor.clearContents()
                
                self._slotPacketRestoreDefaultsClicked()         
                    
            except KeyError:
                #No packet types!
                packet_types = []
                self.comboBox_packet_subcategory.clear()
                
        # Change the Stacked Widget for Scapy Controls
        if "802.11x" in current_protocol_key:
            self.stackedWidget_packet.setCurrentIndex(1)
        else:
            self.stackedWidget_packet.setCurrentIndex(0)

    def _slotPacketRestoreDefaultsClicked(self): 
        """ Restores the values in the Packet Editor to the default values for the selected protocol.
        """        
        # Get the Protocol
        current_protocol = self.comboBox_packet_protocols.currentText()        
        current_protocol_key = str(current_protocol)
        
        # Get the Subcategory
        current_subcategory = self.comboBox_packet_subcategory.currentText()
        current_subcategory_key = str(current_subcategory)
        
        # Clear the Table
        self.tableWidget_attack_packet_editor.clearContents()
            
        # Load the Default Fields and Data        
        fields = getFields(self.pd_library,current_protocol_key,current_subcategory_key)
        default_field_data = getDefaults(self.pd_library,current_protocol_key,current_subcategory_key)
       
        for n in range(0,len(fields)):
            # Length Items
            get_length = self.pd_library["Protocols"][current_protocol_key]['Packet Types'][current_subcategory_key]['Fields'][fields[n]]['Length']    
            length_item = QtWidgets.QTableWidgetItem(str(get_length))
            length_item.setTextAlignment(QtCore.Qt.AlignCenter)
            length_item.setFlags(length_item.flags() & ~QtCore.Qt.ItemIsEditable)
            default_length_item = QtWidgets.QTableWidgetItem(str(get_length))
            default_length_item.setTextAlignment(QtCore.Qt.AlignCenter)
            default_length_item.setFlags(default_length_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_attack_packet_editor.setItem(n,2,length_item)
            self.tableWidget_attack_packet_editor.setItem(n,3,default_length_item)
        
            # Create Table Comboboxes
            new_combobox1 = QtWidgets.QComboBox(self)
            self.tableWidget_attack_packet_editor.setCellWidget(n,0,new_combobox1)  
                               
            # String
            if get_length == 0:
                new_combobox1.addItem("String")
                new_combobox1.setEnabled(False) 
            else:
                new_combobox1.addItem("Binary")
                new_combobox1.addItem("Hex")   
                
                # Binary
                if get_length % 4 != 0:                    
                    new_combobox1.setEnabled(False)
                # Hex
                else:
                    new_combobox1.setCurrentIndex(1)  
              
            # Format
            new_combobox1.setSizeAdjustPolicy(0)
            new_combobox1.setFixedSize(75,24)
            new_combobox1.setCurrentIndex(0)
            new_combobox1.currentIndexChanged.connect(lambda: self._slotPacketBinaryHex(self.tableWidget_attack_packet_editor))
            new_combobox1.setProperty("row", n)               
            self.tableWidget_attack_packet_editor.setItem(n,1,QtWidgets.QTableWidgetItem(str(default_field_data[n])))
                    
        # Calculate the Lengths
        current_length = 0
        default_length = 0
        for n in range(0,self.tableWidget_attack_packet_editor.rowCount()):
            current_length += int(self.tableWidget_attack_packet_editor.item(n,2).text())
            default_length += int(self.tableWidget_attack_packet_editor.item(n,3).text())
        
        # Set the Length Labels
        self.label_packet_current_length_total.setText(str(current_length))
        self.label_packet_default_length_total.setText(str(default_length))            
                
            
    def _slotPacketSubcategory(self):
        """ Changes the Packet Editor fields whenever the subcategory combobox is changed
        """        
        # Get the Subcategory
        current_protocol_key = str(self.comboBox_packet_protocols.currentText())        
        current_subcategory = str(self.comboBox_packet_subcategory.currentText())              
        
        try:
            # Fields          
            self.tableWidget_attack_packet_editor.clearContents()   
            fields = getFields(self.pd_library, current_protocol_key, current_subcategory)
            self.tableWidget_attack_packet_editor.setRowCount(len(fields))            
            self.tableWidget_attack_packet_editor.setVerticalHeaderLabels(fields)
            
            # Lengths
            for n in range(0,len(fields)):
                get_length = self.pd_library["Protocols"][current_protocol_key]['Packet Types'][current_subcategory]['Fields'][fields[n]]['Length']        
                length_item = QtWidgets.QTableWidgetItem(str(get_length))
                length_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.tableWidget_attack_packet_editor.setItem(n,3,length_item)
            
        except KeyError:
            #No Fields Defined!
            #~ print("No Fields Defined!")
            fields = []
            self.tableWidget_attack_packet_editor.setRowCount(1)            
            self.tableWidget_attack_packet_editor.setVerticalHeaderLabels(['Custom'])             
            get_length = 0       
            length_item = QtWidgets.QTableWidgetItem("")
            length_item.setTextAlignment(QtCore.Qt.AlignCenter)
            default_length_item = QtWidgets.QTableWidgetItem(str(get_length))
            default_length_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_attack_packet_editor.setItem(0,2,length_item)
            self.tableWidget_attack_packet_editor.setItem(0,3,default_length_item)
                                            
        # Binary/Hex ComboBoxes
        for n in range(0,self.tableWidget_attack_packet_editor.rowCount()):            
            new_combobox1 = QtWidgets.QComboBox(self)            
            new_combobox1.addItem("Binary")
            new_combobox1.addItem("Hex")
            new_combobox1.setSizeAdjustPolicy(0)
            new_combobox1.setFixedSize(75,24)
            new_combobox1.setCurrentIndex(1)
            new_combobox1.currentIndexChanged.connect(lambda: self._slotPacketBinaryHex(self.tableWidget_attack_packet_editor))
            new_combobox1.setProperty("row", n)
            self.tableWidget_attack_packet_editor.setCellWidget(n,0,new_combobox1)
            
        # Calculate the Lengths
        default_length = 0
        for n in range(0,self.tableWidget_attack_packet_editor.rowCount()):
            default_length += int(self.tableWidget_attack_packet_editor.item(n,3).text())
        
        # Set the Length Labels
        self.label_packet_current_length_total.setText(str(""))
        self.label_packet_default_length_total.setText(str(default_length))   
        
        # Resize the Table
        self.tableWidget_attack_packet_editor.setColumnWidth(0,75) 
        self.tableWidget_attack_packet_editor.setColumnWidth(2,75) 
        self.tableWidget_attack_packet_editor.setColumnWidth(3,75)
        self.tableWidget_attack_packet_editor.horizontalHeader().setSectionResizeMode(1,QtWidgets.QHeaderView.Stretch) 
    
        # Restore Defaults
        if self.comboBox_packet_subcategory.count() > 0:
            self._slotPacketRestoreDefaultsClicked()
        
    def _slotPacketBinaryHex(self, table_widget):
        """ This will convert the data in the Packet Editor to binary and hexadecimal via the combobox.
        """
        row = self.sender().property("row")  # FIX
        if table_widget.horizontalHeaderItem(0).text() == "Select":
            column = 4
        else:
            column = 0
            
        # Binary or Hex
        current_selection = table_widget.cellWidget(row,column).currentText()

        # Contains Data
        if table_widget.item(row,column+1) != None:
            if str(table_widget.item(row,column+1).text()) != "":
                
                # Get the Data        
                get_data = str(table_widget.item(row,column+1).text())
                    
                try:
                    # Hex to Binary
                    if current_selection == "Binary":
                        hex_len = len(get_data)
                        bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                        bin_str_spaces = ' '.join([bin_str[i:i+4] for i in range(0, len(bin_str), 4)])
                        table_widget.item(row,column+1).setText(bin_str_spaces)
                        
                    # Binary to Hex    
                    elif current_selection == "Hex":
                        get_data = get_data.replace(' ', '')
                        hex_str = '%0*X' % ((len(get_data) + 3) // 4, int(get_data, 2))
                        table_widget.item(row,column+1).setText(hex_str)
                        
                    # String/Length 0    
                    elif current_selection == "String":
                        pass
                        #table_widget.item(row,column+1).setText(get_data)
                        
                # Message Data Entered Incorrectly
                except ValueError as inst:
                    self.errorMessage("Message data was entered incorrectly.")    
    
    def _slotPacketAssembleClicked(self):
        """ This will piece together the fields in the Packet Editor to produce a correctly ordered message in the text edit box.
        """
        try:
            # Convert Every Field to Binary, Assemble
            get_bin = ""
            for n in range(0,self.tableWidget_attack_packet_editor.rowCount()):
                # Binary or Hex
                current_selection = self.tableWidget_attack_packet_editor.cellWidget(n,0).currentText()
            
                # Contains Item
                if self.tableWidget_attack_packet_editor.item(n,1) != None:
                    # Not Empty
                    if str(self.tableWidget_attack_packet_editor.item(n,1).text()) != "":
                        # Get the Data      
                        get_data = str(self.tableWidget_attack_packet_editor.item(n,1).text())
                    
                        if current_selection == "Binary":
                            bin_str = get_data.replace(' ', '')
                            
                        # Hex to Binary 
                        elif current_selection == "Hex":
                            hex_len = len(get_data)
                            bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                            
                        get_bin = get_bin + bin_str
                    
            # Convert to Hex, Print
            hex_str = '%0*X' % ((len(get_bin) + 3) // 4, int(get_bin, 2))
            self.textEdit_packet_assembled.setPlainText(hex_str)
                    
        # Message Data Entered Incorrectly
        except ValueError as inst:
            self.errorMessage("Message data was entered incorrectly.")          
    
    def _slotPacketSaveAs(self):
        """ Saves the Assembled Packet to a .bin file (and text file?)
        """
        # Select a Filepath
        directory = os.path.dirname(os.path.realpath(__file__)) + "/Crafted Packets/"  # Default Directory

        # Open the Save Dialog
        dialog = QtWidgets.QFileDialog()
        dialog.setDirectory(directory)
        dialog.setFilter(dialog.filter() | QtCore.QDir.Hidden)
        dialog.setDefaultSuffix('bin')
        dialog.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
        dialog.setNameFilters(['Binary Data Files (*.bin)'])
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            fileName = str(dialog.selectedFiles()[0])
        else:
            fileName = ""   
            
        # Valid File
        if fileName:        
            # Get the File
            file = open(fileName,"wb")
                
            # Get the Data
            get_data = str(self.textEdit_packet_constructed.toPlainText())
                        
            # Check if the Length is Even
            if len(get_data)%2 == 1:
                get_data = get_data + "0"  # Append something to the end to complete the byte
            
            # Format it 
            hb=binascii.a2b_hex(get_data)       
            
            # Write to File
            file.write(hb)
            file.close()
            
    def _slotPacketCalculateCRCsClicked(self):  # Somehow use the library for this? CRC Polynomial? How to get it to work for SimpliciTI?
        """ This will calculate the CRCs for the selected protocol and update the Packet Editor.
        """     
        # Get the Protocol
        current_protocol = self.comboBox_packet_protocols.currentText()
        
        # Get the Subcategory
        current_subcategory = self.comboBox_packet_subcategory.currentText()
        
        #try:
        if True:
            # FM
            if current_protocol == "FM":
                pass

            # DECT
            elif current_protocol == "DECT":            
                # A-Field           
                get_bin = ""
                for n in range(2,7):
                    # Binary or Hex
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(n,0).currentText()
                
                    # Contains Data
                    if self.tableWidget_attack_packet_editor.item(n,1) != None:  # No Item Exists
                        if self.tableWidget_attack_packet_editor.item(n,1).text() != "":  # No Text for the Item Exists

                            # Get the Data      
                            get_data = str(self.tableWidget_attack_packet_editor.item(n,1).text())
                        
                            if current_selection == "Binary":
                                bin_str = get_data.replace(' ', '')
                                
                            # Hex to Binary 
                            elif current_selection == "Hex":
                                hex_len = len(get_data)
                                bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                                
                            get_bin = get_bin + bin_str
                        
                        # Nothing Found in a Field
                        else:
                            get_bin = "MISSING DECT FIELD"
                            self.tableWidget_attack_packet_editor.item(7,1).setText(get_bin)
                            break
                    else:
                        get_bin = "MISSING DECT FIELD"
                        new_item = QtWidgets.QTableWidgetItem("MISSING DECT FIELD")     
                        self.tableWidget_attack_packet_editor.setItem(7,1,new_item)
                        break
                
                if get_bin != "MISSING DECT FIELD":
                    
                    # A-Field CRC Algorithm
                    poly = [1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,1]  # From DECT Standard
                    padding = "0"*(len(poly)-1)
                    mseg = list(get_bin + padding)
                    mseg = [int(i) for i in mseg]
                    
                    q, r = signal2.deconvolve(mseg, poly)
                    r = abs(r)

                    for i in range(0,len(r)):
                        a = r[i]
                        if (a % 2) == 0:
                            r[i] = 0
                        else:
                            r[i] = 1

                    crc = r[len(get_bin):len(r)]
                    crc[-1] = (crc[-1]+1) % 2  # Invert the last bit  (EN 300 175-3 at 6.2.5.2)     

                    # Format it for the Table ("#### #### #### ####")
                    bin_str = str(crc.tolist()).strip('[]')
                    bin_str = ''.join([bin_str[i] for i in range(0, len(bin_str), 5)])  # removes decimals
                    bin_str_spaces = ' '.join([bin_str[i:i+4] for i in range(0, len(bin_str), 4)])  # groups bits into 4
                    
                    # Is Hex or Binary Selected for the CRC?
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(7,0).currentText()
                    if current_selection == "Binary":
                        self.tableWidget_attack_packet_editor.item(7,1).setText(bin_str_spaces)
                                
                    # Binary to Hex 
                    elif current_selection == "Hex":
                        bin_str = bin_str_spaces.replace(' ', '')
                        hex_str = '%0*X' % ((len(bin_str) + 3) // 4, int(bin_str, 2))
                        self.tableWidget_attack_packet_editor.item(7,1).setText(hex_str)
                    
                    # B-Field CRC
                    if current_subcategory == "Basic Packet":
                        # Get B-Field Data
                        # Binary or Hex
                        get_bin = ""
                        current_selection = self.tableWidget_attack_packet_editor.cellWidget(8,0).currentText()
                    
                        # Contains Data
                        if self.tableWidget_attack_packet_editor.item(8,1) != None:  # No Item Exists
                            if self.tableWidget_attack_packet_editor.item(8,1).text() != "":  # No Text for the Item Exists

                                # Get the Data      
                                get_data = str(self.tableWidget_attack_packet_editor.item(8,1).text())
                            
                                if current_selection == "Binary":
                                    bin_str = get_data.replace(' ', '')
                                    
                                # Hex to Binary 
                                elif current_selection == "Hex":
                                    hex_len = len(get_data)
                                    bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                                    
                                get_bin = get_bin + bin_str
                            
                            # Nothing Found in a Field
                            else:
                                get_bin = "MISSING DECT B-FIELD"
                                self.tableWidget_attack_packet_editor.item(9,1).setText(get_bin)
                        else:
                            get_bin = "MISSING DECT B-FIELD"
                            new_item = QtWidgets.QTableWidgetItem("MISSING DECT B-FIELD")       
                            self.tableWidget_attack_packet_editor.setItem(9,1,new_item)
                        
                        # Do the Algorithm
                        b_dec = []
                        for x in range(0,len(get_bin),8):
                             b_dec.append(int(get_bin[x:x+8],2))  # Convert every 8 bits to decimal (40 bytes)
                        
                        rbyte = 0
                        rbit_cnt = 0
                        rbyte_cnt = 0
                        rbits = []
                        for i in range(0,(83-4)+1):
                            bi = i + 48 * (1 + (i >> 4))
                            nb = bi >> 3
                            bw = b_dec[nb]
                            rbyte = int((rbyte << 1) & 255)
                            rbyte |= (bw >> (7 - (bi - (nb << 3)))) & 1
                            
                            rbit_cnt = rbit_cnt + 1
                            if rbit_cnt == 8:
                                rbits.append(int(rbyte&255))
                                rbyte_cnt = rbyte_cnt + 1
                                rbit_cnt = 0
                        
                        # Calculate CRC from rbits                  
                        get_bin = ''
                        for n in range(0,len(rbits)):
                            get_bin = get_bin + bin(rbits[n])[2:].zfill(8)  # Convert decimal to binary string                                      
                        poly = [1,0,0,0,1]  # From DECT Standard (x^4+1)
                        padding = "0"*(len(poly)-1)
                        mseg = list(get_bin + padding)
                        mseg = [int(i) for i in mseg]
                        q, r = signal2.deconvolve(mseg, poly)
                        r = abs(r)
                        for i in range(0,len(r)):
                            a = r[i]
                            if (a % 2) == 0:
                                r[i] = 0
                            else:
                                r[i] = 1
                        crc = r[len(get_bin):len(r)]               
                        
                        # Format it for the Table ("####")
                        bin_str = str(crc.tolist()).strip('[]')
                        bin_str = ''.join([bin_str[i] for i in range(0, len(bin_str), 5)])  # removes decimals
                        bin_str_spaces = ' '.join([bin_str[i:i+4] for i in range(0, len(bin_str), 4)])  # groups bits into 4
                        
                        # Is Hex or Binary Selected for the CRC?
                        current_selection = self.tableWidget_attack_packet_editor.cellWidget(9,0).currentText()
                        if current_selection == "Binary":
                            self.tableWidget_attack_packet_editor.item(9,1).setText(bin_str_spaces)
                                    
                        # Binary to Hex 
                        elif current_selection == "Hex":
                            bin_str = bin_str_spaces.replace(' ', '')
                            hex_str = '%0*X' % ((len(bin_str) + 3) // 4, int(bin_str, 2))
                            self.tableWidget_attack_packet_editor.item(9,1).setText(hex_str)
                                                    
            # Mode S
            elif current_protocol == "Mode S":
                                
                # All Fields before the CRC Field (88 bits)
                get_bin = ""
                last_row = self.tableWidget_attack_packet_editor.rowCount()-1
                
                for n in range(0,last_row):
                    # Binary or Hex
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(n,0).currentText()
                
                    # Contains Data
                    if self.tableWidget_attack_packet_editor.item(n,1) != None:  # No Item Exists
                        if self.tableWidget_attack_packet_editor.item(n,1).text() != "":  # No Text for the Item Exists

                            # Get the Data      
                            get_data = str(self.tableWidget_attack_packet_editor.item(n,1).text())
                        
                            if current_selection == "Binary":
                                bin_str = get_data.replace(' ', '')
                                
                            # Hex to Binary 
                            elif current_selection == "Hex":
                                hex_len = len(get_data)
                                bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                                
                            get_bin = get_bin + bin_str
                        
                        # Nothing Found in a Field
                        else:
                            #if n != 3:  # Ignore Empty MISC Field
                            get_bin = "MISSING MODE S FIELD"
                            self.tableWidget_attack_packet_editor.item(10,1).setText(get_bin)
                            break
                    else:
                        #if n != 3:  # Ignore Empty MISC Field
                        get_bin = "MISSING MODE S FIELD"
                        new_item = QtWidgets.QTableWidgetItem("MISSING MODE S FIELD")       
                        self.tableWidget_attack_packet_editor.setItem(10,1,new_item)
                        break
                
                if get_bin != "MISSING MODE S FIELD":                                   
                    # Binary String to Hex
                    bin_str = get_bin.replace(' ', '')
                    hex_str = '%0*X' % ((len(bin_str) + 3) // 4, int(bin_str, 2))

                    # From ADS-B Out: "adsb_encode.py"
                    # CRC Polynomial (25)
                    GENERATOR = "1111111111111010000001001"
                    df17_str = hex_str +"000000"
                    
                    # Calculate CRC
                    hex_len = len(df17_str)
                    bin_str = bin(int(df17_str, 16))[2:].zfill(int(hex_len*4))
                    msgbin = list(bin_str)
                    encode = True
                    if encode:
                        msgbin[-24:] = ['0'] * 24
 
                    # loop all bits, except last 24 parity bits
                    for i in range(len(msgbin)-24):
                        # if 1, perform modulo 2 multiplication,
                        if msgbin[i] == '1':
                            for j in range(len(GENERATOR)):
                                # modulo 2 multiplication = XOR
                                msgbin[i+j] = str((int(msgbin[i+j]) ^ int(GENERATOR[j])))

                    # last 24 bits
                    crc = ''.join(msgbin[-24:])   
                                        
                    # Format it for the Table ("#### #### #### ####")
                    bin_str = str(crc).strip('[]')
                    bin_str = bin_str.replace(', ','')
                    
                    bin_str_spaces = ' '.join([bin_str[i:i+4] for i in range(0, len(bin_str), 4)])  # groups bits into 4
                    
                    # Is Hex or Binary Selected for the CRC?
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(last_row,0).currentText()
                    if current_selection == "Binary":
                        self.tableWidget_attack_packet_editor.item(last_row,1).setText(bin_str_spaces)
                                
                    # Binary to Hex 
                    elif current_selection == "Hex":
                        bin_str = bin_str_spaces.replace(' ', '')
                        hex_str = '%0*X' % ((len(bin_str) + 3) // 4, int(bin_str, 2))
                        self.tableWidget_attack_packet_editor.item(last_row,1).setText(hex_str) 
                
            # SimpliciTI
            elif current_protocol == "SimpliciTI":          
                # Length Field to End of Payload
                get_bin = ""
                last_row = self.tableWidget_attack_packet_editor.rowCount()-1
                
                for n in range(2,last_row):
                    # Binary or Hex
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(n,0).currentText()
                
                    # Contains Data
                    if self.tableWidget_attack_packet_editor.item(n,1) != None:  # No Item Exists
                        if self.tableWidget_attack_packet_editor.item(n,1).text() != "":  # No Text for the Item Exists

                            # Get the Data      
                            get_data = str(self.tableWidget_attack_packet_editor.item(n,1).text())
                        
                            if current_selection == "Binary":
                                bin_str = get_data.replace(' ', '')
                                
                            # Hex to Binary 
                            elif current_selection == "Hex":
                                hex_len = len(get_data)
                                bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                                
                            get_bin = get_bin + bin_str
                        
                        # Nothing Found in a Field
                        else:
                            if n != 3:  # Ignore Empty MISC Field
                                get_bin = "MISSING SIMPLICITI FIELD"
                                self.tableWidget_attack_packet_editor.item(10,1).setText(get_bin)
                                break
                    else:
                        if n != 3:  # Ignore Empty MISC Field
                            get_bin = "MISSING SIMPLICITI FIELD"
                            new_item = QtWidgets.QTableWidgetItem("MISSING SIMPLICITI FIELD")       
                            self.tableWidget_attack_packet_editor.setItem(10,1,new_item)
                            break
                
                if get_bin != "MISSING SIMPLICITI FIELD":                       
                    # CRC Algorithm
                    crc_registers = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]  # From Design Note 502 Figure 1
                    
                    mseg = [int(i) for i in list(get_bin)]

                    for i in range(0,len(mseg)):
                        bit0 = mseg[i] ^ crc_registers[15]
                        bit2 = bit0 ^ crc_registers[1]
                        bit15 = bit0 ^ crc_registers[14]
                        
                        crc_registers = crc_registers[-1:] + crc_registers[:-1]  # rotate list
                        
                        crc_registers[0] = bit0
                        crc_registers[2] = bit2
                        crc_registers[15] = bit15
                        
                    crc = list(reversed(crc_registers))

                    # Format it for the Table ("#### #### #### ####")
                    bin_str = str(crc).strip('[]')
                    bin_str = bin_str.replace(', ','')
                    
                    bin_str_spaces = ' '.join([bin_str[i:i+4] for i in range(0, len(bin_str), 4)])  # groups bits into 4
                    
                    # Is Hex or Binary Selected for the CRC?
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(last_row,0).currentText()
                    if current_selection == "Binary":
                        self.tableWidget_attack_packet_editor.item(last_row,1).setText(bin_str_spaces)
                                
                    # Binary to Hex 
                    elif current_selection == "Hex":
                        bin_str = bin_str_spaces.replace(' ', '')
                        hex_str = '%0*X' % ((len(bin_str) + 3) // 4, int(bin_str, 2))
                        self.tableWidget_attack_packet_editor.item(last_row,1).setText(hex_str)   
                        
            # RDS
            elif current_protocol == "RDS":

                # Rows to Examine in Packet Crafter    
                if current_subcategory == "Message Version A":               
                    first_row = [0,4,10,12]
                    last_row = [3,9,11,13]                
                elif current_subcategory == "Message Version B":
                    first_row = [0,4,10,14]
                    last_row = [3,9,13,15]
                    
                # CRC A,B,C,D 
                for m in range(0,len(first_row)):
                    get_bin = ""
                    for n in range(first_row[m],last_row[m]):
                        # Binary or Hex
                        current_selection = self.tableWidget_attack_packet_editor.cellWidget(n,0).currentText()
                    
                        # Contains Data
                        if self.tableWidget_attack_packet_editor.item(n,1) != None:  # No Item Exists
                            if self.tableWidget_attack_packet_editor.item(n,1).text() != "":  # No Text for the Item Exists

                                # Get the Data      
                                get_data = str(self.tableWidget_attack_packet_editor.item(n,1).text())
                            
                                if current_selection == "Binary":
                                    bin_str = get_data.replace(' ', '')
                                    
                                # Hex to Binary 
                                elif current_selection == "Hex":
                                    hex_len = len(get_data)
                                    bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                                    
                                get_bin = get_bin + bin_str
                            
                            # Nothing Found in a Field
                            else:
                                get_bin = "MISSING RDS FIELD"
                                self.tableWidget_attack_packet_editor.item(last_row[m],1).setText(get_bin)
                                break
                        else:
                            get_bin = "MISSING RDS FIELD"
                            new_item = QtWidgets.QTableWidgetItem("MISSING RDS FIELD")      
                            self.tableWidget_attack_packet_editor.setItem(last_row[m],1,new_item)
                            break
                    
                    if get_bin != "MISSING RDS FIELD":                                   
                        # Binary String to Hex
                        bin_str = get_bin.replace(' ', '')
                        hex_str = '%0*X' % ((len(bin_str) + 3) // 4, int(bin_str, 2))

                        # CRC Algorithm
                        _GENERATOR_MATRIX = [
                            (0, 0, 0, 1, 1, 1, 0, 1, 1, 1),  # infoword msb
                            (1, 0, 1, 1, 1, 0, 0, 1, 1, 1),  # infoword msb - 1
                            (1, 1, 1, 0, 1, 0, 1, 1, 1, 1),  # infoword msb - 2, ...etc
                            (1, 1, 0, 0, 0, 0, 1, 0, 1, 1),
                            (1, 1, 0, 1, 0, 1, 1, 0, 0, 1),
                            (1, 1, 0, 1, 1, 1, 0, 0, 0, 0),
                            (0, 1, 1, 0, 1, 1, 1, 0, 0, 0),
                            (0, 0, 1, 1, 0, 1, 1, 1, 0, 0),
                            (0, 0, 0, 1, 1, 0, 1, 1, 1, 0),
                            (0, 0, 0, 0, 1, 1, 0, 1, 1, 1),
                            (1, 0, 1, 1, 0, 0, 0, 1, 1, 1),
                            (1, 1, 1, 0, 1, 1, 1, 1, 1, 1),
                            (1, 1, 0, 0, 0, 0, 0, 0, 1, 1),
                            (1, 1, 0, 1, 0, 1, 1, 1, 0, 1),
                            (1, 1, 0, 1, 1, 1, 0, 0, 1, 0),
                            (0, 1, 1, 0, 1, 1, 1, 0, 0, 1)   # infoword lsb
                        ]
                        
                        _OFFSET_WORD = [
                            (0, 0, 1, 1, 1, 1, 1, 1, 0, 0),  # 'A' 
                            (0, 1, 1, 0, 0, 1, 1, 0, 0, 0),  # 'B'
                            (0, 1, 0, 1, 1, 0, 1, 0, 0, 0),  # 'C'
                            (0, 1, 1, 0, 1, 1, 0, 1, 0, 0),  # 'D'
                            (1, 1, 0, 1, 0, 1, 0, 0, 0, 0),  # 'C prime' (used in block 3 if version is type B)
                            #(0, 0, 0, 0, 0, 0, 0, 0, 0, 0)   # 'E'
                        ]
                        
                        mseg = [int(i) for i in list(get_bin)]  # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                        
                        gen_polys = []
                        for index, bit in enumerate(mseg):
                            if bit:
                                gen_polys.append(_GENERATOR_MATRIX[index])
                        
                        # Add Each Generator mod 2 (XOR)
                        crc_registers = [0,0,0,0,0,0,0,0,0,0]
                        for poly in gen_polys:
                            for n in range(0,len(crc_registers)):
                                crc_registers[n] = crc_registers[n] ^ poly[n]

                        # Add CRC and Offset Word
                        for n in range(0,len(crc_registers)):
                            if current_subcategory == "Message Version B" and m == 2:
                                crc_registers[n] = crc_registers[n] ^ _OFFSET_WORD[4][n]  # C'
                            else:
                                crc_registers[n] = crc_registers[n] ^ _OFFSET_WORD[m][n]
                                                    
                        # Format it for the Table ("##########")
                        bin_str = str(crc_registers).strip('[]')
                        bin_str = bin_str.replace(', ','')
                        self.tableWidget_attack_packet_editor.item(last_row[m],1).setText(bin_str)             
                        
            # X10
            elif current_protocol == "X10":
                
                # Invert Address Code and Data Code Fields               
                for n in (0,2):
                    bin_str = ""
                    inv_bin_str = ""
                    # Binary or Hex
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(n,0).currentText()
                
                    # Contains Data
                    if self.tableWidget_attack_packet_editor.item(n,1) != None:  # No Item Exists
                        if self.tableWidget_attack_packet_editor.item(n,1).text() != "":  # No Text for the Item Exists

                            # Get the Data      
                            get_data = str(self.tableWidget_attack_packet_editor.item(n,1).text())
                        
                            if current_selection == "Binary":
                                bin_str = get_data.replace(' ', '')
                                
                            # Hex to Binary 
                            elif current_selection == "Hex":
                                hex_len = len(get_data)
                                bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                                
                            # Address Code
                            if n == 0:
                                if len(bin_str) != 8:
                                    bin_str = "MISSING ADDRESS CODE"
                                    self.tableWidget_attack_packet_editor.item(1,1).setText(bin_str)
                            elif n == 2:  
                                if len(bin_str) != 8:
                                    bin_str = "MISSING DATA CODE"
                                    self.tableWidget_attack_packet_editor.item(3,1).setText(bin_str)                          
                        
                        # Nothing Found in a Field
                        else:
                            if n == 0:
                                bin_str = "MISSING ADDRESS CODE"
                                self.tableWidget_attack_packet_editor.item(1,1).setText(bin_str)
                            elif n == 2:
                                bin_str = "MISSING DATA CODE"
                                self.tableWidget_attack_packet_editor.item(3,1).setText(bin_str)                                
                            break
                    # Nothing Found in a Field
                    else:
                        if n == 0:
                            bin_str = "MISSING ADDRESS CODE"
                            self.tableWidget_attack_packet_editor.item(1,1).setText(bin_str)
                        elif n == 2:
                            bin_str = "MISSING DATA CODE"
                            self.tableWidget_attack_packet_editor.item(3,1).setText(bin_str)   
                        break
                
                    # Calculate Inverse
                    if bin_str != "MISSING ADDRESS CODE" and bin_str != "MISSING DATA CODE":     
                        for m in range(0,8):
                            # Address Code
                            if bin_str[m] == "0":
                                inv_bin_str = inv_bin_str + "1"
                            else:
                                inv_bin_str = inv_bin_str + "0"                     
                                                          
                        # Binary String to Hex
                        inv_bin_str = inv_bin_str.replace(' ', '')
                        inv_hex_str = '%0*X' % ((len(inv_bin_str) + 3) // 4, int(inv_bin_str, 2)) 
                                            
                        # Format it for the Table ("#### #### #### ####")                   
                        inv_bin_str_spaces = ' '.join([inv_bin_str[i:i+4] for i in range(0, len(inv_bin_str), 4)])  # groups bits into 4
                        
                        # Is Hex or Binary Selected for the CRC?
                        inv_current_selection = self.tableWidget_attack_packet_editor.cellWidget(n+1,0).currentText()
                        if inv_current_selection == "Binary":
                            self.tableWidget_attack_packet_editor.item(n+1,1).setText(inv_bin_str_spaces)      
                        else:
                            self.tableWidget_attack_packet_editor.item(n+1,1).setText(inv_hex_str)    
                            
            # TPMS
            elif current_protocol == "TPMS":
                # All Fields before the CRC Field (58 bits)
                get_bin = ""
                last_row = self.tableWidget_attack_packet_editor.rowCount()-1
                
                for n in range(0,last_row):
                    # Binary or Hex
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(n,0).currentText()
                
                    # Contains Data
                    if self.tableWidget_attack_packet_editor.item(n,1) != None:  # No Item Exists
                        if self.tableWidget_attack_packet_editor.item(n,1).text() != "":  # No Text for the Item Exists

                            # Get the Data      
                            get_data = str(self.tableWidget_attack_packet_editor.item(n,1).text())
                        
                            if current_selection == "Binary":
                                bin_str = get_data.replace(' ', '')
                                
                            # Hex to Binary 
                            elif current_selection == "Hex":
                                hex_len = len(get_data)
                                bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                                
                            get_bin = get_bin + bin_str
                        
                        # Nothing Found in a Field
                        else:
                            get_bin = "MISSING TPMS FIELD"
                            self.tableWidget_attack_packet_editor.item(10,1).setText(get_bin)
                            break
                    else:
                        get_bin = "MISSING TPMS FIELD"
                        new_item = QtWidgets.QTableWidgetItem("MISSING TPMS FIELD")       
                        self.tableWidget_attack_packet_editor.setItem(10,1,new_item)
                        break
                
                if get_bin != "MISSING TPMS FIELD":                                   
                    # Binary String to Hex
                    bin_str = get_bin.replace(' ', '')
                    crc_data =  '000000' + bin_str 
                    crc_data_bytes = []
                    for n in range(0,int(len(crc_data)/8)):
                        crc_data_bytes.append(int(crc_data[n*8:n*8+8],2))
                    crc_data_bytes = bytes(crc_data_bytes)            
                    check_fn = crcmod.mkCrcFun(0x100 | 0x13, initCrc=0x0, rev=False)
                    crc = '{0:08b}'.format(check_fn(crc_data_bytes))

                    ####################################################
                    # # From ADS-B Out: "adsb_encode.py"
                    # # CRC Polynomial (25)
                    # GENERATOR = "1111111111111010000001001"
                    # df17_str = hex_str +"000000"
                    
                    # # Calculate CRC
                    # hex_len = len(df17_str)
                    # bin_str = bin(int(df17_str, 16))[2:].zfill(int(hex_len*4))
                    # msgbin = list(bin_str)
                    # encode = True
                    # if encode:
                        # msgbin[-24:] = ['0'] * 24
 
                    # # loop all bits, except last 24 parity bits
                    # for i in range(len(msgbin)-24):
                        # # if 1, perform modulo 2 multiplication,
                        # if msgbin[i] == '1':
                            # for j in range(len(GENERATOR)):
                                # # modulo 2 multiplication = XOR
                                # msgbin[i+j] = str((int(msgbin[i+j]) ^ int(GENERATOR[j])))

                    # # last 24 bits
                    # crc = ''.join(msgbin[-24:])   
                    ####################################################
                                        
                    # Format it for the Table ("#### #### #### ####")
                    bin_str = str(crc).strip('[]')
                    bin_str = bin_str.replace(', ','')
                    
                    bin_str_spaces = ' '.join([bin_str[i:i+4] for i in range(0, len(bin_str), 4)])  # groups bits into 4
                    
                    # Is Hex or Binary Selected for the CRC?
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(last_row,0).currentText()
                    if current_selection == "Binary":
                        self.tableWidget_attack_packet_editor.item(last_row,1).setText(bin_str_spaces)
                                
                    # Binary to Hex 
                    elif current_selection == "Hex":
                        bin_str = bin_str_spaces.replace(' ', '')
                        hex_str = '%0*X' % ((len(bin_str) + 3) // 4, int(bin_str, 2))
                        self.tableWidget_attack_packet_editor.item(last_row,1).setText(hex_str)         
                        
            # Z-Wave
            elif current_protocol == "ZWAVE":
                # All Fields before the CRC Field 
                get_bin = ""
                last_row = self.tableWidget_attack_packet_editor.rowCount()-1
                
                for n in range(0,last_row):
                    # Binary or Hex
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(n,0).currentText()
                
                    # Contains Data
                    if self.tableWidget_attack_packet_editor.item(n,1) != None:  # No Item Exists
                        if self.tableWidget_attack_packet_editor.item(n,1).text() != "":  # No Text for the Item Exists

                            # Get the Data      
                            get_data = str(self.tableWidget_attack_packet_editor.item(n,1).text())
                        
                            if current_selection == "Binary":
                                bin_str = get_data.replace(' ', '')
                                
                            # Hex to Binary 
                            elif current_selection == "Hex":
                                hex_len = len(get_data)
                                bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                                
                            get_bin = get_bin + bin_str
                        
                        # Nothing Found in a Field
                        else:
                            get_bin = "MISSING ZWAVE FIELD"
                            self.tableWidget_attack_packet_editor.item(last_row,1).setText(get_bin)
                            break
                    else:
                        get_bin = "MISSING ZWAVE FIELD"
                        new_item = QtWidgets.QTableWidgetItem("MISSING ZWAVE FIELD")       
                        self.tableWidget_attack_packet_editor.setItem(last_row,1,new_item)
                        break
                
                if get_bin != "MISSING ZWAVE FIELD":     
                    
                    # Binary String to Hex
                    bin_str = get_bin.replace(' ', '')
                    crc_data =  bin_str 
                    crc_data_bytes = ''
                    for n in range(0,int(len(crc_data)/8)):
                        crc_data_bytes = crc_data_bytes + hex(int(crc_data[n*8:n*8+8],2))[2:].zfill(2)
                                        
                    # Calculate the CRC
                    get_seed = "1D0F"
                    get_poly = int("1021",16)
                    
                    # Known Seed
                    acc = get_seed
                    for n in range(0,int(len(crc_data_bytes)/2)):
                        new_byte = crc_data_bytes[2*n:2*n+2]                
                        acc = self.updateCRC(get_poly, acc, new_byte, 16)  # Poly: 0x1021, Seed: 0x1DOF  
                        
                    hex_len = len(acc)
                    bin_str = bin(int(acc, 16))[2:].zfill(int(hex_len*4))
            
                    # Format it for the Table ("#### #### #### ####")                  
                    bin_str_spaces = ' '.join([bin_str[i:i+4] for i in range(0, len(bin_str), 4)])  # groups bits into 4
                    
                    # Is Hex or Binary Selected for the CRC?
                    current_selection = self.tableWidget_attack_packet_editor.cellWidget(last_row,0).currentText()
                    if current_selection == "Binary":
                        self.tableWidget_attack_packet_editor.item(last_row,1).setText(bin_str_spaces)
                                
                    # Binary to Hex 
                    elif current_selection == "Hex":
                        bin_str = bin_str_spaces.replace(' ', '')
                        hex_str = '%0*X' % ((len(bin_str) + 3) // 4, int(bin_str, 2))
                        self.tableWidget_attack_packet_editor.item(last_row,1).setText(hex_str)                                      
                        
        # Message Data Entered Incorrectly
        #except ValueError as inst:
        #    self.errorMessage("Message data was entered incorrectly.")  
            
    def _slotFlowGraphFinished(self, flow_graph_type):
        """ This will be called in response to "Flow Graph Finished" Messages from FGE.
            The purpose is to check the "Start/Stop Flow Graph" pushbuttons to see if the user has already stopped the flow graph.
        """
        # Perform Action
        if flow_graph_type == "PD":         
            if self.pushButton_pd_flow_graphs_start_stop.text() == "Stop":             
                # Toggle the Text
                self.pushButton_pd_flow_graphs_start_stop.setText("Start")  
                
                # Disable Apply Button
                self.pushButton_pd_flow_graphs_apply_changes.setEnabled(False)
                
                # Update Flow Graph Status Labels
                self.label_pd_flow_graphs_status.setText("Stopped")
                self.label_pd_status_flow_graph_status.setText("Stopped")
                
                # Update the Status Dialog
                self.status_dialog.tableWidget_status_results.item(3,0).setText("Not Running")
                
        elif flow_graph_type == "Attack":
            # Single-Stage
            if self.pushButton_attack_start_stop.text() == "Stop Attack":
                # Toggle the Text
                self.pushButton_attack_start_stop.setText("Start Attack")  
                
                # Disable Apply Button
                self.pushButton_attack_apply_changes.setEnabled(False)
                
                # Update Flow Graph Status Label
                self.label_attack_flow_graph_status.setText("Stopped")    
                
                # Enable Attack Switching
                self.comboBox_attack_protocols.setEnabled(True)
                self.comboBox_attack_modulation.setEnabled(True)
                self.comboBox_attack_hardware.setEnabled(True)   
                
                # Enabled All Values for Editing
                for get_row in range(self.tableWidget_attack_flow_graph_current_values.rowCount()):   
                    get_value_item = self.tableWidget_attack_flow_graph_current_values.takeItem(get_row,0)
                    get_value_item.setFlags(get_value_item.flags() | QtCore.Qt.ItemIsEditable)
                    get_value_item.setFlags(get_value_item.flags() | QtCore.Qt.ItemIsEnabled)
                    self.tableWidget_attack_flow_graph_current_values.setItem(get_row,0,get_value_item)             
            
            # Fuzzing   
            if self.pushButton_attack_fuzzing_start.text() == "Stop Attack":   
                # Toggle the Text
                self.pushButton_attack_fuzzing_start.setText("Start Attack")  ######
                
                # Disable Apply Button
                self.pushButton_attack_fuzzing_apply_changes.setEnabled(False) #######
                
                # Update Flow Graph Status Label
                self.label_attack_fuzzing_flow_graph_status.setText("Stopped") ######
                
                # Enabled All Values for Editing
                for get_row in range(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()):   
                    get_value_item = self.tableWidget_attack_fuzzing_flow_graph_current_values.takeItem(get_row,0)
                    get_value_item.setFlags(get_value_item.flags() | QtCore.Qt.ItemIsEditable)
                    get_value_item.setFlags(get_value_item.flags() | QtCore.Qt.ItemIsEnabled)
                    self.tableWidget_attack_fuzzing_flow_graph_current_values.setItem(get_row,0,get_value_item) 
                
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(3,0).setText("Not Running")             
                
    def _slotFlowGraphStarted(self, flow_graph_type):
        """ This will be called in response to "Flow Graph Started" Messages from FGE.
            The purpose is to enabled the stop buttons and change the status messages to indicate the flow graph is running.
        """
        # Perform Action
        if flow_graph_type == "PD":         
            # Update Flow Graph Status Labels
            self.label_pd_flow_graphs_status.setText("Running... ")
            self.pushButton_pd_flow_graphs_start_stop.setEnabled(True)
            self.label_pd_status_flow_graph_status.setText("Running... ")
            
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(2,0).setText('Running Flow Graph... ' + str(self.textEdit_pd_flow_graphs_filepath.toPlainText()).rsplit("/",1)[1])
                
        elif flow_graph_type == "Attack":
            # Single-Stage
            if self.tabWidget_attack_attack.currentIndex() == 0:
                # Update Flow Graph Status Label
                self.label_attack_flow_graph_status.setText("Running...")
                self.pushButton_attack_start_stop.setEnabled(True)
                
            # Fuzzing
            elif self.tabWidget_attack_attack.currentIndex() == 2:
                # Update Flow Graph Status Label
                self.label_attack_fuzzing_flow_graph_status.setText("Running...")
                self.pushButton_attack_fuzzing_start.setEnabled(True)
                
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(3,0).setText('Running Flow Graph...')
            
    def _slotIQ_FlowGraphStarted(self):
        """ This will be called in response to "Flow Graph Started IQ" Messages from FGE.
            The purpose is to check the enable the cancel buttons and change the status messages to indicate the IQ flow graph is running.
        """
        # Update the Pushbutton and Label
        self.pushButton_iq_record.setEnabled(True)
        get_number_of_files = str(self.tableWidget_iq_record.item(0,5).text())
        self.label_iq_status_files.setText("Recording File " + str(self.iq_file_counter) + " of " + get_number_of_files)
                    
        # Update the Status Dialog  
        self.status_dialog.tableWidget_status_results.item(4,0).setText('Running Flow Graph... ')
        
    def _slotIQ_PlaybackFlowGraphStarted(self):
        """ This will be called in response to "Flow Graph Started IQ" Messages from FGE.
            The purpose is to check the enable the cancel buttons and change the status messages to indicate the IQ flow graph is running.
        """
        # Update the Pushbutton and Label
        self.pushButton_iq_playback.setEnabled(True)
        self.label_iq_playback_status.setText("Running...")
                    
        # Update the Status Dialog
        self.status_dialog.tableWidget_status_results.item(4,0).setText('Running Flow Graph... ')    
                                           
    def checkHeartbeats(self):
        """ Checks the HIPRFISR heartbeat times to see if the HIPRFISR is still connected.
        """
        current_time = time.time()
        
        # Failed Heartbeat Check While Previously Connected     
        if float(self.hiprfisr_heartbeat_time) < current_time - (float(self.dashboard_settings_dictionary['failure_multiple']) * float(self.dashboard_settings_dictionary['heartbeat_interval'])) and self.hiprfisr_connected is True:
            self.hiprfisr_connected = False
            self.statusbar_hiprfisr.setText("HIPRFISR: XX")
            
        # Passed Heartbeat Check While Previously Disconnected
        elif float(self.hiprfisr_heartbeat_time) > current_time - (float(self.dashboard_settings_dictionary['failure_multiple']) * float(self.dashboard_settings_dictionary['heartbeat_interval'])) and self.hiprfisr_connected is False:
            self.hiprfisr_connected = True
            self.statusbar_hiprfisr.setText("HIPRFISR: OK")
        
    def _slotAutomationSystemStartClicked(self):
        """ Starts FISSURE in a particular mode.
        """
        # Turn System On
        if self.pushButton_automation_system_start.text() == "Start":          
            self.pushButton_automation_system_start.setText("Stop")
            self.pushButton_automation_system_reset.setEnabled(False)
                                
            # Disable Targeting Group Box
            self.frame_automation_targeting.setEnabled(False)
                                    
            # Start TSI     
            if self.checkBox_automation_auto_start_tsi.isChecked():         
                if self.pushButton_tsi_detector_start.text() == "Start":
                    self._slotTSI_DetectorStartClicked()
                
                # Update the SDR Configuration
                #UPDATE_SDRS()
            
            # Set HIPRFISR Processing of SOIs
            if self.checkBox_automation_auto_select_sois.isChecked() == True:
                self.autoSelectSOI()
                                
            elif self.checkBox_automation_auto_select_sois.isChecked() == False:  # Will have to add or delete things for this
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Process SOIs', Parameters = [False,None,None,None])                              
                
            # Enable the Tabs
            self.tabWidget.setTabEnabled(1,True)
            self.tabWidget.setTabEnabled(2,True)
            if self.checkBox_automation_receive_only.isChecked() == False:
                self.tabWidget.setTabEnabled(3,True)
            self.tabWidget.setTabEnabled(4,True)
            self.tabWidget.setTabEnabled(5,True)
            self.tabWidget.setTabEnabled(6,True)
            self.tabWidget.setTabEnabled(7,True)
            self.tabWidget.setTabEnabled(8,True)
            
            # Automation Mode
            if self.dashboard_settings_dictionary['startup_automation_mode'] == "Discovery":
                print("START OF DISCOVERY MODE")
                        
                # Send SOI Selection Mode to HIPRFISR
                self.dashboard_settings_dictionary['SOI_trigger_mode'] = "2"
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'SOI Selection Mode', Parameters = int(self.dashboard_settings_dictionary['SOI_trigger_mode']))    
                        
            # Target Mode
            elif self.dashboard_settings_dictionary['startup_automation_mode'] == "Target":
                print("START OF TARGET MODE")
                                
                # Send SOI Selection Mode to HIPRFISR
                self.dashboard_settings_dictionary['SOI_trigger_mode'] = "2"
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'SOI Selection Mode', Parameters = int(self.dashboard_settings_dictionary['SOI_trigger_mode']))    
                
            # Manual Mode
            elif self.dashboard_settings_dictionary['startup_automation_mode'] == "Manual":
                print("START OF MANUAL MODE")
                
                # Send SOI Selection Mode to HIPRFISR
                self.dashboard_settings_dictionary['SOI_trigger_mode'] = "0"
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'SOI Selection Mode', Parameters = int(self.dashboard_settings_dictionary['SOI_trigger_mode']))    
                    
            # Custom Mode
            elif self.dashboard_settings_dictionary['startup_automation_mode'] == "Custom": 
                print("START OF CUSTOM MODE")
                
                # Send SOI Selection Mode to HIPRFISR
                if self.checkBox_automation_auto_select_sois.isChecked():
                    self.dashboard_settings_dictionary['SOI_trigger_mode'] = "2"
                    self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'SOI Selection Mode', Parameters = int(self.dashboard_settings_dictionary['SOI_trigger_mode']))    
                else:
                    self.dashboard_settings_dictionary['SOI_trigger_mode'] = "0"
                    self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'SOI Selection Mode', Parameters = int(self.dashboard_settings_dictionary['SOI_trigger_mode']))            
                    
            # Turn on Protocol Discovery
            if self.checkBox_automation_auto_start_pd.isChecked():
                if self.pushButton_pd_status_start.text() == "Start":
                    self._slotPD_StatusStartClicked()
        
        # Turn System Off       
        else:
            self.pushButton_automation_system_start.setText("Start")
            self.pushButton_automation_system_reset.setEnabled(True)
            
            # Stop Scanning
            if self.pushButton_tsi_detector_start.text() == "Stop":
                self._slotTSI_DetectorStartClicked()
            
            # Stop HIPRFISR Processing of SOIs
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Process SOIs', Parameters = [False,None,None,None])  
            
            # Disable the Protocol Discovery 
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop PD')
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Auto Start PD', Parameters = False)      
            self.status_dialog.tableWidget_status_results.item(2,0).setText("Not Running")
            self.label_pd_status_pd.setText("Not Running")
            if self.pushButton_pd_status_start.text() == "Stop":
                self._slotPD_StatusStartClicked()
            
            # Turn Off Any Running Flow Graphs
            if self.pushButton_pd_flow_graphs_start_stop.text() == "Stop":
                self._slotPD_DemodulationStartStopClicked()
            if self.pushButton_attack_start_stop.text() == "Stop Attack":
                self._slotAttackStartStopAttack()     
            if self.pushButton_attack_fuzzing_start.text() == "Stop Attack":
                self._slotAttackFuzzingStartClicked()     
            if self.pushButton_attack_multi_stage_start.text() == "Stop":
                self._slotAttackMultiStageStartClicked()          
                
            # Turn Off IQ Recording     
            if self.pushButton_iq_record.text() == "Cancel":
                self._slotIQ_RecordClicked()
                        
            # Enable Targeting Group Box
            self.frame_automation_targeting.setEnabled(True)
                                    
            # Disable the Tabs
            self.tabWidget.setTabEnabled(1,False)
            self.tabWidget.setTabEnabled(2,False)
            self.tabWidget.setTabEnabled(3,False)
            self.tabWidget.setTabEnabled(4,False)
            self.tabWidget.setTabEnabled(5,False)
            self.tabWidget.setTabEnabled(6,False)
            self.tabWidget.setTabEnabled(7,False)
            self.tabWidget.setTabEnabled(8,False)

    def _slotAutomationLockSearchBandClicked(self):
        """ Enabling this checkbox will allow only one search band to be activated while the system is running.
        """
        # Checked
        if self.checkBox_automation_lock_search_band.isChecked() == True:
            self.tableWidget_automation_scan_options.setVisible(True)
            
            # Disable TSI Tab Controls
            self.pushButton_tsi_add_band.setEnabled(False)            
            self.tableWidget_tsi_scan_options.setEnabled(False)
            self.spinBox_tsi_sdr_start.setEnabled(False)
            self.spinBox_tsi_sdr_end.setEnabled(False)
            self.spinBox_tsi_sdr_step.setEnabled(False)
            self.doubleSpinBox_tsi_sdr_dwell.setEnabled(False)
            self.listWidget_tsi_scan_presets.setEnabled(False)
            self.pushButton_tsi_save_preset.setEnabled(False)
            self.pushButton_tsi_delete_preset.setEnabled(False)                          
            self.tuning_matplotlib_widget.setEnabled(False)

            for txt in self.tuning_matplotlib_widget.axes.texts:
                if txt.get_position() == (1,500):
                    txt.remove()
            self.tuning_matplotlib_widget.axes.text(1,500,"LOCKED",fontsize=12,bbox=dict(facecolor='red', alpha=0.5))
            self.tuning_matplotlib_widget.draw()
            
            # Delete Any Existing Bands
            for x in range(1,10):
                self._slotTSI_RemoveBandClicked()
            
            # Add Band from Automation Tab 
            self.spinBox_tsi_sdr_start.setValue(int(self.tableWidget_automation_scan_options.item(0,0).text()))
            self.spinBox_tsi_sdr_end.setValue(int(self.tableWidget_automation_scan_options.item(0,1).text()))
            self.spinBox_tsi_sdr_step.setValue(int(self.tableWidget_automation_scan_options.item(0,2).text()))  
            self.doubleSpinBox_tsi_sdr_dwell.setValue(int(self.tableWidget_automation_scan_options.item(0,3).text()))  
            self._slotTSI_AddBandClicked()
            self.pushButton_tsi_remove_band.setEnabled(False)
            
        # Unchecked
        elif self.checkBox_automation_lock_search_band.isChecked() == False:
            self.tableWidget_automation_scan_options.setVisible(False)
            
            # Enable TSI Tab Controls
            self.pushButton_tsi_add_band.setEnabled(True)            
            self.tableWidget_tsi_scan_options.setEnabled(True)
            self.spinBox_tsi_sdr_start.setEnabled(True)
            self.spinBox_tsi_sdr_end.setEnabled(True)
            self.spinBox_tsi_sdr_step.setEnabled(True)
            self.doubleSpinBox_tsi_sdr_dwell.setEnabled(True)
            self.listWidget_tsi_scan_presets.setEnabled(True)
            self.pushButton_tsi_save_preset.setEnabled(True)
            self.pushButton_tsi_delete_preset.setEnabled(True)                          
            self.tuning_matplotlib_widget.setEnabled(True)
            
            for txt in self.tuning_matplotlib_widget.axes.texts:
                if txt.get_position() == (1,500):
                    txt.remove()
            self.tuning_matplotlib_widget.draw()
            
    def _slotAutomationSOI_PriorityAddLevelClicked(self):
        """ Adds a new row to the "SOI Priority" table.
        """
        # Current Number of Rows
        get_rows = self.tableWidget_automation_soi_list_priority.rowCount()
        
        # Maximum of Three Rows
        if get_rows < 3:
            
            # Add the Row   
            self.tableWidget_automation_soi_list_priority.setRowCount(get_rows+1)
            
            # Create the ComboBoxes and Empty Item
            new_combobox = QtWidgets.QComboBox(self)
            self.tableWidget_automation_soi_list_priority.setCellWidget(get_rows,0,new_combobox)
            new_combobox2 = QtWidgets.QComboBox(self)
            self.tableWidget_automation_soi_list_priority.setCellWidget(get_rows,1,new_combobox2)
            empty_item1 = QtWidgets.QTableWidgetItem("")
            self.tableWidget_automation_soi_list_priority.setItem(get_rows,2,empty_item1)
            
            # Row 1 Exists
            if get_rows == 1:
                # Show the Label
                self.label_soi_priority_row2.setVisible(True)
                
                # Text for New Row
                if self.tableWidget_automation_soi_list_priority.cellWidget(0,0).currentText() == "Power":
                    new_combobox.addItem("Frequency")
                    new_combobox.addItem("Modulation")
                    new_combobox2.addItem("Highest")
                    new_combobox2.addItem("Lowest")
                    new_combobox2.addItem("Nearest to")
                    new_combobox2.addItem("Greater than")
                    new_combobox2.addItem("Less than")
                    
                elif self.tableWidget_automation_soi_list_priority.cellWidget(0,0).currentText() == "Frequency":
                    new_combobox.addItem("Power")
                    new_combobox.addItem("Modulation")
                    new_combobox2.addItem("Highest")
                    new_combobox2.addItem("Lowest")
                    new_combobox2.addItem("Nearest to")
                    new_combobox2.addItem("Greater than")
                    new_combobox2.addItem("Less than")
                elif self.tableWidget_automation_soi_list_priority.cellWidget(0,0).currentText() == "Modulation":
                    new_combobox.addItem("Power")
                    new_combobox.addItem("Frequency")
                    new_combobox2.addItem("Highest")
                    new_combobox2.addItem("Lowest")
                    new_combobox2.addItem("Nearest to")
                    new_combobox2.addItem("Greater than")
                    new_combobox2.addItem("Less than")
                        
            # Row 2 Exists              
            elif get_rows == 2:
                # Show the Label
                self.label_soi_priority_row3.setVisible(True)   
                
                # Disable the Add Level Button
                self.pushButton_automation_soi_priority_add_level.setEnabled(False)
                
                # Enable the Remove Button
                self.pushButton_automation_soi_priority_remove_level.setEnabled(True)
            
                # Text for New Row
                if self.tableWidget_automation_soi_list_priority.cellWidget(0,0).currentText() != "Power" and self.tableWidget_automation_soi_list_priority.cellWidget(1,0).currentText() != "Power":
                    new_combobox.addItem("Power")
                    new_combobox2.addItem("Highest")
                    new_combobox2.addItem("Lowest")
                    new_combobox2.addItem("Nearest to")
                    new_combobox2.addItem("Greater than")
                    new_combobox2.addItem("Less than")
                elif self.tableWidget_automation_soi_list_priority.cellWidget(0,0).currentText() != "Frequency" and self.tableWidget_automation_soi_list_priority.cellWidget(1,0).currentText() != "Frequency":
                    new_combobox.addItem("Frequency")
                    new_combobox2.addItem("Highest")
                    new_combobox2.addItem("Lowest")
                    new_combobox2.addItem("Nearest to")
                    new_combobox2.addItem("Greater than")
                    new_combobox2.addItem("Less than")
                elif self.tableWidget_automation_soi_list_priority.cellWidget(0,0).currentText() != "Modulation" and self.tableWidget_automation_soi_list_priority.cellWidget(1,0).currentText() != "Modulation":
                    new_combobox.addItem("Modulation")
                    new_combobox2.addItem("Containing")
                                        
            # Adjust the Table
            self.tableWidget_automation_soi_list_priority.cellWidget(get_rows-1,0).setEnabled(False)
            new_combobox.setSizeAdjustPolicy(0)
            new_combobox.currentIndexChanged.connect(self._slotSOI_PriorityCategoryChanged)
            self.tableWidget_automation_soi_list_priority.resizeRowsToContents()
        
        
    def _slotAutomationSOI_PriorityRemoveLevelClicked(self):
        """ Removes a row from the "SOI Priority" table.
        """     
        # Current Number of Rows
        get_rows = self.tableWidget_automation_soi_list_priority.rowCount()

        # Minimum of One Row
        if get_rows > 1:
            # Hide the Labels, Enable/Disable the Buttons
            if get_rows == 2:
                self.label_soi_priority_row2.setVisible(False)
                self.pushButton_automation_soi_priority_remove_level.setEnabled(False)
            elif get_rows == 3:
                self.label_soi_priority_row3.setVisible(False)   
                self.pushButton_automation_soi_priority_add_level.setEnabled(True)           
                
            # Remove the Row    
            self.tableWidget_automation_soi_list_priority.setRowCount(get_rows-1)  
            
            # Adjust the Table
            self.tableWidget_automation_soi_list_priority.cellWidget(get_rows-2,0).setEnabled(True)
            self.tableWidget_automation_soi_list_priority.resizeRowsToContents()
            
            
    def _slotSOI_PriorityCategoryChanged(self):
        """ Changes the filter combobox options when the the category combobox is changed.
        """ 
        # Change the Combobox
        last_row = self.tableWidget_automation_soi_list_priority.rowCount()-1
        new_combobox = QtWidgets.QComboBox(self)
        self.tableWidget_automation_soi_list_priority.setCellWidget(last_row,1,new_combobox)
            
        if self.tableWidget_automation_soi_list_priority.cellWidget(last_row,0).currentText() == "Power":
            new_combobox.addItem("Highest")
            new_combobox.addItem("Lowest")
            new_combobox.addItem("Nearest to")
            new_combobox.addItem("Greater than")
            new_combobox.addItem("Less than")
        elif self.tableWidget_automation_soi_list_priority.cellWidget(last_row,0).currentText() == "Frequency":
            new_combobox.addItem("Highest")
            new_combobox.addItem("Lowest")
            new_combobox.addItem("Nearest to")
            new_combobox.addItem("Greater than")
            new_combobox.addItem("Less than")
        elif self.tableWidget_automation_soi_list_priority.cellWidget(last_row,0).currentText() == "Modulation":
            new_combobox.addItem("Containing")
                                    
    def _slotAutomationAutoSelectPD_FlowGraphsClicked(self):
        """ This is called when the "Auto-Load PD Flow Graphs" checkbox is clicked.
        """         
        # Checked
        if self.checkBox_automation_auto_select_pd_flow_graphs.isChecked() == True:
            self.label_pd_status_auto_select_pd_flow_graphs.setText("Yes")
            
        # Unchecked
        elif self.checkBox_automation_auto_select_pd_flow_graphs.isChecked() == False:
            self.label_pd_status_auto_select_pd_flow_graphs.setText("No")
                
    def _slotAutomationAutoStartPD_Clicked(self):
        """ This is called when the "Auto-Start PD" checkbox is clicked.
        """
        # Checked
        if self.checkBox_automation_auto_start_pd.isChecked() == True:
            self.label_pd_status_auto_start_pd.setText("Yes")
            #~ self.pushButton_pd_status_start.setVisible(False)    
            
            # System is On
            if self.pushButton_automation_system_start.text() == "Stop":
                # Start PD if Flow Graph is Already Loaded and PD is not Running
                if (self.label_pd_status_flow_graph_status.text() != "") and (self.pushButton_pd_status_start.text() == "Start"):
                    self._slotPD_StatusStartClicked()
            
        # Unchecked 
        elif self.checkBox_automation_auto_start_pd.isChecked() == False:
            self.label_pd_status_auto_start_pd.setText("No")  
            #~ self.pushButton_pd_status_start.setVisible(True)
                
    def _slotPD_StatusStartClicked(self):
        """ Protocol "Start" button was clicked. Begins protocol discovery.
        """
        # Turn Protocol Discovery On
        if self.pushButton_pd_status_start.text() == "Start":            
            self.pushButton_pd_status_start.setText("Stop")
            
            # Send Message to Turn on PD 
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Start PD')   
            
            # Update the Labels     
            self.status_dialog.tableWidget_status_results.item(2,0).setText("Running")
            self.label_pd_status_pd.setText("Running")
            
            # Enable the Tabs
            self.tabWidget_protocol.setTabEnabled(1,True)
            self.tabWidget_protocol.setTabEnabled(2,True)
            #self.tabWidget_protocol.setTabEnabled(3,True)
            #self.tabWidget_protocol.setTabEnabled(4,True)
            #self.tabWidget_protocol.setTabEnabled(5,True)
            #self.tabWidget_protocol.setTabEnabled(6,True)
            #self.tabWidget_protocol.setTabEnabled(7,True)
            
            # Enable the Status Labels/Controls
            self.frame_pd_status_current_soi.setEnabled(True)        
            self.frame_pd_status_bitstream_buffer.setEnabled(True) 
            self.frame_pd_status_zmq_pub.setEnabled(True) 
            self.pushButton_pd_status_soi_new.setEnabled(True)
            
            # Insert Message into the Status Window
            get_text = time.strftime('%H:%M:%S', time.localtime()) + ": Starting Protocol Discovery...\n"
            self._slotPD_AddStatus(get_text)
        
        # Turn Protocol Discovery Off       
        else:
            self.pushButton_pd_status_start.setText("Start")
            
            # Send Message to Turn off PD 
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop PD')
            
            # Disable the Protocol Discovery Trigger
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Auto Start PD', Parameters = False)
            
            # Update the Labels         
            self.status_dialog.tableWidget_status_results.item(2,0).setText("Not Running")
            self.label_pd_status_pd.setText("Not Running")
            
            # Disable the Tabs
            self.tabWidget_protocol.setTabEnabled(1,False)
            self.tabWidget_protocol.setTabEnabled(2,False)
            #self.tabWidget_protocol.setTabEnabled(3,False)
            #self.tabWidget_protocol.setTabEnabled(4,False)
            #self.tabWidget_protocol.setTabEnabled(5,False)
            #self.tabWidget_protocol.setTabEnabled(6,False)
            #self.tabWidget_protocol.setTabEnabled(7,False)
            
            # Disable the Status Labels/Controls
            self.frame_pd_status_current_soi.setEnabled(False)  
            self.frame_pd_status_bitstream_buffer.setEnabled(False) 
            self.frame_pd_status_zmq_pub.setEnabled(False) 
                        
            # Insert Message into the Status Window
            get_text = time.strftime('%H:%M:%S', time.localtime()) + ": Stopping Protocol Discovery...\n"
            self._slotPD_AddStatus(get_text)
            
            # TEST ONLY: Stopping Flow Graph at PD Stop (will be removed)
            if self.pushButton_pd_flow_graphs_start_stop.text() == "Stop":
                self._slotPD_DemodulationStartStopClicked()  # TEST ONLY: PD program will handle stopping flow graphs 
                
    def _slotPD_StatusBlacklistSOI_Clicked(self):
        """ This will stop protocol discovery of the current SOI. If the auto-select SOIs is checked it will procede to the next unique SOI.
            Otherwise the user can manually select a new SOI.
        """
        #~ # Stop Protocol Discovery
        #~ if self.pushButton_pd_status_start.text() == "Stop":         
            #~ self._slotPD_StatusStartClicked()
            
        # Stop Any Running Flow Graphs
        if self.pushButton_pd_flow_graphs_start_stop.text() == "Stop":
            self._slotPD_DemodulationStartStopClicked()
            
        # Unload the Flow Graph
        self.unloadFlowGraph()
                    
        # # Select the Current SOI in the AMC SOI Table
        # for x in range(0,self.tableWidget_tsi_narrowband.rowCount()):
            # if self.tableWidget_tsi_narrowband.cellWidget(x,0).isChecked():
                # self.tableWidget_tsi_narrowband.setCurrentCell(x,0)
        
        # # Blacklist Current SOI
        # self._slotTSI_SOI_BlacklistClicked()               
                
        # Disable the Pushbuttons
        self.pushButton_pd_status_blacklist_soi.setEnabled(False)
        self.pushButton_pd_status_untarget.setEnabled(False)
        self.pushButton_pd_status_search_library.setEnabled(False)
            
    def _slotTSI_SOI_BlacklistClicked(self):
        """ Adds the Currently Selected SOI from the AMC SOI table to a blacklist. Any signals in the blacklist will not be added
            to the AMC SOI table in the future.
        """
        if self.tableWidget_tsi_narrowband.rowCount() > 0:
            
            # Get the Selected SOI
            row = self.tableWidget_tsi_narrowband.currentRow()
            
            # Valid Selection
            if row >= 0:
                target_SOI = self.tableWidget_tsi_narrowband.item(row,1).text() + "," + self.tableWidget_tsi_narrowband.item(row,3).text()  # Frequency, Modulation
                
                # Remove All Matching SOIs from the Table, Check if Radiobutton is Selected
                reprocess_SOIs = False
                for x in reversed(range(0,self.tableWidget_tsi_narrowband.rowCount())):
                    if target_SOI == self.tableWidget_tsi_narrowband.item(x,1).text() + "," + self.tableWidget_tsi_narrowband.item(x,3).text(): 
                        # Check if it is Targeted
                        if self.tableWidget_tsi_narrowband.cellWidget(x,0).isChecked() == True:
                            reprocess_SOIs = True
                        # Remove the Row    
                        self.tableWidget_tsi_narrowband.removeRow(x)
                        
                # Add it to the Blacklist
                self.soi_blacklist.append(str(target_SOI))
                
                # Inform the HIPRFISR
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Ignore SOIs', Parameters = [self.soi_blacklist])
            
                # Re-Process SOIs (if applicable)
                if (reprocess_SOIs == True) and (self.checkBox_automation_auto_select_sois.isChecked() == True):       
                    self.autoSelectSOI()
                    
                # Add it to the Blacklist List Widget
                self.listWidget_tsi_soi_blacklist.addItem(str(target_SOI))
                self.pushButton_tsi_soi_blacklist_remove.setEnabled(True)
                
                # Clear PD Status Current SOI Editbox
                self.textEdit_pd_status_target.clear()
                                
    def _slotTSI_SOI_BlacklistRemoveClicked(self):
        """ Removes the currently selected SOI from the Blacklist and makes it qualified for future processing.
        """
        # Get the Item
        if self.listWidget_tsi_soi_blacklist.count() > 0:
            get_row = self.listWidget_tsi_soi_blacklist.currentRow()
            get_item = self.listWidget_tsi_soi_blacklist.item(get_row)
                        
            # Delete from SOI Blacklist Variable
            for x in reversed(range(0,len(self.soi_blacklist))):
                if self.soi_blacklist[x] == get_item.text():
                    del self.soi_blacklist[x]
                    
            # Send Updated Blacklist to HIPRFISR
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Ignore SOIs', Parameters = [self.soi_blacklist])
                        
            # Delete from List Widget
            self.listWidget_tsi_soi_blacklist.takeItem(get_row)
            
            # Disable the "Remove" Pushbutton 
            if self.listWidget_tsi_soi_blacklist.count() == 0:
                self.pushButton_tsi_soi_blacklist_remove.setEnabled(False)
                
    def _slotTSI_SOI_UntargetClicked(self):
        """ This will untarget the currently targeted SOI and allow the reselection process to continue. This will autoselect an SOI if "Auto-Select SOIs" is checked.
        """        
        # Untarget
        if self.pushButton_tsi_untarget.text() == "Untarget":     
            # Clear SOI
            self.target_soi = []
                   
            # Uncheck the Radiobutton
            for x in range(0,self.tableWidget_tsi_narrowband.rowCount()):
                if self.tableWidget_tsi_narrowband.cellWidget(x,0).isChecked():
                    self.tableWidget_tsi_narrowband.cellWidget(x,0).setAutoExclusive(False)  # Need this to uncheck radiobutton
                    self.tableWidget_tsi_narrowband.cellWidget(x,0).setChecked(False)
                    self.tableWidget_tsi_narrowband.cellWidget(x,0).setAutoExclusive(True)
                    
            # Clear the "Targeted Signal Details" Edit Box
            self.textEdit_pd_status_target.clear()
            
            # Disable the Pushbuttons
            self.pushButton_pd_status_untarget.setEnabled(False)
            #self.pushButton_pd_status_blacklist_soi.setEnabled(False)
            self.pushButton_pd_status_search_library.setEnabled(False)
                        
            # Auto-Select SOIs is Checked
            if self.checkBox_automation_auto_select_sois.isChecked():          
                #Search for SOI Again
                self.autoSelectSOI()
                
            # Auto-Select PD Flow Graphs is Checked 
            if self.checkBox_automation_auto_select_pd_flow_graphs.isChecked():
                # Stop Protocol Discovery
                if self.pushButton_pd_status_start.text() == "Stop":         
                    self._slotPD_StatusStartClicked()
                
        # Auto-Select
        elif self.pushButton_tsi_untarget.text() == "Auto-Select":  
            # Choose a New SOI
            self.autoSelectSOI()
            
                
    def autoSelectSOI(self):
        """ This will search the AMC SOI List and choose the SOI based on the priorities.
        """      
        print("AUTO SELECT CALLED\n")
        # Get the Parameter Order in Which to Sort SOIs
        priorities = []
        filter_names = []
        filter_values = []              
        for rows in range(0,self.tableWidget_automation_soi_list_priority.rowCount()):  # SOI List Format: [Modulation,Frequency,Power]
            if self.tableWidget_automation_soi_list_priority.cellWidget(rows,0).currentText() == "Modulation":
                priorities.append(0)
            elif self.tableWidget_automation_soi_list_priority.cellWidget(rows,0).currentText() == "Frequency":
                priorities.append(1)
            elif self.tableWidget_automation_soi_list_priority.cellWidget(rows,0).currentText() == "Power":
                priorities.append(2)
            
            filter_names.append(str(self.tableWidget_automation_soi_list_priority.cellWidget(rows,1).currentText()))
            filter_values.append(str(self.tableWidget_automation_soi_list_priority.item(rows,2).text()))
            
            # Discovery Mode
            if self.dashboard_settings_dictionary['startup_automation_mode'] == "Discovery":  
                break

        # Send Command to HIPRFISR
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Process SOIs', Parameters = [True,priorities,filter_names,filter_values])
                    
    def unloadFlowGraph(self):
        """ This will undo the effects of "_slotPD_DemodulationLoadFlowGraphClicked" by erasing the tables, labels, and text boxes.
        """
        # Update the Edit Box
        self.textEdit_pd_flow_graphs_filepath.setPlainText("")
        
        # Update the Status Dialog
        self.status_dialog.tableWidget_status_results.item(2,0).setText("Flow Graph Not Loaded")
        
        # Update the Protocol Tab Labels
        self.label_pd_status_loaded_flow_graph.setText('')
        self.label_pd_status_flow_graph_status.setText('')
        
        # Update the Variable Listings in "Flow Graph" tab
        self.label_pd_flow_graphs_default_variables.setText("")
        self.tableWidget_pd_flow_graphs_current_values.clearContents()
        self.tableWidget_pd_flow_graphs_current_values.setRowCount(0)   
                            
        # Adjust Table
        self.tableWidget_pd_flow_graphs_current_values.resizeRowsToContents()
        
        # Copy the Flow Graph Dictionary
        self.flow_graph_variables = []  
        
        # Enable/Disable the Push Buttons
        self.pushButton_pd_flow_graphs_view.setEnabled(False)
        self.pushButton_pd_flow_graphs_start_stop.setEnabled(False)
        self.pushButton_pd_flow_graphs_apply_changes.setEnabled(False)
        self.pushButton_pd_flow_graphs_restore_defaults.setEnabled(False)
        
        # Update Flow Graph Status Label
        self.label_pd_flow_graphs_status.setText("Not Loaded")      
        
    def _slotMenuUHD_FindDevicesClicked(self):
        """ Opens a message box and copies the results of "uhd_find_devices"
        """
        # Get the Text
        proc=subprocess.Popen("uhd_find_devices &", shell=True, stdout=subprocess.PIPE, )
        output=proc.communicate()[0].decode()
            
        # Create a Dialog Window    
        msgBox = MyMessageBox(my_text = output)
        msgBox.exec_()                    
        
    def _slotAutomationSystemResetClicked(self):
        """ This will reset all the tables and data collected thus far back to startup conditions.
        """
        # Automation
        self.status_dialog.tableWidget_status_results.item(3,0).setText("Flow Graph Not Loaded")
        #~ self.label_current_flow_graph.setText("Flow Graph Not Loaded")
        #~ self.label_status_attack.setText("Flow Graph Not Loaded")        
        
        # TSI
        self._slotTSI_SOI_UntargetClicked()     
        if self.listWidget_tsi_soi_blacklist.count() > 0:  # Remove Blacklisted Items
            for x in reversed(range(0,self.listWidget_tsi_soi_blacklist.count())):
                self.listWidget_tsi_soi_blacklist.setCurrentRow(x)
                self._slotTSI_SOI_BlacklistRemoveClicked()      
        self._slotTSI_ClearSOI_ListClicked()
        self._slotTSI_ClearWidebandListClicked()        
        
        # Protocol Discovery - Tab 1
        self._slotPD_DemodulationLookupClearClicked()
        self.listWidget_pd_flow_graphs_recommended_fgs.clear()
        self.textEdit_pd_status.clear() 
        self.pushButton_pd_status_start.setEnabled(False)
        self.label_pd_status_loaded_flow_graph.setText("")
        self.label_pd_status_flow_graph_status.setText("")
        
        # Protocol Discovery - Flow Graph
        self.textEdit_pd_flow_graphs_filepath.setPlainText("")
        self.label_pd_flow_graphs_status.setText("Not Loaded")
        self.label_pd_flow_graphs_description.setText("")
        self.label_pd_flow_graphs_default_variables.setText("")
        self.tableWidget_pd_flow_graphs_current_values.setRowCount(0)
        self.pushButton_pd_flow_graphs_start_stop.setEnabled(False)
        self.pushButton_pd_flow_graphs_apply_changes.setEnabled(False)
        self.pushButton_pd_flow_graphs_restore_defaults.setEnabled(False)
        self.pushButton_pd_flow_graphs_view.setEnabled(False)
        
        # Attack
        self.pushButton_attack_start_stop.setEnabled(False)
        self.label_attack_flow_graph_status.setText("Not Loaded")
        self.pushButton_attack_apply_changes.setEnabled(False)
        self.pushButton_attack_restore_defaults.setEnabled(False)
        self.pushButton_attack_view_flow_graph.setEnabled(False)
        self.tableWidget_attack_flow_graph_current_values.setRowCount(0)
        self.tableWidget_attack_attack_history.setRowCount(0)
        self.label_selected_protocol.setText("")
        self.label_attack_fuzzing_selected_protocol.setText("")
        self.label_selected_attack.setText("")
        self.label_attack_fuzzing_selected_attack.setText("")
        self.label_selected_flow_graph.setText("")  
        self.label_attack_fuzzing_selected_flow_graph.setText("")    
        self.label_selected_modulation.setText("")
        self.label_attack_fuzzing_selected_modulation.setText("")
        self.label_selected_notes.setText("")
        
    def _slotMenuHackrfInfoClicked(self):
        """ Opens a message box and copies the results of "hackrf_info"
        """
        # Get the Text
        proc=subprocess.Popen('hackrf_info &', shell=True, stdout=subprocess.PIPE, )
        output=proc.communicate()[0].decode()
            
        # Create a Dialog Window    
        msgBox = MyMessageBox(my_text = output)
        msgBox.exec_()           
        
    def _slotMenuLsusbClicked(self):
        """ Opens a message box and copies the results of "lsusb"
        """
        # Get the Text
        proc=subprocess.Popen('lsusb &', shell=True, stdout=subprocess.PIPE, )
        output=proc.communicate()[0].decode()
            
        # Create a Dialog Window    
        msgBox = MyMessageBox(my_text = output)
        msgBox.exec_()    
        
    def _slotMenuIwconfigClicked(self):
        """ Opens a message box and copies the results of "iwconfig"
        """
        # Get the Text
        proc=subprocess.Popen('iwconfig &', shell=True, stdout=subprocess.PIPE, )
        output=proc.communicate()[0].decode()
            
        # Create a Dialog Window    
        msgBox = MyMessageBox(my_text = output)
        msgBox.exec_()           
                
    def _slotPD_SnifferStreamClicked(self):
        """ Launches the Sniffer_stream flow graph which sniffs a ZMQ PUB port, passes the data to a UDP port, and opens Wireshark.
        """         
        # Start Sniffer
        if self.pushButton_pd_sniffer_stream.text() == "Sniffer - Stream":
            try:
                flow_graph_filepath = str(os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Sniffer Flow Graphs/Sniffer_stream.py")
                
                variable_names = ['address','port']
                get_pd_bits_port = str(self.label_pd_sniffer_zmq_port.text())
                get_address = '127.0.0.1:' + get_pd_bits_port
                get_port = str(self.textEdit_pd_sniffer_sub_udp_port.toPlainText())
                variable_values = [get_address, get_port]
                
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Run Sniffer Flow Graph', Parameters = [flow_graph_filepath, variable_names, variable_values])
                
                # Disable the Buttons
                self.pushButton_pd_sniffer_stream.setEnabled(False)
                self.pushButton_pd_sniffer_tagged_stream.setEnabled(False)
                self.pushButton_pd_sniffer_msg_pdu.setEnabled(False)                
                self.pushButton_pd_sniffer_stream.setText("Stop")
                
            except:
                pass
            
        # Stop Sniffer            
        else:                
            try:
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Sniffer Flow Graph', Parameters = 'Stream')
                
                # Disable the Buttons
                self.pushButton_pd_sniffer_stream.setEnabled(False)
                self.pushButton_pd_sniffer_tagged_stream.setEnabled(False)
                self.pushButton_pd_sniffer_msg_pdu.setEnabled(False)

            except:
                pass
                
    def _slotPD_SnifferTaggedStreamClicked(self):
        """ Launches the Sniffer_tagged_stream flow graph which sniffs a ZMQ PUB port, passes the data to a UDP port, and opens Wireshark.
        """
        # Start Sniffer
        get_port = str(self.textEdit_pd_sniffer_sub_udp_port.toPlainText())
        if self.pushButton_pd_sniffer_tagged_stream.text() == "Sniffer - Tagged Str.":
            try:
                flow_graph_filepath = str(os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Sniffer Flow Graphs/Sniffer_tagged_stream.py")
                
                variable_names = ['address','port']
                get_pd_bits_port = str(self.label_pd_sniffer_zmq_port.text())
                get_address = '127.0.0.1:' + get_pd_bits_port
                get_port = str(self.textEdit_pd_sniffer_sub_udp_port.toPlainText())
                variable_values = [get_address, get_port]
                
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Run Sniffer Flow Graph', Parameters = [flow_graph_filepath, variable_names, variable_values])
                
                # Disable the Buttons
                self.pushButton_pd_sniffer_stream.setEnabled(False)
                self.pushButton_pd_sniffer_tagged_stream.setEnabled(False)
                self.pushButton_pd_sniffer_msg_pdu.setEnabled(False)
                self.pushButton_pd_sniffer_tagged_stream.setText("Stop")

            except:
                pass
            
        # Stop Sniffer            
        else:                
            try:
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Sniffer Flow Graph', Parameters = 'TaggedStream')
                
                # Disable the Buttons
                self.pushButton_pd_sniffer_stream.setEnabled(False)
                self.pushButton_pd_sniffer_tagged_stream.setEnabled(False)
                self.pushButton_pd_sniffer_msg_pdu.setEnabled(False)
                
            except:
                pass
        
    def _slotPD_SnifferMsgPduClicked(self):
        """ Launches the Sniffer_msg_pdu flow graph which sniffs a ZMQ PUB port, passes the data to a UDP port, and opens Wireshark.
        """
        # Start Sniffer
        if self.pushButton_pd_sniffer_msg_pdu.text() == "Sniffer - Msg/PDU":
            try:
                flow_graph_filepath = str(os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Sniffer Flow Graphs/Sniffer_async.py")
                
                variable_names = ['address','port']
                get_pd_bits_port = str(self.label_pd_sniffer_zmq_port.text())
                get_address = '127.0.0.1:' + get_pd_bits_port
                get_port = str(self.textEdit_pd_sniffer_sub_udp_port.toPlainText())
                variable_values = [get_address, get_port]
                
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Run Sniffer Flow Graph', Parameters = [flow_graph_filepath, variable_names, variable_values])
                
                # Disable the Buttons
                self.pushButton_pd_sniffer_stream.setEnabled(False)
                self.pushButton_pd_sniffer_tagged_stream.setEnabled(False)
                self.pushButton_pd_sniffer_msg_pdu.setEnabled(False)
                self.pushButton_pd_sniffer_msg_pdu.setText("Stop")
                
            except:
                pass
            
        # Stop Sniffer            
        else:                
            try:
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Sniffer Flow Graph', Parameters = 'Message/PDU')
                
                # Disable the Buttons
                self.pushButton_pd_sniffer_stream.setEnabled(False)
                self.pushButton_pd_sniffer_tagged_stream.setEnabled(False)
                self.pushButton_pd_sniffer_msg_pdu.setEnabled(False)
            except:
                pass      
                
    def _slotIQ_LoadIQ_Data(self):
        """ Loads the IQ data file information
        """
        # Update the File Information
        try:
            self.label_iq_file_name.setText("File: " + self.listWidget_iq_files.currentItem().text())  # File name
        except:
            print("No File Selected.")
            return
        get_file_path = str(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        self.label_iq_file_size.setText("Size: " + str(round(float((os.path.getsize(get_file_path)))/1048576,2)) + " MB")  # File Size
        self.textEdit_iq_crop_original.setPlainText(get_file_path)
        self.textEdit_iq_crop_new.setPlainText(get_file_path.rpartition('.')[0] + '_cropped.' + get_file_path.rpartition('.')[2])
        self.comboBox_iq_crop_data_type.setCurrentIndex(self.comboBox_iq_data_type.currentIndex())
        self.comboBox_iq_resample_data_type.setCurrentIndex(self.comboBox_iq_data_type.currentIndex())
        
        # Number of Samples
        get_type = self.comboBox_iq_data_type.currentText()
        number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        if number_of_bytes > 0:
            self.textEdit_iq_start.setPlainText("1")  # Start
            self.textEdit_iq_crop_start.setPlainText("1")
            
            if get_type == "Complex Float 32":
                self.textEdit_iq_end.setPlainText(str(int(number_of_bytes/8)))  # End
            elif get_type == "Float/Float 32":
                self.textEdit_iq_end.setPlainText(str(int(number_of_bytes/4)))
            elif get_type == "Short/Int 16":
                self.textEdit_iq_end.setPlainText(str(int(number_of_bytes/2)))
            elif get_type == "Int/Int 32":
                self.textEdit_iq_end.setPlainText(str(int(number_of_bytes/4)))
            elif get_type == "Byte/Int 8":
                self.textEdit_iq_end.setPlainText(str(int(number_of_bytes/1)))
            elif get_type == "Complex Int 16":
                self.textEdit_iq_end.setPlainText(str(int(number_of_bytes/4)))
            elif get_type == "Complex Int 8":
                self.textEdit_iq_end.setPlainText(str(int(number_of_bytes/2)))
            elif get_type == "Complex Float 64":
                self.textEdit_iq_end.setPlainText(str(int(number_of_bytes/16)))
            elif get_type == "Complex Int 64":
                self.textEdit_iq_end.setPlainText(str(int(number_of_bytes/16)))
        else:
            self.textEdit_iq_start.setPlainText("n/a")
            self.textEdit_iq_end.setPlainText("n/a")  
        
        # Sample Label    
        self.label_iq_samples.setText("Samples: " + str(self.textEdit_iq_end.toPlainText()))
        
        # Playback
        self.textEdit_iq_playback_filepath.setPlainText(get_file_path)
        if (self.dashboard_settings_dictionary['hardware_iq'] == "RTL2832U") or (self.dashboard_settings_dictionary['hardware_iq'] == "802.11x Adapter"):  # Receive-Only
            pass
        else:
            self.frame_iq_playback.setEnabled(True)
                
        # Range Buttons
        if int(self.textEdit_iq_end.toPlainText()) > 1000000:
            self.pushButton_iq_plot_prev.setVisible(True)
            self.pushButton_iq_plot_next.setVisible(True)
            #self.pushButton_iq_plot_all.setEnabled(False)
            self.textEdit_iq_end.setPlainText("1000000")
        else:
            self.pushButton_iq_plot_prev.setVisible(False)
            self.pushButton_iq_plot_next.setVisible(False)            
            #self.pushButton_iq_plot_all.setEnabled(True)
            
        # Reset Range Cursor Memory
        self.iq_plot_range_start = 0
        self.iq_plot_range_end = 0

    def _slotIQ_Dir1_Clicked(self):
        """ Selects a source folder for transferring files
        """
        # Select a Directory
        dialog = QtWidgets.QFileDialog(self)
        dialog.setFileMode(QtWidgets.QFileDialog.Directory)
        dialog.setOption(QtWidgets.QFileDialog.ShowDirsOnly, True)

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:
            self.textEdit_iq_dir1.setText(folder)
        except:
            pass
            
        # Hide Success Label
        self.label_iq_transfer_folder_success.setVisible(False)
        
    def _slotIQ_Dir2_Clicked(self):
        """ Selects a destination folder for transferring files
        """
        # Select a Directory
        dialog = QtWidgets.QFileDialog(self)
        dialog.setFileMode(QtWidgets.QFileDialog.Directory)
        dialog.setOption(QtWidgets.QFileDialog.ShowDirsOnly, True)

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:
            self.textEdit_iq_dir2.setText(folder)
        except:
            pass        
            
        # Hide Success Label
        self.label_iq_transfer_folder_success.setVisible(False)
            
    def _slotIQ_TransferClicked(self):
        """ Transfers files from the source folder to the destination folder
        """     
        try:
            self.copytree(str(self.textEdit_iq_dir1.toPlainText()), str(self.textEdit_iq_dir2.toPlainText()))
                    
            # Show Success Label
            self.label_iq_transfer_folder_success.setVisible(True)
            
        except OSError as e:
            pass
        
    def copytree(self, src, dst, symlinks=False, ignore=None):
        """ Copies files from one folder to another. Creates the output directory if it does not exist. Only replaces if the file is modified.
        """
        if not os.path.exists(dst):
            os.makedirs(dst)
        for item in os.listdir(src):
            s = os.path.join(src, item)
            d = os.path.join(dst, item)
            if os.path.isdir(s):
                copytree(s, d, symlinks, ignore)
            else:
                if not os.path.exists(d) or os.stat(s).st_mtime - os.stat(d).st_mtime > 1:
                    shutil.copy2(s, d)  
                    
    def _slotIQ_PlotClicked(self):
        """ Plots the selected IQ file within the specified range.
        """ 
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0:
            
            # Get the Number of Samples
            try:
                start_sample = int(self.textEdit_iq_start.toPlainText())
                end_sample = int(self.textEdit_iq_end.toPlainText())
                num_samples = end_sample - start_sample + 1
            except:
                return
            
            # Do Nothing if Bad Range
            if num_samples < 0:
                return
            
            # Do Not Load Large Amounts of Data
            if num_samples < 5000000:
        
                # Get the Size of Each Sample in Bytes      
                complex_multiple = 1
                if get_type == "Complex Float 32":
                    complex_multiple = 2
                    sample_size = 4
                    num_samples = complex_multiple * num_samples               
                elif get_type == "Float/Float 32":
                    sample_size = 4
                elif get_type == "Short/Int 16":
                    sample_size = 2
                elif get_type == "Int/Int 32":
                    sample_size = 4
                elif get_type == "Byte/Int 8":
                    sample_size = 1
                elif get_type == "Complex Int 16":
                    complex_multiple = 2
                    sample_size = 2
                    num_samples = complex_multiple * num_samples   
                elif get_type == "Complex Int 8":
                    complex_multiple = 2
                    sample_size = 1
                    num_samples = complex_multiple * num_samples                      
                elif get_type == "Complex Float 64":
                    complex_multiple = 2
                    sample_size = 8
                    num_samples = complex_multiple * num_samples                      
                elif get_type == "Complex Int 64":
                    complex_multiple = 2
                    sample_size = 8
                    num_samples = complex_multiple * num_samples                      
                    
                # Check the Range
                if (num_samples*sample_size > number_of_bytes) or (complex_multiple*end_sample*sample_size > number_of_bytes) or (start_sample < 1):
                    print("Out of range.")
                    return
                
                # Read the Data 
                filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
                file = open(filepath,"rb")                          # Open the file
                if "Complex" in get_type:
                    file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
                else:
                    file.seek((start_sample-1) * sample_size)       # Point to the starting sample
                plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
                file.close()
                
                # Format the Data
                if get_type == "Complex Float 32":
                    plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
                elif get_type == "Float/Float 32":
                    plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
                elif get_type == "Short/Int 16":
                    plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
                elif get_type == "Int/Int 32":
                    plot_data_formatted = struct.unpack(num_samples*'i', plot_data)
                elif get_type == "Byte/Int 8":
                    plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
                elif get_type == "Complex Int 16":
                    plot_data_formatted = struct.unpack(num_samples*'h', plot_data)                    
                elif get_type == "Complex Int 8":
                    plot_data_formatted = struct.unpack(num_samples*'b', plot_data)                    
                elif get_type == "Complex Float 64":
                    plot_data_formatted = struct.unpack(num_samples*'d', plot_data)                    
                elif get_type == "Complex Int 64":
                    plot_data_formatted = struct.unpack(num_samples*'l', plot_data)                    
                
                # Plot
                self.iq_matplotlib_widget.clearPlot()
                self.iq_matplotlib_widget.configureAxes(polar=False)
                if "Complex" in get_type:
                    # Ignore hold() Deprecation Warnings
                    with warnings.catch_warnings():
                        warnings.simplefilter("ignore")
                        warnings.filterwarnings("ignore", module="matplotlib")
                        
                        # Plot
                        self.iq_matplotlib_widget.axes.plot(range(1,len(plot_data_formatted[::2])+1),plot_data_formatted[::2],'b',linewidth=1)
                        #self.iq_matplotlib_widget.axes.hold(True)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
                        self.iq_matplotlib_widget.axes.plot(range(1,len(plot_data_formatted[::2])+1),plot_data_formatted[1::2],'r',linewidth=1)
                        #self.iq_matplotlib_widget.axes.hold(False)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
                else:
                    self.iq_matplotlib_widget.axes.plot(range(1,len(plot_data_formatted)+1),plot_data_formatted,'b',linewidth=1)
                
                self.iq_matplotlib_widget.applyLabels("IQ Data",'Samples','Amplitude (LSB)',None,None) 
                self.pushButton_iq_cursor1.setChecked(False)
                self._slotIQ_Cursor1Clicked() 
                #self.iq_matplotlib_widget.draw()
                
                # Set Range Cursor Memory
                self.iq_plot_range_start = start_sample
                self.iq_plot_range_end = end_sample
                
            else:
                print("Too many samples for plotting.")
            
        else:
            print("File is empty or invalid.")    
    
    def isFloat(self,x):
        """ Returns "True" if the input is a Float. Returns "False" otherwise.
        """
        try:
            float(x)
        except ValueError:
            return False
        return True     
            
    def _slotIQ_RecordDirClicked(self):
        """ Selects a folder to store the recorded IQ files.
        """     
        # Select a Directory
        dialog = QtWidgets.QFileDialog(self)
        dialog.setFileMode(QtWidgets.QFileDialog.Directory)
        dialog.setOption(QtWidgets.QFileDialog.ShowDirsOnly, True)

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:
            self.textEdit_iq_record_dir.setText(folder)
            
            # Change the Viewer Folder
            get_dir = str(self.textEdit_iq_record_dir.toPlainText())            
            if len(get_dir) > 0:
                
                # Load Directory and File
                folder_index = self.comboBox_iq_folders.findText(get_dir)
                if folder_index < 0:
                    # New Directory
                    self.comboBox_iq_folders.addItem(get_dir)      
                    self.comboBox_iq_folders.setCurrentIndex(self.comboBox_iq_folders.count()-1)
                else:
                    # Directory Exists
                    self.comboBox_iq_folders.setCurrentIndex(folder_index)
                
        except:
            pass
        
    def _slotIQ_RecordClicked(self, called_from_thread=False):
        """ Loads the "iq_recorder" flow graph on the specified USRP source and begins recording data.
        """         
        # Stop Recording                      
        if (self.pushButton_iq_record.text() == "Stop") and (called_from_thread == False):
            # Send Message to FGE/HIPRFISR
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop IQ Flow Graph', Parameters = ['']) 
            self.iq_file_counter = "abort"
            
        else:
            # Record
            if self.pushButton_iq_record.text() == "Record" and self.iq_file_counter == 0:                
                self.iq_file_counter = 1               
                
            if self.iq_file_counter > 0:
                # Get the Values from the Table
                try:
                    get_base_file_name = str(self.tableWidget_iq_record.item(0,0).text())
                    get_frequency = str(self.tableWidget_iq_record.item(0,1).text())
                    get_channel = str(self.tableWidget_iq_record.cellWidget(0,2).currentText())
                    get_antenna = str(self.tableWidget_iq_record.cellWidget(0,3).currentText())
                    get_gain = str(self.tableWidget_iq_record.item(0,4).text())
                    get_number_of_files = str(self.tableWidget_iq_record.item(0,5).text())
                    get_file_length = str(self.tableWidget_iq_record.item(0,6).text())
                    get_sample_rate = str(self.tableWidget_iq_record.item(0,7).text())
                    get_data_type = str(self.tableWidget_iq_record.cellWidget(0,8).currentText())
                    get_file_interval = str(self.tableWidget_iq_record.item(0,9).text())
                    #get_power_squelch = str(self.tableWidget_iq_record.item(0,9).text())
                    #get_lpf_cutoff = str(self.tableWidget_iq_record.item(0,10).text())
                    #get_lpf_trans_width = str(self.tableWidget_iq_record.item(0,11).text())             
                    get_filepath = str(self.textEdit_iq_record_dir.toPlainText()) + "/" + get_base_file_name
                    #~ get_filepath = get_filepath.replace('/','//')
                    
                    # Validate Inputs
                    float(get_frequency)
                    float(get_gain)
                    int(get_number_of_files)
                    int(get_file_length)
                    float(get_sample_rate)
                    float(get_file_interval)
                    valid_freq = self.checkFrequencyBounds(float(get_frequency), self.dashboard_settings_dictionary['hardware_iq'], self.dashboard_settings_dictionary['hardware_daughterboard_iq'])
                    if valid_freq == False:
                        self.iq_file_counter = 0
                        print("Frequency outside of hardware bounds.")
                        return
                    if int(get_number_of_files) < 1:
                        self.iq_file_counter = 0
                        print("Number of files must be >= 1.")
                        return
                    if float(get_file_interval) < 0:
                        self.iq_file_counter = 0
                        print("File interval must be positive.")
                        return                        
                except:
                    self.iq_file_counter = 0
                    print("Invalid input parameter.")
                    return
                
                # Get Flow Graph from Hardware
                if self.dashboard_settings_dictionary['hardware_iq'] == "Computer":
                    fname = "iq_recorder"  # Should never be called                
                elif self.dashboard_settings_dictionary['hardware_iq'] == "USRP X310":
                    fname = "iq_recorder_x310"
                elif self.dashboard_settings_dictionary['hardware_iq'] == "USRP B210":
                    fname = "iq_recorder_b210"
                elif self.dashboard_settings_dictionary['hardware_iq'] == "HackRF":
                    fname = "iq_recorder_hackrf"
                elif self.dashboard_settings_dictionary['hardware_iq'] == "RTL2832U":
                    fname = "iq_recorder_rtl2832u"  # To Do
                elif self.dashboard_settings_dictionary['hardware_iq'] == "802.11x Adapter":
                    fname = "iq_recorder"  # Should never be called
                elif self.dashboard_settings_dictionary['hardware_iq'] == "USRP B205mini":
                    fname = "iq_recorder_b210"
                elif self.dashboard_settings_dictionary['hardware_iq'] == "LimeSDR":
                    fname = "iq_recorder_limesdr"
                elif self.dashboard_settings_dictionary['hardware_iq'] == "bladeRF":
                    fname = "iq_recorder_bladerf"
                elif self.dashboard_settings_dictionary['hardware_iq'] == "Open Sniffer":
                    fname = "iq_recorder"  # Should never be called                    
                    
                # LimeSDR Channel
                if self.dashboard_settings_dictionary['hardware_iq'] == "LimeSDR":
                    if get_channel == "A":
                        get_channel = "0"
                    elif get_channel == "B":
                        get_channel = "1"
                
                # Hardware Serial
                if len(self.dashboard_settings_dictionary['hardware_serial_iq']) > 0:
                    if self.dashboard_settings_dictionary['hardware_iq'] == "HackRF":
                        get_serial = self.dashboard_settings_dictionary['hardware_serial_iq']
                    else:
                        get_serial = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_iq']                               
                else:
                    if self.dashboard_settings_dictionary['hardware_iq'] == "HackRF":
                        get_serial = ""
                    else:
                        get_serial = "False"    
                
                # Put them in a List
                variable_names = ['filepath','ip_address','rx_channel','rx_frequency','sample_rate','rx_gain','rx_antenna','file_length','serial']
                variable_values = [get_filepath,self.dashboard_settings_dictionary['hardware_ip_iq'],get_channel,get_frequency,get_sample_rate,get_gain,get_antenna,get_file_length,get_serial]  
                
                # Remember File Name for Multiple File Recordings on First Attempt
                if self.iq_file_counter == 1:
                    self.iq_first_file_name = get_base_file_name
                    
                # Send the Parameters to FGE
                    #If no errors entering parameters...
                get_file_type = "Flow Graph"
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Run IQ Flow Graph', Parameters = [str(fname), variable_names, variable_values, get_file_type])
                
                # Change Status Label and Record Button Text
                self.label_iq_status_files.setText("Starting...")
                self.pushButton_iq_record.setText("Stop")
                self.pushButton_iq_record.setEnabled(False)
                self.status_dialog.tableWidget_status_results.item(4,0).setText('Starting...')
            
            
    def _slotIQ_FlowGraphFinished(self):
        """ Called upon cancelling IQ recording. Changes the status and button text.
        """
        # Change Status Label and Record Button Text
        self.label_iq_status_files.setText("Not Recording")
        self.status_dialog.tableWidget_status_results.item(4,0).setText('Not Recording')
        
        # Refresh File List
        self._slotIQ_RefreshClicked()
        
        # Get Folder and File of Recording
        get_dir = str(self.textEdit_iq_record_dir.toPlainText())
        get_file = str(self.tableWidget_iq_record.item(0,0).text())
        
        if len(get_dir) > 0 and len(get_file) > 0:
        
            # Load Directory and File
            folder_index = self.comboBox_iq_folders.findText(get_dir)
            if folder_index < 0:
                # New Directory
                self.comboBox_iq_folders.addItem(get_dir)      
                self.comboBox_iq_folders.setCurrentIndex(self.comboBox_iq_folders.count()-1)
            else:
                # Directory Exists
                self.comboBox_iq_folders.setCurrentIndex(folder_index)
                
            # Load File
            file_item = self.listWidget_iq_files.findItems(get_file,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive)
            file_index = self.listWidget_iq_files.row(file_item[0])
            self.listWidget_iq_files.setCurrentRow(file_index)
            self._slotIQ_LoadIQ_Data()
            self._slotIQ_PlotAllClicked()

        # More than One Number of Files
        get_number_of_files = str(self.tableWidget_iq_record.item(0,5).text())
        if int(get_number_of_files) > 1:
            
            # Update the Counter
            if self.iq_file_counter != "abort":
                self.iq_file_counter = self.iq_file_counter + 1
            
                # Update New File Name
                get_file_name = self.iq_first_file_name
                if '.' in get_file_name:
                    get_file_name = get_file_name.split('.')[0] + '_' + str(self.iq_file_counter) + '.' + get_file_name.split('.')[1]
                else:
                    get_file_name = get_file_name + '_' + str(self.iq_file_counter)
                self.tableWidget_iq_record.setItem(0,0, QtWidgets.QTableWidgetItem(get_file_name))
            
            # Do the Next Recording
            if self.iq_file_counter == "abort":
                self.iq_file_counter = int(get_number_of_files) + 1
            if self.iq_file_counter <= int(get_number_of_files):
                get_delay = float(str(self.tableWidget_iq_record.item(0,9).text()))
                next_record_thread = threading.Timer(get_delay, self._slotIQ_RecordClicked, [True])
                next_record_thread.start()
                #self._slotIQ_RecordClicked()
            
            # All Done
            else:
                self.iq_file_counter = 0
                self.pushButton_iq_record.setText("Record")
        else:
            self.iq_file_counter = 0
            self.pushButton_iq_record.setText("Record") 
        
    def _slotIQ_FlowGraphPlaybackFinished(self):
        """ Called upon cancelling IQ playback. Changes the status and button text.
        """
        # Change Status Label and Record Button Text
        self.label_iq_playback_status.setText("Not Running")
        self.pushButton_iq_playback.setText("Play") 
        self.status_dialog.tableWidget_status_results.item(4,0).setText('Not Recording')     
        
    def _slotTSI_BlacklistAddClicked(self):
        """ Adds frequency range for TSI to ignore to list widget and sends message to TSI.
        """
        # Get the Start and End Frequencies
        start_freq = self.textEdit_tsi_ignore_start.toPlainText()
        end_freq = self.textEdit_tsi_ignore_end.toPlainText()
        start_freq_hz = str(float(start_freq)*1e6)
        end_freq_hz = str(float(end_freq)*1e6)
            
        # Valid Selection
        # if a number, if end_freq > start_freq, if none are blank

        # Add it to the TSI Blacklist List Widget
        self.listWidget_tsi_blacklist.addItem(start_freq + "-" + end_freq)
        self.pushButton_tsi_blacklist_remove.setEnabled(True)

        # Inform the HIPRFISR
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Add Blacklist', Parameters = [start_freq_hz, end_freq_hz])

    def _slotTSI_BlacklistRemoveClicked(self):
        """ Removes frequency range item for TSI to ignore from the list widget and sends message to TSI.
        """
        # Get the Values in the Current Row
        start_freq = str(self.listWidget_tsi_blacklist.currentItem().text()).split("-")[0]
        end_freq = str(self.listWidget_tsi_blacklist.currentItem().text()).split("-")[1]
        start_freq_hz = str(float(start_freq)*1e6)
        end_freq_hz = str(float(end_freq)*1e6)
            
        # Remove it from the TSI Blacklist List Widget
        self.listWidget_tsi_blacklist.takeItem(self.listWidget_tsi_blacklist.currentRow())

        # Inform the HIPRFISR
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Remove Blacklist', Parameters = [start_freq_hz, end_freq_hz])
        
        # Disable the Pusbuttons
        if self.listWidget_tsi_blacklist.count() == 0:
            self.pushButton_tsi_blacklist_remove.setEnabled(False)  
            self.pushButton_tsi_update.setEnabled(False)
        
    def _slotAttackFuzzingSubcategory(self):
        """ Updates the Data Fields table with fields and values for the selected messsage type.
        """    
        # Get the Subcategory
        current_protocol_key = str(self.label_attack_fuzzing_selected_protocol.text())        
        current_subcategory = str(self.comboBox_attack_fuzzing_subcategory.currentText())    
        if current_subcategory != "None":   
            try:
                # Fields          
                self.tableWidget_attack_fuzzing_data_field.clearContents()   
                fields = getFields(self.pd_library, current_protocol_key, current_subcategory)                         
                self.tableWidget_attack_fuzzing_data_field.setRowCount(len(fields))            
                self.tableWidget_attack_fuzzing_data_field.setVerticalHeaderLabels(fields)
                
                # Lengths
                for n in range(0,len(fields)):
                    get_length = self.pd_library["Protocols"][current_protocol_key]['Packet Types'][current_subcategory]['Fields'][fields[n]]['Length']        
                    length_item = QtWidgets.QTableWidgetItem(str(get_length))
                    length_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_attack_fuzzing_data_field.setItem(n,7,length_item)
                
            except KeyError:
                #No Fields Defined!
                #~ print("No Fields Defined!")
                fields = []
                self.tableWidget_attack_fuzzing_data_field.setRowCount(1)            
                self.tableWidget_attack_fuzzing_data_field.setVerticalHeaderLabels(['Custom'])        
                get_length = 0       
                length_item = QtWidgets.QTableWidgetItem("")
                length_item.setTextAlignment(QtCore.Qt.AlignCenter)
                default_length_item = QtWidgets.QTableWidgetItem(str(get_length))
                default_length_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.tableWidget_attack_fuzzing_data_field.setItem(0,6,length_item)
                self.tableWidget_attack_fuzzing_data_field.setItem(0,7,default_length_item)
                                                
            # Restore ComboBoxes and CheckBoxes
            for n in range(0,self.tableWidget_attack_fuzzing_data_field.rowCount()):            
                new_combobox1 = QtWidgets.QComboBox(self)
                self.tableWidget_attack_fuzzing_data_field.setCellWidget(n,4,new_combobox1)
                new_combobox1.addItem("Binary")
                new_combobox1.addItem("Hex")
                new_combobox1.setSizeAdjustPolicy(0)
                new_combobox1.setFixedSize(113,24)
                new_combobox1.setCurrentIndex(1)
                new_combobox1.currentIndexChanged.connect(lambda: self._slotPacketBinaryHex(self.tableWidget_attack_fuzzing_data_field))
                new_combobox1.setProperty("row", n)
                
                # CheckBoxes    
                new_checkbox = QtWidgets.QCheckBox("",self)
                new_checkbox.setStyleSheet("margin-left:17%")  # doesn't center, could create a layout and put the radio button in the layout
                self.tableWidget_attack_fuzzing_data_field.setCellWidget(n,0,new_checkbox)
                #new_checkbox.stateChanged.connect(self._slotAttackFuzzingDataSelectCheckboxClicked)
                
                # ComboBoxes
                new_combobox2 = QtWidgets.QComboBox(self)
                self.tableWidget_attack_fuzzing_data_field.setCellWidget(n,1,new_combobox2)
                new_combobox2.addItem("Random")
                new_combobox2.addItem("Sequential")
                new_combobox2.setSizeAdjustPolicy(0)
                new_combobox2.setFixedSize(87,24)
                new_combobox2.setCurrentIndex(0) 
                new_combobox2.setProperty("row", n)
                                
            # Calculate the Lengths
            default_length = 0
            for n in range(0,self.tableWidget_attack_fuzzing_data_field.rowCount()):
                default_length += int(self.tableWidget_attack_fuzzing_data_field.item(n,7).text())
            
            # Set the Length Labels
            self.label_attack_fuzzing_current_length_total.setText(str(""))
            self.label_attack_fuzzing_default_length_total.setText(str(default_length))  
            
            # Resize the Table
            self.tableWidget_attack_fuzzing_data_field.setColumnWidth(0,54) 
            self.tableWidget_attack_fuzzing_data_field.setColumnWidth(1,113) 
            self.tableWidget_attack_fuzzing_data_field.setColumnWidth(2,87) 
            self.tableWidget_attack_fuzzing_data_field.setColumnWidth(3,87) 
            self.tableWidget_attack_fuzzing_data_field.setColumnWidth(4,87) 
            self.tableWidget_attack_fuzzing_data_field.setColumnWidth(6,75) 
            self.tableWidget_attack_fuzzing_data_field.setColumnWidth(7,75)
            self.tableWidget_attack_fuzzing_data_field.horizontalHeader().setSectionResizeMode(5,QtWidgets.QHeaderView.Stretch) 
            self.tableWidget_attack_fuzzing_data_field.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
            self.tableWidget_attack_fuzzing_data_field.horizontalHeader().setSectionResizeMode(4, QtWidgets.QHeaderView.ResizeToContents)
            
            # Restore Defaults
            if self.comboBox_attack_fuzzing_subcategory.count() > 0:
                self._slotAttackFuzzingRestoreDefaultsClicked()
                        
    def _slotAttackFuzzingRestoreDefaultsClicked(self):
        """ Reloads the default values for the selected message type into the Data Fields table.
        """        
        # Get the Protocol
        current_protocol = self.comboBox_attack_protocols.currentText()        
        current_protocol_key = str(current_protocol)
        
        # Get the Subcategory
        current_subcategory = self.comboBox_attack_fuzzing_subcategory.currentText()
        current_subcategory_key = str(current_subcategory)
        
        # Clear the Tables
        self.tableWidget_attack_fuzzing_data_field.clearContents()
   
        # Load the Default Fields and Data 
        fields = getFields(self.pd_library,current_protocol_key,current_subcategory_key)       
        default_field_data = [self.pd_library["Protocols"][current_protocol_key]['Packet Types'][current_subcategory_key]['Fields'][field]['Default Value'] for field in fields]            
       
        for n in range(0,len(fields)):
            # Length Items
            get_length = self.pd_library["Protocols"][current_protocol_key]['Packet Types'][current_subcategory_key]['Fields'][fields[n]]['Length']    
            length_item = QtWidgets.QTableWidgetItem(str(get_length))
            length_item.setTextAlignment(QtCore.Qt.AlignCenter)
            length_item.setFlags(QtCore.Qt.ItemIsEnabled)
            default_length_item = QtWidgets.QTableWidgetItem(str(get_length))
            default_length_item.setTextAlignment(QtCore.Qt.AlignCenter)
            default_length_item.setFlags(QtCore.Qt.ItemIsEnabled)
            self.tableWidget_attack_fuzzing_data_field.setItem(n,6,length_item)
            self.tableWidget_attack_fuzzing_data_field.setItem(n,7,default_length_item)

            # Set Binary/Hex comboboxes
            new_combobox1 = QtWidgets.QComboBox(self)
            self.tableWidget_attack_fuzzing_data_field.setCellWidget(n,4,new_combobox1)
            new_combobox1.addItem("Binary")
            new_combobox1.addItem("Hex")
            new_combobox1.setSizeAdjustPolicy(0)
            new_combobox1.setCurrentIndex(0)
            new_combobox1.currentIndexChanged.connect(lambda: self._slotPacketBinaryHex(self.tableWidget_attack_fuzzing_data_field))
            new_combobox1.setProperty("row", n)               
            self.tableWidget_attack_fuzzing_data_field.setItem(n,5,QtWidgets.QTableWidgetItem(str(default_field_data[n])))
            if get_length % 4 != 0:
                new_combobox1.setEnabled(False)
            else:
                new_combobox1.setCurrentIndex(1)   
                
            # CheckBoxes    
            new_checkbox = QtWidgets.QCheckBox("",self)
            new_checkbox.setStyleSheet("margin-left:17%")  # doesn't center, could create a layout and put the radio button in the layout
            self.tableWidget_attack_fuzzing_data_field.setCellWidget(n,0,new_checkbox)
            #new_checkbox.stateChanged.connect(self._slotAttackFuzzingDataSelectCheckboxClicked)
            
            # ComboBoxes
            new_combobox2 = QtWidgets.QComboBox(self)
            self.tableWidget_attack_fuzzing_data_field.setCellWidget(n,1,new_combobox2)
            new_combobox2.addItem("Random")
            new_combobox2.addItem("Sequential")
            new_combobox2.setSizeAdjustPolicy(0)
            new_combobox2.setCurrentIndex(0)
            
            # Set Min Values
            min_item = QtWidgets.QTableWidgetItem(str(0))
            min_item.setTextAlignment(QtCore.Qt.AlignCenter)     
            self.tableWidget_attack_fuzzing_data_field.setItem(n,2,min_item)
            
            # Set Max Values
            get_max = (2**get_length)-1
            max_item = QtWidgets.QTableWidgetItem(str(get_max))
            max_item.setTextAlignment(QtCore.Qt.AlignCenter)     
            self.tableWidget_attack_fuzzing_data_field.setItem(n,3,max_item)
           
        # Calculate the Lengths
        current_length = 0
        default_length = 0
        for n in range(0,self.tableWidget_attack_fuzzing_data_field.rowCount()):
            current_length += int(self.tableWidget_attack_fuzzing_data_field.item(n,6).text())
            default_length += int(self.tableWidget_attack_fuzzing_data_field.item(n,7).text())
        
        # Set the Length Labels
        self.label_attack_fuzzing_current_length_total.setText(str(current_length))
        self.label_attack_fuzzing_default_length_total.setText(str(default_length)) 
        
        # Resize the Table
        self.tableWidget_attack_fuzzing_data_field.setColumnWidth(0,54) 
        self.tableWidget_attack_fuzzing_data_field.setColumnWidth(1,113) 
        self.tableWidget_attack_fuzzing_data_field.setColumnWidth(2,87) 
        self.tableWidget_attack_fuzzing_data_field.setColumnWidth(3,87) 
        self.tableWidget_attack_fuzzing_data_field.setColumnWidth(4,87) 
        self.tableWidget_attack_fuzzing_data_field.setColumnWidth(6,75) 
        self.tableWidget_attack_fuzzing_data_field.setColumnWidth(7,75)
        self.tableWidget_attack_fuzzing_data_field.horizontalHeader().setSectionResizeMode(5,QtWidgets.QHeaderView.Stretch)   
        self.tableWidget_attack_fuzzing_data_field.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        self.tableWidget_attack_fuzzing_data_field.horizontalHeader().setSectionResizeMode(4, QtWidgets.QHeaderView.ResizeToContents)
        
    def _slotAttackFuzzingStartClicked(self):
        """ Signals to HIPRFISR/FGE to load fuzzer flow graph
        """             
        #~ try:
        # Data Field Table
        if self.stackedWidget_fuzzing.currentIndex() == 0:
            # Convert Every Field to Binary, Assemble
            get_bin = ""
            fuzzing_fields = []
            fuzzing_type = []
            fuzzing_min = []
            fuzzing_max = []
            hex_str = ""
            for n in range(0,self.tableWidget_attack_fuzzing_data_field.rowCount()):
                # Binary or Hex
                current_selection = self.tableWidget_attack_fuzzing_data_field.cellWidget(n,4).currentText()
            
                # Contains Data
                if self.tableWidget_attack_fuzzing_data_field.item(n,5).text() != "":
                    # Get the Data      
                    get_data = str(self.tableWidget_attack_fuzzing_data_field.item(n,5).text())
                
                    if current_selection == "Binary":
                        bin_str = get_data.replace(' ', '')
                        
                    # Hex to Binary 
                    elif current_selection == "Hex":
                        hex_len = len(get_data)
                        bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                        
                    get_bin = get_bin + bin_str
                    
                # Get Checked Fields
                if self.tableWidget_attack_fuzzing_data_field.cellWidget(n,0).isChecked() == True:
                    fuzzing_fields.append(str(self.tableWidget_attack_fuzzing_data_field.verticalHeaderItem(n).text()))
                    
                    # Get Fuzzing Type
                    fuzzing_type.append(str(self.tableWidget_attack_fuzzing_data_field.cellWidget(n,1).currentText()))
                    
                    # Get Fuzzing Min
                    if self.tableWidget_attack_fuzzing_data_field.item(n,2) == None:
                        fuzzing_min.append("")
                    else:
                        fuzzing_min.append(str(self.tableWidget_attack_fuzzing_data_field.item(n,2).text()))
                    
                    # Get Fuzzing Max
                    if self.tableWidget_attack_fuzzing_data_field.item(n,3) == None:
                        fuzzing_max.append("")
                    else:
                        fuzzing_max.append(str(self.tableWidget_attack_fuzzing_data_field.item(n,3).text()))
                    
            # Convert to Hex
            if get_bin != "":
                hex_str = '%0*X' % ((len(get_bin) + 3) // 4, int(get_bin, 2))
                    
        # Send Stop Message to the HIPRFISR (Flow Graph Currently Running: Stopping)
        if self.pushButton_attack_fuzzing_start.text() == "Stop Attack":
            
            # Stop Physical Fuzzing (In Case it is Running)
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Physical Fuzzing')
            
            # Stop Attack Flow Graph
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Attack Flow Graph', Parameters = [''])
            
            # Toggle the Text
            self.pushButton_attack_fuzzing_start.setText("Start Attack")  
            
            # Disable Apply Button
            self.pushButton_attack_fuzzing_apply_changes.setEnabled(False)
            
            # Update Flow Graph Status Label
            self.label_attack_fuzzing_flow_graph_status.setText("Not Running") 
            
            # Enabled All Values for Editing
            for get_row in range(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()):   
                get_value_item = self.tableWidget_attack_fuzzing_flow_graph_current_values.takeItem(get_row,0)
                get_value_item.setFlags(get_value_item.flags() | QtCore.Qt.ItemIsEditable)
                get_value_item.setFlags(get_value_item.flags() | QtCore.Qt.ItemIsEnabled)
                self.tableWidget_attack_fuzzing_flow_graph_current_values.setItem(get_row,0,get_value_item)

        # Start Flow Graph/Fuzzing
        elif self.pushButton_attack_fuzzing_start.text() == "Start Attack":
            
            # Initialize                    
            physical_fuzzing_enabled = False                    
            
            # Get each Variable Name and Value
            variable_names = []
            variable_values = []
            for get_row in range(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()):                
                # Save the Variable Name and Value in the Row to a Dictionary
                get_name = str(self.tableWidget_attack_fuzzing_flow_graph_current_values.verticalHeaderItem(get_row).text())
                fuzzing_blocks = ["fuzzing_fields","fuzzing_type","fuzzing_min","fuzzing_max","fuzzing_data","fuzzing_seed","fuzzing_interval","fuzzing_protocol","fuzzing_packet_type"]
                if not any(get_name in x for x in fuzzing_blocks):
                    variable_names.append(get_name)
                    variable_values.append(str(self.tableWidget_attack_fuzzing_flow_graph_current_values.item(get_row,0).text()))
                
            # Disable Values with Names Matching those Listed in "fissure_config.yaml"
            for get_row in range(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()):             
                get_name = str(self.tableWidget_attack_fuzzing_flow_graph_current_values.verticalHeaderItem(get_row).text())
                if get_name in self.dashboard_settings_dictionary['disabled_running_flow_graph_variables']:
                    get_value_item = self.tableWidget_attack_fuzzing_flow_graph_current_values.takeItem(get_row,0)
                    get_value_item.setFlags(get_value_item.flags() & ~QtCore.Qt.ItemIsEnabled)
                    self.tableWidget_attack_fuzzing_flow_graph_current_values.setItem(get_row,0,get_value_item)    
    
            # Fields - Insert Fuzzing Information
            if self.stackedWidget_fuzzing.currentIndex() == 0:         
                variable_names.append("fuzzing_fields")
                variable_names.append("fuzzing_type")
                variable_names.append("fuzzing_min")
                variable_names.append("fuzzing_max")
                variable_names.append("fuzzing_data")
                variable_names.append("fuzzing_seed")
                variable_names.append("fuzzing_interval")
                variable_names.append("fuzzing_protocol")
                variable_names.append("fuzzing_packet_type")
                variable_values.append(str(fuzzing_fields))
                variable_values.append(str(fuzzing_type))
                variable_values.append(str(fuzzing_min))
                variable_values.append(str(fuzzing_max))
                variable_values.append(hex_str)
                variable_values.append(str(self.textEdit_attack_fuzzing_seed.toPlainText()))
                variable_values.append(str(self.textEdit_attack_fuzzing_interval.toPlainText()))
                variable_values.append(str(self.label_attack_fuzzing_selected_protocol.text()))
                variable_values.append(str(self.comboBox_attack_fuzzing_subcategory.currentText()))                    
                
            # Variables
            elif self.stackedWidget_fuzzing.currentIndex() == 1:  
                                      
                # Look for Variable Fuzzing Radiobuttons
                for rows in range(0,self.tableWidget_fuzzing_variables.rowCount()):
                    if self.tableWidget_fuzzing_variables.cellWidget(rows,0):  # Has a Cell Widget
                        if self.tableWidget_fuzzing_variables.cellWidget(rows,0).isChecked():
                            physical_fuzzing_enabled = True
                            break                                               
                                                
                # Start Variable Fuzzing
                if physical_fuzzing_enabled == True:
                    
                    # Get Physical Layer Fuzzing Parameters
                    fuzzing_variables = []
                    fuzzing_type = []
                    fuzzing_min = []
                    fuzzing_max = []
                    fuzzing_seed_step = []
                    for rows in range(0,self.tableWidget_fuzzing_variables.rowCount()):
                        if self.tableWidget_fuzzing_variables.cellWidget(rows,0):  # Has a Cell Widget
                            if self.tableWidget_fuzzing_variables.cellWidget(rows,0).isChecked():               
                                # Get Fuzzing Variable Name
                                fuzzing_variables.append(str(self.tableWidget_fuzzing_variables.verticalHeaderItem(rows).text()))
                                
                                # Get Fuzzing Type
                                fuzzing_type.append(str(self.tableWidget_fuzzing_variables.cellWidget(rows,1).currentText()))
                                
                                # Get Fuzzing Min
                                if self.tableWidget_fuzzing_variables.item(rows,3) == None:
                                    fuzzing_min.append("")
                                else:
                                    fuzzing_min.append(str(self.tableWidget_fuzzing_variables.item(rows,3).text()))
                                
                                # Get Fuzzing Max
                                if self.tableWidget_fuzzing_variables.item(rows,4) == None:
                                    fuzzing_max.append("")
                                else:
                                    fuzzing_max.append(str(self.tableWidget_fuzzing_variables.item(rows,4).text()))
                                    
                                # Get Fuzzing Seed/Step
                                if self.tableWidget_fuzzing_variables.item(rows,2) == None:
                                    fuzzing_seed_step.append("0")
                                else:
                                    fuzzing_seed_step.append(str(self.tableWidget_fuzzing_variables.item(rows,2).text()))                       
                                        
                    # Add Update Period
                    fuzzing_update_period = str(self.textEdit_fuzzing_update_period.toPlainText())
                    
                    # Min/Max Error Checking
                    for n in range(0,len(fuzzing_min)):
                        if (fuzzing_min[n] == "" or fuzzing_max[n] == ""):
                            self.errorMessage("Error in Physical Layer Fuzzing: Min./Max. Value Missing.")
                            raise ValueError
                            
                        else:
                            if float(fuzzing_min[n]) > float(fuzzing_max[n]):
                                self.errorMessage("Error in Physical Layer Fuzzing: Minimum is Greater than Maximum.")      
                                raise ValueError  

            # Toggle the Text       
            self.pushButton_attack_fuzzing_start.setText("Stop Attack") 
            self.pushButton_attack_fuzzing_start.setEnabled(False)
            
            # Enable Apply Button
            self.pushButton_attack_fuzzing_apply_changes.setEnabled(False) 
            
            # Update Flow Graph Status Label
            self.label_attack_fuzzing_flow_graph_status.setText("Starting...")
            
            # Send "Run Attack Flow Graph" Message to the HIPRFISR
            fname = self.label_attack_fuzzing_selected_flow_graph.text()   
            get_file_type = "Flow Graph"      
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Run Attack Flow Graph', Parameters = [str(fname), variable_names, variable_values, get_file_type])     
   
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(3,0).setText('Starting... "' + fname.split('/')[-1] + '"')
            
            # Send "Start Physical Fuzzing" Message
            if physical_fuzzing_enabled == True:    
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Start Physical Fuzzing', Parameters = [fuzzing_variables, fuzzing_type, fuzzing_min, fuzzing_max, fuzzing_update_period, fuzzing_seed_step])     

            # Update the Attack History Table       
            attack_name = str(self.label_attack_fuzzing_selected_attack.text())
            protocol = str(self.label_attack_fuzzing_selected_protocol.text())
            self.updateAttackHistory(attack_name, protocol, variable_names, variable_values)        
    
        #~ # Message Data Entered Incorrectly
        #~ except ValueError as inst:
            #~ self.errorMessage("Message data was entered incorrectly.")  
        
    def _slotAttackFuzzingApplyChangesClicked(self):
        """ Updates the fuzzing flow graph with new fuzzer/flow graph variable changes.
        """ 
        # Flow Graph Controls
        # Send Message(s) to the HIPRFISR for each Variable Name and Value
        for get_row in range(self.tableWidget_attack_fuzzing_flow_graph_current_values.rowCount()):
            
            # Determine the Variable Name and Value in the Row
            variable_name = self.tableWidget_attack_fuzzing_flow_graph_current_values.verticalHeaderItem(get_row).text()
            value = self.tableWidget_attack_fuzzing_flow_graph_current_values.item(get_row,0).text()
                    
            # Check and Send the "Set" Message if Value Changed
            if self.attack_flow_graph_variables[str(variable_name)] != str(value):
                self.attack_flow_graph_variables[str(variable_name)] = str(value)
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Variable', Parameters = ["Attack", str(variable_name), str(value)] )
        
        #~ # Data Field Controls
        #~ if self.stackedWidget_fuzzing.currentIndex() == 0:
            #~ # Convert Every Field to Binary, Assemble
            #~ get_bin = ""
            #~ fuzzing_fields = []
            #~ fuzzing_type = []
            #~ fuzzing_min = []
            #~ fuzzing_max = []
            #~ hex_str = ""
            #~ for n in range(0,self.tableWidget_attack_fuzzing_data_field.rowCount()):
                #~ # Binary or Hex
                #~ current_selection = self.tableWidget_attack_fuzzing_data_field.cellWidget(n,4).currentText()
            #~ 
                #~ # Contains Data
                #~ if self.tableWidget_attack_fuzzing_data_field.item(n,5).text() != "":
                    #~ # Get the Data      
                    #~ get_data = str(self.tableWidget_attack_fuzzing_data_field.item(n,5).text())
                    #~ print(get_data)
                    #~ 
                    #~ if current_selection == "Binary":
                        #~ bin_str = get_data.replace(' ', '')
                        #~ 
                    #~ # Hex to Binary 
                    #~ elif current_selection == "Hex":
                        #~ print(n)
                        #~ hex_len = len(get_data)
                        #~ bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                        #~ 
                    #~ get_bin = get_bin + bin_str
                    #~ 
                #~ # Get Checked Fields
                #~ if self.tableWidget_attack_fuzzing_data_field.cellWidget(n,0).isChecked() == True:
                    #~ fuzzing_fields.append(str(self.tableWidget_attack_fuzzing_data_field.verticalHeaderItem(n).text()))
                    #~ 
                    #~ # Get Fuzzing Type
                    #~ fuzzing_type.append(str(self.tableWidget_attack_fuzzing_data_field.cellWidget(n,1).currentText()))
                    #~ 
                    #~ # Get Fuzzing Min
                    #~ if self.tableWidget_attack_fuzzing_data_field.item(n,2) == None:
                        #~ fuzzing_min.append("")
                    #~ else:
                        #~ fuzzing_min.append(str(self.tableWidget_attack_fuzzing_data_field.item(n,2).text()))
                    #~ 
                    #~ # Get Fuzzing Max
                    #~ if self.tableWidget_attack_fuzzing_data_field.item(n,3) == None:
                        #~ fuzzing_max.append("")
                    #~ else:
                        #~ fuzzing_max.append(str(self.tableWidget_attack_fuzzing_data_field.item(n,3).text()))
            #~ 
            #~ # Convert Data to Hex           
            #~ if get_bin != "":
                #~ hex_str = '%0*X' % ((len(get_bin) + 3) // 4, int(get_bin, 2))           
                        #~ 
            #~ # Check and Send the "Set" Message if Value Changed
            #~ if self.attack_flow_graph_variables["fuzzing_fields"] != str(fuzzing_fields):
                #~ self.attack_flow_graph_variables["fuzzing_fields"] = str(fuzzing_fields)
                #~ self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Variable', Parameters = ["Attack", "fuzzing_fields", str(fuzzing_fields)] )
            #~ if self.attack_flow_graph_variables["fuzzing_type"] != str(fuzzing_type):
                #~ self.attack_flow_graph_variables["fuzzing_type"] = str(fuzzing_type)
                #~ self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Variable', Parameters = ["Attack", "fuzzing_type", str(fuzzing_type)] )
            #~ if self.attack_flow_graph_variables["fuzzing_min"] != str(fuzzing_min):
                #~ self.attack_flow_graph_variables["fuzzing_min"] = str(fuzzing_min)
                #~ self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Variable', Parameters = ["Attack", "fuzzing_min", str(fuzzing_min)] )
            #~ if self.attack_flow_graph_variables["fuzzing_max"] != str(fuzzing_max):
                #~ self.attack_flow_graph_variables["fuzzing_max"] = str(fuzzing_max)
                #~ self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Variable', Parameters = ["Attack", "fuzzing_max", str(fuzzing_max)] )                        
            #~ if self.attack_flow_graph_variables["fuzzing_data"] != hex_str:
                #~ self.attack_flow_graph_variables["fuzzing_data"] = hex_str
                #~ self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Variable', Parameters = ["Attack", "fuzzing_data", hex_str] )            
                #~ 
        # Disable the Pushbutton
        self.pushButton_attack_fuzzing_apply_changes.setEnabled(False)
        
        # Update the "Attack History" Table
        attack_name = str(self.label_attack_fuzzing_selected_attack.text())
        protocol = str(self.label_attack_fuzzing_selected_protocol.text())
        self.updateAttackHistory(attack_name, protocol, list(self.attack_flow_graph_variables.keys()), list(self.attack_flow_graph_variables.values()))
        
    def _slotPacketAllHexClicked(self):
        """ Converts all values to hex from binary in the packet editor.
        """ 
        try:
            # Change the Binary/Hex ComboBox
            for row in range(self.tableWidget_attack_packet_editor.rowCount()):  
                if self.tableWidget_attack_packet_editor.cellWidget(row,0).isEnabled() is True:           
                    self.tableWidget_attack_packet_editor.cellWidget(row,0).setCurrentIndex(1)              
                
        # Message Data Entered Incorrectly
        except ValueError as inst:
            self.errorMessage("Message data was entered incorrectly.")              
        
    def _slotPacketAllBinaryClicked(self):
        """ Converts all values to binary from hex in the packet editor.
        """ 
        try:
            # Change the Binary ComboBox
            for row in range(self.tableWidget_attack_packet_editor.rowCount()):
                get_length = int(self.tableWidget_attack_packet_editor.item(row,3).text())
                if get_length > 0:
                    self.tableWidget_attack_packet_editor.cellWidget(row,0).setCurrentIndex(0)
                
        # Message Data Entered Incorrectly
        except ValueError as inst:
            self.errorMessage("Message data was entered incorrectly.")          
        
    def _slotAttackFuzzingAllHexClicked(self):
        """ Converts all values to hex from binary in the fuzzing controls tab.
        """ 
        # Change the Binary/Hex ComboBox
        for row in range(self.tableWidget_attack_fuzzing_data_field.rowCount()):   
            if self.tableWidget_attack_fuzzing_data_field.cellWidget(row,4).isEnabled() is True:                
                self.tableWidget_attack_fuzzing_data_field.cellWidget(row,4).setCurrentIndex(1)                            
        
    def _slotAttackFuzzingAllBinaryClicked(self):
        """ Converts all values to binary from hex in the fuzzing controls tab.
        """ 
        # Change the Binary ComboBox
        for row in range(self.tableWidget_attack_fuzzing_data_field.rowCount()):
            self.tableWidget_attack_fuzzing_data_field.cellWidget(row,4).setCurrentIndex(0)
            
    def _slotDetectorFlowGraphError(self, param):
        """ Creates a message box with an error message upon Detector flow graph error.
        """
        # Enable Items
        self._slotTSI_DetectorStartClicked()
        
        # Open Window
        self.errorMessage("Flow Graph Error:\n" + param)              

    def _slotFlowGraphError(self, param):
        """ Creates a message box with an error message upon flow graph error.
        """
        # Enable Items
        self.comboBox_attack_protocols.setEnabled(True)
        self.comboBox_attack_modulation.setEnabled(True)
        self.comboBox_attack_hardware.setEnabled(True)
        
        # Open Window
        self.errorMessage("Flow Graph Error:\n" + param)    
        
    def _slotPacketOpenClicked(self):
        """ Loads a binary file into the packet editor.
        """
        # Look for the Binary File
        directory = os.path.dirname(os.path.realpath(__file__)) + "/Crafted Packets/"  # Default Directory
        fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select Binary File...", directory, filter="Binary Files (*.bin);;All Files (*.*)")[0]

        # If a Valid File
        if fname != "":
            # Read the File
            f = open(fname, "rb")
            get_bytes = f.read()
            f.close()
            hex_str = binascii.hexlify(get_bytes)            
            hex_str = hex_str.decode("utf-8").upper()
            
            # Set the Assembled Text Box
            self.textEdit_packet_constructed.setPlainText(hex_str)
            
    def _slotAttackFuzzingSelectFileClicked(self):
        """ Loads a flow graph for fuzzing its variables.
        """     
        # Get the Current Protocol and Modulation
        get_protocol = self.comboBox_attack_protocols.currentText()
        get_modulation = self.comboBox_attack_modulation.currentText()
        
        # Look for a Flow Graph
        directory = os.path.dirname(os.path.realpath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/" # Default Directory
        fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select Flow Graph...", directory, filter="Flow Graphs (" + get_protocol.replace(" ","_") + "_" + get_modulation.replace(" ","_")  + "*.py);;All Files (*.*)")[0]
    
        # If a Valid File
        if fname != "":         
            # Set the File Edit Box
            self.textEdit_fuzzing_from_file.setText(fname)
            
            # Enable the Pushbutton
            self.pushButton_attack_fuzzing_start.setEnabled(True)
        
            # Load the File
            self._slotAttackLoadFromLibraryClicked(None,fname.split('/')[-1])  
            
            # Update the Variables Table
            if self.stackedWidget_fuzzing.currentIndex() == 1:
                # Clear the Table
                for rows in reversed(range(0,self.tableWidget_fuzzing_variables.rowCount())):
                    self.tableWidget_fuzzing_variables.removeRow(rows)
                
                # Insert the Data
                # Read Flow Graph Variables
                radio_button_group=QtWidgets.QButtonGroup(self)
                temp_flow_graph_variables = {}
                f = open(fname,'r')
                parsing = False
                for line in f:
                    if line.startswith("        # Variables"):
                        parsing = True
                    elif line.startswith("        # Blocks"):
                        parsing = False
                    if parsing:
                        # Strip Extra Text
                        get_line = line.split('=',1)[-1]
                        get_line = get_line.split('#',1)[0]
                        get_line = get_line.lstrip()
                            
                        # Default Values in the Variables Table                         
                        if get_line != "":                                          
                            variable_name = QtWidgets.QTableWidgetItem(get_line.split(' = ')[0])
                            value_text = get_line.split(' = ')[1].rstrip('\n')
                            value_text = value_text.replace('"','')
                            value = QtWidgets.QTableWidgetItem(value_text)
                            value.setFlags(value.flags() & ~QtCore.Qt.ItemIsEditable)
                            value.setTextAlignment(QtCore.Qt.AlignCenter)
                            self.tableWidget_fuzzing_variables.setRowCount(self.tableWidget_fuzzing_variables.rowCount()+1)                            
                            
                            # Add Buttons/ComboBoxes if Value is a Float
                            if self.isFloat(value_text):        
                                                    
                                # Select Radiobuttons
                                new_button = QtWidgets.QRadioButton("",self)
                                new_button.setStyleSheet("margin-left:15%")  # doesn't center, could create a layout and put the radio button in the layout                         
                                self.tableWidget_fuzzing_variables.setCellWidget(self.tableWidget_fuzzing_variables.rowCount()-1,0,new_button)  
                                radio_button_group.addButton(new_button)    
                                
                                # Type Comboboxes
                                new_fuzzing_combobox = QtWidgets.QComboBox(self)
                                self.tableWidget_fuzzing_variables.setCellWidget(self.tableWidget_fuzzing_variables.rowCount()-1,1,new_fuzzing_combobox)
                                new_fuzzing_combobox.addItem("Random")
                                new_fuzzing_combobox.addItem("Sequential")
                                new_fuzzing_combobox.setSizeAdjustPolicy(0)
                                new_fuzzing_combobox.setCurrentIndex(0) 
                                
                            # Disable the Row   
                            else:
                                # Disable Editing
                                for col in range(0,self.tableWidget_fuzzing_variables.columnCount()):
                                    blank_item = QtWidgets.QTableWidgetItem("")
                                    blank_item.setFlags(blank_item.flags() & ~QtCore.Qt.ItemIsEnabled)
                                    self.tableWidget_fuzzing_variables.setItem(self.tableWidget_fuzzing_variables.rowCount()-1,col,blank_item)  
                                    
                                #~ value.setFlags(value.flags() & ~QtCore.Qt.ItemIsEnabled)
                                #~ variable_name.setFlags(variable_name.flags() & ~QtCore.Qt.ItemIsEditable)
                                
                            # Add the Items 
                            self.tableWidget_fuzzing_variables.setItem(self.tableWidget_fuzzing_variables.rowCount()-1,5,value)         
                            self.tableWidget_fuzzing_variables.setVerticalHeaderItem(self.tableWidget_fuzzing_variables.rowCount()-1,variable_name)
                
                # Close the File
                f.close() 
                            
                # Adjust Table
                self.tableWidget_fuzzing_variables.resizeRowsToContents()                   
                self.tableWidget_fuzzing_variables.resizeColumnsToContents()    
                self.tableWidget_fuzzing_variables.horizontalHeader().setStretchLastSection(False)
                self.tableWidget_fuzzing_variables.horizontalHeader().setStretchLastSection(True)
                            
    def errorMessage(self,message_text):
        """ Creates a popup window with an error message.
        """
        # Create the Message Box
        msgBox = QtWidgets.QMessageBox()
        msgBox.setText(message_text)
        msgBox.setStandardButtons(QtWidgets.QMessageBox.Ok)
        msgBox.setDefaultButton(QtWidgets.QMessageBox.Ok)
        ret = msgBox.exec_()
                    
    def _slotLogSaveAllClicked(self):
        """ Saves all mission data for the session to a new "log" file.
        """
        # Select a Filepath
        directory = os.path.dirname(os.path.realpath(__file__)) + "/Logs/Session Logs/"  # Default Directory

        # Open the Save Dialog
        dialog = QtWidgets.QFileDialog()
        dialog.setDirectory(directory)
        dialog.setFilter(dialog.filter() | QtCore.QDir.Hidden)
        dialog.setDefaultSuffix('log')
        dialog.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
        dialog.setNameFilters(['Log Files (*.log)'])
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            fname = str(dialog.selectedFiles()[0])
        else:
            fname = ""  
            
        # Valid File
        if fname:   
            # Add .log Extension
            if fname[-4:] != ".log":
                fname = fname + ".log"
                            
            # Write to File     
            new_file = open(fname,'w')
            with open(os.path.dirname(os.path.realpath(__file__)) + "/Logs/event.log") as mylogfile:
                
                # Write the Current System Log Contents
                if self.checkBox_log_system_log.isChecked():
                    new_file.write("#########################################################################\n")
                    new_file.write("########################## System Log ##################################\n")
                    new_file.write("#########################################################################\n")
                    new_file.write(mylogfile.read())
                
                # Write the Attack History Contents
                if self.checkBox_log_attack_history.isChecked():
                    new_file.write("#########################################################################\n")
                    new_file.write("########################## Attack History ###############################\n")
                    new_file.write("#########################################################################\n")
                    for rows in range(0, self.tableWidget_attack_attack_history.rowCount()):
                        for columns in range(0, self.tableWidget_attack_attack_history.columnCount()):                  
                            new_file.write(self.tableWidget_attack_attack_history.item(rows, columns).text() + "\t")
                        new_file.write("\n")                
                
                # Write the Session Notes:
                if self.checkBox_log_session_notes.isChecked():
                    new_file.write("#########################################################################\n")
                    new_file.write("########################## Session Notes ################################\n")
                    new_file.write("#########################################################################\n")
                    new_file.write(self.textEdit_log_notes.toPlainText())
                
                # Close the File
                new_file.close()
                    
    def _slotAttackMultiStageAdd(self):
        """ Adds an attack name to the list widget. Capped at 5 for no real reason.
        """
        # Get the Text from the QTreeWidget
        new_attack = self.treeWidget_attack_attacks.currentItem().text(0)
        
        # Ignore Non-Single-Stage Attacks
        ignored_attacks = []
        for n in self.pd_library["Attacks"]["Multi-Stage Attacks"] + self.pd_library["Attacks"]["Fuzzing Attacks"]:
            ignored_attacks.append(n)                      
        categories = ["Single-Stage","Denial of Service","Jamming","Spoofing","Sniffing/Snooping","Probe Attacks","File","Installation of Malware"]  # Might need a way to detect categories
        ignored_attacks += categories
        if any(str(new_attack) in x for x in ignored_attacks):
            pass
                
        # Add to the TableWidget        
        else:   
            if self.tableWidget_attack_multi_stage_attacks.rowCount() < 5: 
                
                # Add Row
                self.tableWidget_attack_multi_stage_attacks.insertRow(self.tableWidget_attack_multi_stage_attacks.rowCount())
                
                # Attack
                attack_item = QtWidgets.QTableWidgetItem(new_attack) 
                attack_item.setTextAlignment(QtCore.Qt.AlignCenter)
                attack_item.setFlags(attack_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,0,attack_item) 
                
                # Protocol
                protocol_item = QtWidgets.QTableWidgetItem(self.comboBox_attack_protocols.currentText())
                protocol_item.setTextAlignment(QtCore.Qt.AlignCenter)
                protocol_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,1,protocol_item)
                
                # Modulation
                modulation_item = QtWidgets.QTableWidgetItem(self.comboBox_attack_modulation.currentText())
                modulation_item.setTextAlignment(QtCore.Qt.AlignCenter)
                modulation_item.setFlags(modulation_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,2,modulation_item)
                
                # Hardware
                get_hardware = str(self.comboBox_attack_hardware.currentText())
                hardware_item = QtWidgets.QTableWidgetItem(get_hardware)
                hardware_item.setTextAlignment(QtCore.Qt.AlignCenter)
                hardware_item.setFlags(hardware_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,3,hardware_item)
                
                # Type (Flow Graph or Python Script)
                get_file_type = list(self.pd_library["Protocols"][str(self.comboBox_attack_protocols.currentText())]["Attacks"][str(new_attack)][str(self.comboBox_attack_modulation.currentText())]["Hardware"][get_hardware].keys())[0]
                type_item = QtWidgets.QTableWidgetItem(get_file_type)
                type_item.setTextAlignment(QtCore.Qt.AlignCenter)
                type_item.setFlags(type_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,4,type_item)
                
                # Duration
                duration_item = QtWidgets.QTableWidgetItem("5") 
                duration_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,5,duration_item)                

                # Get Filename from the Library
                fname = self.pd_library["Protocols"][str(self.comboBox_attack_protocols.currentText())]["Attacks"][str(new_attack)][str(self.comboBox_attack_modulation.currentText())]["Hardware"][get_hardware][get_file_type]                   
                
                # Get the Attack Filepath
                flow_graph_directory = os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/"
                fname = flow_graph_directory + fname
            
                # Adjust Item
                filename_item = QtWidgets.QTableWidgetItem(fname) 
                filename_item.setTextAlignment(QtCore.Qt.AlignCenter)
                filename_item.setFlags(filename_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,6,filename_item)
                
                # Resize            
                self.tableWidget_attack_multi_stage_attacks.setCurrentCell(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,0)
                self.tableWidget_attack_multi_stage_attacks.resizeRowsToContents()
                
                # Enable PushButtons
                if self.tableWidget_attack_multi_stage_attacks.rowCount() > 1:
                    self.pushButton_attack_multi_stage_generate.setEnabled(True)
        
    def _slotAttackMultiStageRemove(self):
        """ Removes the selected attack from the table widget.
        """ 
        # Remove from the TableWidget
        self.tableWidget_attack_multi_stage_attacks.removeRow(self.tableWidget_attack_multi_stage_attacks.currentRow())
        self.tableWidget_attack_multi_stage_attacks.setCurrentCell(self.tableWidget_attack_multi_stage_attacks.rowCount()-1,0)
                
        # Disable PushButtons
        if self.tableWidget_attack_multi_stage_attacks.rowCount() < 2:
            self.pushButton_attack_multi_stage_generate.setEnabled(False)                      
        
    def _slotAttackMultiStageGenerate(self):
        """ Loads each attack from the listbox and populates a table in the tabwidget with flow graph variables.
        """ 
        # Enable Widgets
        self.tabWidget_attack_multi_stage.setEnabled(True)
        self.tabWidget_attack_multi_stage.setCurrentIndex(0)
        self.pushButton_attack_multi_stage_save.setEnabled(True)
        self.pushButton_attack_multi_stage_start.setEnabled(True)
        
        # Remove Tabs
        for n in reversed(range(0,self.tabWidget_attack_multi_stage.count())):
            self.tabWidget_attack_multi_stage.removeTab(n)
        
        # Cycle Through Each Attack in the TableWidget
        self.table_list = []
        for n in range(0,self.tableWidget_attack_multi_stage_attacks.rowCount()):

            # Get the Flow Graph Filepath
            fname = str(self.tableWidget_attack_multi_stage_attacks.item(n,6).text())  # filepath
            filename = fname.rsplit("/",1)[-1]
                
            # If a Valid File
            if fname != "":    
                
                # Create a Table                             
                new_table = QtWidgets.QTableWidget(self)    
                new_table.setColumnCount(1)
                new_table.setRowCount(0)    
                new_table.clearContents()
                new_table.setHorizontalHeaderItem(0,QtWidgets.QTableWidgetItem("Value"))
                new_table.resizeColumnsToContents()
                new_table.horizontalHeader().setStretchLastSection(False) 
                new_table.horizontalHeader().setStretchLastSection(True) 
                self.table_list.append(new_table)
                         
                ftype = str(self.tableWidget_attack_multi_stage_attacks.item(n,4).text()) #"Python2 Script"
                # To Do: Flow Graph - GUI
                if ftype == "Flow Graph":

                    # Read Single-Stage Flow Graph Variables
                    temp_flow_graph_variables = {}
                    f = open(fname,'r')                     
   
                    # Load the Flow Graph Contents into the Table
                    parsing = False
                    for line in f:
                        if line.startswith("        # Variables"):
                            parsing = True
                        elif line.startswith("        # Blocks"):
                            parsing = False
                        if parsing:
                            # Strip Extra Text
                            get_line = line.split('=',1)[-1]
                            get_line = get_line.split('#',1)[0]
                            get_line = get_line.lstrip()
                            
                            if get_line != "":                  
                                # Fill in the "Current Values" Table
                                variable_name = get_line.split(' = ')[0]
                                variable_name_item = QtWidgets.QTableWidgetItem(variable_name)
                                value_text = get_line.split(' = ')[1].rstrip('\n')
                                value_text = value_text.replace('"','')
                                
                                # Replace with Global Constants
                                if variable_name == "ip_address":
                                    value_text = self.dashboard_settings_dictionary['hardware_ip_attack']
                                elif variable_name == "serial":
                                    if len(self.dashboard_settings_dictionary['hardware_serial_attack']) > 0:
                                        if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                            value_text = self.dashboard_settings_dictionary['hardware_serial_attack']
                                        else:
                                            value_text = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_attack']                                
                                    else:
                                        if self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
                                            value_text = ""
                                        else:
                                            value_text = "False"                                    
                                
                                # Fill in the "Current Values" Table
                                value = QtWidgets.QTableWidgetItem(value_text)
                                self.table_list[n].setRowCount(self.table_list[n].rowCount()+1)
                                self.table_list[n].setVerticalHeaderItem(self.table_list[n].rowCount()-1,variable_name_item)   
                                self.table_list[n].setItem(self.table_list[n].rowCount()-1,0,value) 
                                
                                # Add a Filepath Button
                                if 'filepath' in variable_name:
                                    # Add a New Column
                                    if self.table_list[n].columnCount() == 1:
                                        self.table_list[n].horizontalHeader().setStretchLastSection(False)
                                        self.table_list[n].setColumnCount(2)
                                        self.table_list[n].setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                                    
                                    # Create the PushButton
                                    new_pushbutton = QtWidgets.QPushButton(self.table_list[n])
                                    new_pushbutton.setText("...")
                                    new_pushbutton.setFixedSize(34,23)
                                    self.table_list[n].setCellWidget(self.table_list[n].rowCount()-1,1,new_pushbutton)
                                    get_row_number = self.table_list[n].rowCount()-1
                                    get_default_directory = self.defaultAttackFilepathDirectory(str(self.label_selected_flow_graph.text()).rsplit('/')[-1],variable_name)
                                    new_pushbutton.clicked.connect((lambda get_row_number,get_default_directory: lambda: self._slotSelectFilepath(self.tabWidget_attack_multi_stage.currentIndex(), get_row = get_row_number, default_directory = get_default_directory))(get_row_number,get_default_directory))  # Pass constant value, not variable value

                                    # Adjust Table
                                    if self.table_list[n].columnWidth(1) > 65:  # check for iface/guess column width
                                        self.table_list[n].horizontalHeader().setMinimumSectionSize(5)
                                        self.table_list[n].setColumnWidth(1,35) 
                                    self.table_list[n].horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch)                                           
                                    
                                # Add a Guess Interface Button
                                if variable_name == 'iface':
                                    # Add a New Column
                                    if self.table_list[n].columnCount() == 1:
                                        self.table_list[n].horizontalHeader().setStretchLastSection(False)
                                        self.table_list[n].setColumnCount(2)
                                        self.table_list[n].setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                                    
                                    # Create the PushButton
                                    new_pushbutton = QtWidgets.QPushButton(self.table_list[n])
                                    new_pushbutton.setText("Guess")
                                    new_pushbutton.setFixedSize(64,23)
                                    self.table_list[n].setCellWidget(self.table_list[n].rowCount()-1,1,new_pushbutton)
                                    new_pushbutton.clicked.connect(lambda: self._slotGuessInterfaceTableClicked(self.tabWidget_attack_multi_stage.currentIndex()))

                                    # Adjust Table
                                    self.table_list[n].setColumnWidth(1,65) 
                                    self.table_list[n].horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch)
                                    
                    # Close the File
                    f.close()  
                                
                # Python Script
                else:
                    # Get Python2/Python3 Variables
                    flow_graph_directory = os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/"
                    if ftype == "Python3 Script":
                        proc=subprocess.Popen("python3 python_importer.py " + filename.replace('.py',''), shell=True, stdout=subprocess.PIPE, cwd=flow_graph_directory)
                    else:
                        proc=subprocess.Popen("python2 python_importer.py " + filename.replace('.py',''), shell=True, stdout=subprocess.PIPE, cwd=flow_graph_directory)
                    output=ast.literal_eval(proc.communicate()[0].decode())
                    get_vars = output[0]
                    get_vals = output[1]

                    temp_flow_graph_variables = {}
                    for nn in range(0,len(get_vars)):    
                        # Replace with Global Constants
                        if get_vars[nn] == "iface":
                            get_vals[nn] = self.dashboard_settings_dictionary['hardware_interface_attack']
                                              
                        # Fill in the "Current Values" Table
                        variable_name = QtWidgets.QTableWidgetItem(get_vars[nn])
                        value = QtWidgets.QTableWidgetItem(str(get_vals[nn]))
                        self.table_list[n].setRowCount(self.table_list[n].rowCount()+1)
                        self.table_list[n].setVerticalHeaderItem(self.table_list[n].rowCount()-1,variable_name)   
                        self.table_list[n].setItem(self.table_list[n].rowCount()-1,0,value)   

                        # Store Variables and Values to a Dictionary
                        temp_flow_graph_variables[str(variable_name.text())] = str(value.text())

                        # Add a Filepath Button
                        if 'filepath' in str(variable_name.text()):
                            # Add a New Column
                            if self.table_list[n].columnCount() == 1:
                                self.table_list[n].horizontalHeader().setStretchLastSection(False)
                                self.table_list[n].setColumnCount(2)
                                self.table_list[n].setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                            
                            # Create the PushButton
                            new_pushbutton = QtWidgets.QPushButton(self.table_list[n])
                            new_pushbutton.setText("...")
                            if 'iface' in get_vars:
                                new_pushbutton.setFixedSize(64,23)
                            else:
                                new_pushbutton.setFixedSize(34,23)
                            self.table_list[n].setCellWidget(self.table_list[n].rowCount()-1,1,new_pushbutton)
                            get_row_number = self.table_list[n].rowCount()-1
                            get_default_directory = self.defaultAttackFilepathDirectory(str(self.label_selected_flow_graph.text()).rsplit('/')[-1],str(variable_name.text()))
                            new_pushbutton.clicked.connect((lambda get_row_number,get_default_directory: lambda: self._slotSelectFilepath(self.tabWidget_attack_multi_stage.currentIndex(), get_row = get_row_number, default_directory = get_default_directory))(get_row_number,get_default_directory))  # Pass constant value, not variable value

                            # Adjust Table
                            if self.table_list[n].columnWidth(1) > 65:  # check for iface/guess column width
                                self.table_list[n].horizontalHeader().setMinimumSectionSize(5)
                                self.table_list[n].setColumnWidth(1,35) 
                            self.table_list[n].horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch)   
                            
                        # Add a Guess Interface Button
                        if str(variable_name.text()) == 'iface':
                            # Add a New Column
                            if self.table_list[n].columnCount() == 1:
                                self.table_list[n].horizontalHeader().setStretchLastSection(False)
                                self.table_list[n].setColumnCount(2)
                                self.table_list[n].setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                            
                            # Create the PushButton
                            new_pushbutton = QtWidgets.QPushButton(self.table_list[n])
                            new_pushbutton.setText("Guess")
                            new_pushbutton.setFixedSize(64,23)
                            self.table_list[n].setCellWidget(self.table_list[n].rowCount()-1,1,new_pushbutton)
                            new_pushbutton.clicked.connect(lambda: self._slotGuessInterfaceTableClicked(self.tabWidget_attack_multi_stage.currentIndex()))

                            # Adjust Table
                            self.table_list[n].setColumnWidth(1,65) 
                            self.table_list[n].horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch) 
                                                    
                # Adjust Table
                self.table_list[n].resizeRowsToContents()                    
                    
                # Add it to a New Tab       
                new_tab = QtWidgets.QWidget()       
                vBoxlayout  = QtWidgets.QVBoxLayout()
                vBoxlayout.addWidget(self.table_list[n])
                new_tab.setLayout(vBoxlayout)                
                self.tabWidget_attack_multi_stage.addTab(new_tab,self.tableWidget_attack_multi_stage_attacks.item(n,0).text())        
                
        # Update the Status Label       
        self.label_attack_multi_stage_status.setText("Loaded") 
        
    def _slotAttackMultiStageUpClicked(self):
        """ Shifts the row up one position for tableWidget_attack_multi_stage_attacks. This changes the order in which the flow graphs are executed.
        """
        if self.tableWidget_attack_multi_stage_attacks.currentRow() != 0:  # Ignore top row
            # Take the Row Above
            above_item0 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,0)
            above_item1 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,1)
            above_item2 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,2)
            above_item3 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,3)
            above_item4 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,4)
            
            # Take the Current Row
            current_item0 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),0)
            current_item1 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),1)
            current_item2 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),2)
            current_item3 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),3)
            current_item4 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),4)
            
            # Set the Current Row
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),0,above_item0)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),1,above_item1)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),2,above_item2)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),3,above_item3)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),4,above_item4)
            
            # Set the Row Above
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,0,current_item0)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,1,current_item1)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,2,current_item2)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,3,current_item3)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,4,current_item4)
            
            # Change the Selected Row               
            self.tableWidget_attack_multi_stage_attacks.setCurrentCell(self.tableWidget_attack_multi_stage_attacks.currentRow()-1,0)
            
            # Resize
            self.tableWidget_attack_multi_stage_attacks.resizeRowsToContents()
                
    def _slotAttackMultiStageDownClicked(self):
        """ Shifts the row down one position for tableWidget_attack_multi_stage_attacks. This changes the order in which the flow graphs are executed.
        """ 
        # Get Bottom Row
        bottom_row = self.tableWidget_attack_multi_stage_attacks.rowCount()
        
        # Move it Down
        if self.tableWidget_attack_multi_stage_attacks.currentRow() != bottom_row-1:  # Ignore bottom row
            # Take the Row Below
            below_item0 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,0)
            below_item1 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,1)
            below_item2 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,2)
            below_item3 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,3)
            below_item4 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,4)
            
            # Take the Current Row
            current_item0 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),0)
            current_item1 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),1)
            current_item2 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),2)
            current_item3 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),3)
            current_item4 = self.tableWidget_attack_multi_stage_attacks.takeItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),4)
            
            # Set the Current Row
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),0,below_item0)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),1,below_item1)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),2,below_item2)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),3,below_item3)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow(),4,below_item4)
            
            # Set the Row Above
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,0,current_item0)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,1,current_item1)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,2,current_item2)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,3,current_item3)
            self.tableWidget_attack_multi_stage_attacks.setItem(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,4,current_item4)
            
            # Change the Selected Row               
            self.tableWidget_attack_multi_stage_attacks.setCurrentCell(self.tableWidget_attack_multi_stage_attacks.currentRow()+1,0)
            
            # Resize
            self.tableWidget_attack_multi_stage_attacks.resizeRowsToContents()
            
    def _slotAttackMultiStageStartClicked(self):
        """ Sends message to HIPRFISR/FGE to both flow graphs with the specified durations.
        """     
        # Send Stop Message to the HIPRFISR (Flow Graph Currently Running: Stopping)
        if self.pushButton_attack_multi_stage_start.text() == "Stop":
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Multi-Stage Attack', Parameters = '')
            
            # Toggle the Text
            self.pushButton_attack_multi_stage_start.setText("Start")      
            
            # Update the Status Label
            self.label_attack_multi_stage_status.setText("Not Running")
            
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(3,0).setText("Not Running")
            
            # Enable Load/Save
            self.pushButton_attack_multi_stage_load.setEnabled(True)
            self.pushButton_attack_multi_stage_save.setEnabled(True)

        # Reset to Last Known Flow Graph Configuration (Flow Graph Currently Stopped: Starting)
        elif self.pushButton_attack_multi_stage_start.text() == "Start":       
                    
            # Cycle Through Each Tab and Collect the Values
            all_fname_list = []
            all_variable_names_list = []
            all_variable_values_list = []
            all_duration_list = []
            all_file_types_list = []
            for n in range(0,self.tabWidget_attack_multi_stage.count()): 
                
                # Get File Details
                attack_name = str(self.tableWidget_attack_multi_stage_attacks.item(n,0).text())
                protocol = str(self.tableWidget_attack_multi_stage_attacks.item(n,1).text())
                modulation_type = str(self.tableWidget_attack_multi_stage_attacks.item(n,2).text())
                file_type = str(self.tableWidget_attack_multi_stage_attacks.item(n,4).text())       
                    
                # Save the Variable Name and Value in the Row to a List
                variable_names = []
                variable_values = []            
                get_table = self.tabWidget_attack_multi_stage.children()[0].widget(n).children()[1]  # TabWidget>>StackedLayout>>Tab>>Table
                for get_row in range(get_table.rowCount()):     
                    variable_names.append(str(get_table.verticalHeaderItem(get_row).text()))
                    variable_values.append(str(get_table.item(get_row,0).text()))
                                    
                # Append to List of Lists
                all_fname_list.append(str(self.tableWidget_attack_multi_stage_attacks.item(n,6).text()))
                all_variable_names_list.append(variable_names)
                all_variable_values_list.append(variable_values)
                all_duration_list.append(str(self.tableWidget_attack_multi_stage_attacks.item(n,5).text()))
                all_file_types_list.append(file_type)
                
                # Update the Attack History Table 
                self.updateAttackHistory(attack_name, protocol, variable_names, variable_values)  
            
            # Get Repeat Checkbox Value
            get_repeat = self.checkBox_attack_multi_stage_repeat.isChecked()
                            
            # Send "Start Multi-Stage Attack" Message to the HIPRFISR    
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Start Multi-Stage Attack', Parameters = [all_fname_list, all_variable_names_list, all_variable_values_list, all_duration_list, get_repeat, all_file_types_list])  
                
            # Toggle the Text       
            self.pushButton_attack_multi_stage_start.setText("Stop") 
            
            # Update the Status Label
            self.label_attack_multi_stage_status.setText("Running...")
            
            # Update the Status Dialog
            self.status_dialog.tableWidget_status_results.item(3,0).setText("Running Multi-Stage Attack...")
            
            # Disable Load/Save
            self.pushButton_attack_multi_stage_load.setEnabled(False)
            self.pushButton_attack_multi_stage_save.setEnabled(False)
            
    def _slotAttackMultiStageAttackFinished(self):
        """ Changes the pushbuttons and labels upon receiving a message from the FGE.
        """     
        # Change the Pushbuttons and Labels
        self.pushButton_attack_multi_stage_start.setText("Start")  
        self.label_attack_multi_stage_status.setText("Not Running")
        
        # Update the Status Dialog
        self.status_dialog.tableWidget_status_results.item(3,0).setText("Not Running")
    
        # Enable Load/Save
        self.pushButton_attack_multi_stage_load.setEnabled(True)
        self.pushButton_attack_multi_stage_save.setEnabled(True)
    
    def _slotAttackMultiStageLoadClicked(self,fname):
        """ Loads variables from multiple flow graphs into the tables from a custom formatted file.
        """ 
        if fname == "":
            # Look for the Multi-Stage Attack File
            directory = os.path.dirname(os.path.realpath(__file__)) + "/Multi-Stage Attack Files/"  # Default Directory
            fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select Multi-Stage Attack File...", directory, filter="Multi-Stage Attack Files (*.msa);;All Files (*.*)")[0]
            
        # If a Valid File
        if fname != "":
            # Clear the Tabs and Tables
            self.tabWidget_attack_multi_stage.setTabText(0,"")
            self.tabWidget_attack_multi_stage.setTabText(1,"")
            for row0 in reversed(range(0,self.tableWidget_attack_multi_stage_attacks.rowCount())):
                self.tableWidget_attack_multi_stage_attacks.removeRow(row0)
            
            # Remove Existing Tabs
            for n in reversed(range(0,self.tabWidget_attack_multi_stage.count())): 
                self.tabWidget_attack_multi_stage.removeTab(n)
                    
            # Read the File
            f = open(fname, "rb")           
            data = yaml.load(f.read(), yaml.FullLoader)
            attack_table_row_list = data[0]
            attack_name_list = []
            for rows in attack_table_row_list:
                attack_name_list.append(rows[4])
            variable_names_list = data[1]
            variable_values_list = data[2]
            
            # Attack Table
            self.tableWidget_attack_multi_stage_attacks.setRowCount(len(attack_name_list))
            for row in range(0,len(attack_table_row_list)):
                for col in range(0,len(attack_table_row_list[0])):
                    row_value = attack_table_row_list[row][col]
                    row_value_item = QtWidgets.QTableWidgetItem(row_value)
                    row_value_item.setTextAlignment(QtCore.Qt.AlignCenter)              
                    self.tableWidget_attack_multi_stage_attacks.setItem(row,col,row_value_item)                            
            self.tableWidget_attack_multi_stage_attacks.resizeRowsToContents()
            
            # Create Tables and Load in Values
            self.table_list = []
            for n in range(0,len(attack_name_list)):        

                # Create a Table                                
                new_table = QtWidgets.QTableWidget(self)    
                new_table.setColumnCount(1)
                new_table.setRowCount(0)    
                new_table.clearContents()
                new_table.setHorizontalHeaderItem(0,QtWidgets.QTableWidgetItem("Value"))
                new_table.resizeColumnsToContents()
                new_table.horizontalHeader().setStretchLastSection(False)  
                new_table.horizontalHeader().setStretchLastSection(True)  
                self.table_list.append(new_table)  
                                
                # Load the Flow Graph Contents into the Table
                for m in range(0,len(variable_names_list[n])):
                    
                    # Fill in the "Current Values" Table
                    variable_name = QtWidgets.QTableWidgetItem(variable_names_list[n][m])
                    value = QtWidgets.QTableWidgetItem(variable_values_list[n][m])
                    self.table_list[n].setRowCount(self.table_list[n].rowCount()+1)
                    self.table_list[n].setVerticalHeaderItem(self.table_list[n].rowCount()-1,variable_name)   
                    self.table_list[n].setItem(self.table_list[n].rowCount()-1,0,value)  
                    
                    # Add a Filepath Button
                    if 'filepath' in str(variable_name.text()):
                        # Add a New Column
                        if self.table_list[n].columnCount() == 1:
                            self.table_list[n].horizontalHeader().setStretchLastSection(False)
                            self.table_list[n].setColumnCount(2)
                            self.table_list[n].setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                        
                        # Create the PushButton
                        new_pushbutton = QtWidgets.QPushButton(self.table_list[n])
                        new_pushbutton.setText("...")
                        if 'iface' in variable_names_list[n]:
                            new_pushbutton.setFixedSize(64,23)
                        else:
                            new_pushbutton.setFixedSize(34,23)
                        self.table_list[n].setCellWidget(self.table_list[n].rowCount()-1,1,new_pushbutton)
                        get_row_number = self.table_list[n].rowCount()-1
                        get_default_directory = self.defaultAttackFilepathDirectory(str(self.label_selected_flow_graph.text()).rsplit('/')[-1],str(variable_name.text()))
                        new_pushbutton.clicked.connect((lambda get_row_number,get_default_directory: lambda: self._slotSelectFilepath(self.tabWidget_attack_multi_stage.currentIndex(), get_row = get_row_number, default_directory = get_default_directory))(get_row_number,get_default_directory))  # Pass constant value, not variable value

                        # Adjust Table
                        if self.table_list[n].columnWidth(1) > 65:  # check for iface/guess column width
                            self.table_list[n].horizontalHeader().setMinimumSectionSize(5)   
                            self.table_list[n].setColumnWidth(1,35) 
                        self.table_list[n].horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch)                                           
                        
                    # Add a Guess Interface Button
                    if str(variable_name.text()) == 'iface':
                        # Add a New Column
                        if self.table_list[n].columnCount() == 1:
                            self.table_list[n].horizontalHeader().setStretchLastSection(False)
                            self.table_list[n].setColumnCount(2)
                            self.table_list[n].setHorizontalHeaderItem(1,QtWidgets.QTableWidgetItem(""))
                        
                        # Create the PushButton
                        new_pushbutton = QtWidgets.QPushButton(self.table_list[n])
                        new_pushbutton.setText("Guess")
                        new_pushbutton.setFixedSize(64,23)
                        self.table_list[n].setCellWidget(self.table_list[n].rowCount()-1,1,new_pushbutton)
                        new_pushbutton.clicked.connect(lambda: self._slotGuessInterfaceTableClicked(self.tabWidget_attack_multi_stage.currentIndex()))

                        # Adjust Table
                        self.table_list[n].setColumnWidth(1,65) 
                        self.table_list[n].horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch)                                      

                # Adjust Table
                self.table_list[n].resizeRowsToContents()                    
                    
                # Add it to a New Tab       
                new_tab = QtWidgets.QWidget()       
                vBoxlayout  = QtWidgets.QVBoxLayout()
                vBoxlayout.addWidget(self.table_list[n])
                new_tab.setLayout(vBoxlayout)                                   
                self.tabWidget_attack_multi_stage.addTab(new_tab,self.tableWidget_attack_multi_stage_attacks.item(n,0).text())        
                
            # Close the File   
            f.close()           
            
            # Enable the Controls
            self.pushButton_attack_multi_stage_save.setEnabled(True)
            self.tabWidget_attack_multi_stage.setEnabled(True)
            self.pushButton_attack_multi_stage_start.setEnabled(True)
            self.label_attack_multi_stage_status.setEnabled(True)
            self.label_attack_multi_stage_status.setText("Loaded")
    
        
    def _slotAttackMultiStageSaveClicked(self):
        """ Saves flow graph variables and values from the tables to a custom formatted file.
        """     
        # Select a Filepath
        directory = os.path.dirname(os.path.realpath(__file__)) + "/Multi-Stage Attack Files/"  # Default Directory

        # This Method Allows ".msa" to be Added to the End of the Name
        dialog = QtWidgets.QFileDialog()
        dialog.setDirectory(directory)
        dialog.setFilter(dialog.filter() | QtCore.QDir.Hidden)
        dialog.setDefaultSuffix('msa')
        dialog.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
        dialog.setNameFilters(['Multi-Stage Attack Files (*.msa)'])
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            fileName = str(dialog.selectedFiles()[0])
        else:
            print('Cancelled')  
            fileName = ""   
        
        # Valid file
        if fileName:
            # Get the File
            file = open(fileName,"wb")
                            
            # Get Single-Stage Attacks Table
            attack_table_row = []
            attack_table_row_list = []
            for row in range(0,self.tableWidget_attack_multi_stage_attacks.rowCount()):
                for col in range(0,self.tableWidget_attack_multi_stage_attacks.columnCount()):
                    attack_table_row.append(str(self.tableWidget_attack_multi_stage_attacks.item(row,col).text()))                 
                attack_table_row_list.append(attack_table_row)
                attack_table_row = []       
                                            
            # Go Through Each Tab
            attack_name_list = []
            variable_names = []
            variable_values = []
            variable_names_list = []
            variable_values_list = []
            for tab in range(0,self.tabWidget_attack_multi_stage.count()):
                            
                # Get the Flow Graph Table
                get_table = self.tabWidget_attack_multi_stage.children()[0].widget(tab).children()[1]  # TabWidget>>StackedLayout>>Tab>>Table
                            
                # Get Flow Graph Table Values
                for get_row in range(get_table.rowCount()):             
                    # Save the Variable Name and Value in the Row to a Dictionary
                    variable_names.append(str(get_table.verticalHeaderItem(get_row).text()))
                    variable_values.append(str(get_table.item(get_row,0).text()))               
                variable_names_list.append(variable_names)
                variable_values_list.append(variable_values)
                variable_names = []
                variable_values = []
                
            # Assemble the Data into a File Format  
            formatted_data = "- " + str(attack_table_row_list) + "\n- " + str(variable_names_list) + "\n- " + str(variable_values_list)
                                    
            # Write to File
            file.write(formatted_data)
            file.close()                    
                
    def _slotPacketAppendClicked(self):
        """ Appends the contents of the packet scratchpad (with the multiplier) to the assembled text edit box.
        """
        # Get the Assembled Packet Text
        scratch_pad_text = str(self.textEdit_packet_assembled.toPlainText())
        
        # Get the Text Multiplier
        try:
            text_multiplier = int(str(self.textEdit_packet_number_of_messages.toPlainText()))
            if text_multiplier < 1:
                text_multipler = 1
                self.textEdit_packet_number_of_messages.setText("1")
            
            # Create a Repeated Message
            repeated_message = ""
            for n in range(0,text_multiplier):
                repeated_message += scratch_pad_text
                
            # Append to the Constructed Sequence
            get_assembled_text = str(self.textEdit_packet_constructed.toPlainText())
            get_assembled_text += repeated_message
            
            # Update the Constructed Sequence
            self.textEdit_packet_constructed.setText(get_assembled_text)
        except:
            self.errorMessage("Enter a Valid Multiplier (Counting Number)")     
            
    def _slotAttackModulationChanged(self):
        """ This is called whenever the attack modulation combobox is changed. It is used to adjust label text.
        """     
        try:
            # Get the Protocol and Modulation 
            current_protocol = str(self.comboBox_attack_protocols.currentText())
            current_modulation = str(self.comboBox_attack_modulation.currentText())

            # Set Label Text
            self.label_attack_fuzzing_selected_modulation.setText(current_modulation)

            # Modulation is Chosen
            if current_modulation != "":
                
                # Hide/Unhide All Attacks, Disable All Attacks
                iterator = QtWidgets.QTreeWidgetItemIterator(self.treeWidget_attack_attacks)
                while iterator.value():
                    item = iterator.value()
                    if self.checkBox_attack_show_all.isChecked():
                        item.setHidden(False)                
                    else:
                        item.setHidden(True)    
                    item.setDisabled(True)
                                    
                    # Update Iterator                    
                    iterator+=1
                
                # Enable the Selections
                get_attacks = self.pd_library["Protocols"][current_protocol]["Attacks"]
                get_hardware = str(self.comboBox_attack_hardware.currentText())

                for n in get_attacks:
                    if current_modulation in self.pd_library["Protocols"][current_protocol]["Attacks"][n]:
                        if get_hardware in self.pd_library["Protocols"][current_protocol]["Attacks"][n][current_modulation]["Hardware"]:
                            self.treeWidget_attack_attacks.findItems(n,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setDisabled(False)
                            self.treeWidget_attack_attacks.findItems(n,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setHidden(False) 
                            self.enableAttackTreeParents(n)
                     
                # Always Enabled
                for n in ['Single-Stage', 'Multi-Stage', 'New Multi-Stage', 'Fuzzing', 'Variables']:            
                    self.treeWidget_attack_attacks.findItems(n,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setDisabled(False)
                    self.treeWidget_attack_attacks.findItems(n,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setHidden(False)
                    
                # Expand the Tree Widget
                self.treeWidget_attack_attacks.expandAll() 
                
                # Select the Top Item
                self.treeWidget_attack_attacks.setCurrentItem(self.treeWidget_attack_attacks.topLevelItem(0))
                
        except:
            #No packet types!
            pass       
            
    def enableAttackTreeParents(self, attack):
        """ Finds and enables the parents of an attack in the attack tree widget.
        """
        # Find the Parents
        attack_index = -1
        parents = []
        for n in reversed(self.pd_library['Attacks']['Single-Stage Attacks']):
            if attack == n.split(',')[0]:
                attack_index = int(n.split(',')[1])
            if int(n.split(',')[1]) == (attack_index-1):
                parents.append(n.split(',')[0])
                attack_index = attack_index - 1
        
        # Enable the Parents
        for p in parents:
            self.treeWidget_attack_attacks.findItems(p,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setDisabled(False)
            self.treeWidget_attack_attacks.findItems(p,QtCore.Qt.MatchExactly|QtCore.Qt.MatchRecursive,0)[0].setHidden(False)
            
    def slotAttackHardwareChanged(self):
        """ Updates the attack tree widget and is used to run attacks.
        """
        self._slotAttackModulationChanged()     
        
    def _slotMenuLoadConfigurationClicked(self):
        """ Replaces the fissure_config.yaml with another YAML file. The dashboard reloads itself with the new settings. Should it inform the other components? TODO
        """
        # Look for a YAML File
        directory = os.path.dirname(os.path.realpath(__file__)) + "/YAML/User Configs/"  # Default Directory
        fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select Configuration File...", directory, filter="Configuration Files (*.yaml);;All Files (*.*)")[0]

        # If a Valid File
        if fname != "":
            # Load Settings from YAML File
            yaml_config_file = open(fname)
            self.dashboard_settings_dictionary = yaml.load(yaml_config_file, yaml.FullLoader)
            yaml_config_file.close()   
            
            # Dump Dictionary to File
            stream = open(os.path.dirname(os.path.realpath(__file__)) + '/YAML/fissure_config.yaml', 'w')
            yaml.dump(self.dashboard_settings_dictionary, stream, default_flow_style=False, indent=5)  

            # Update Settings Across Components
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Update FISSURE Configuration')
            
            # Update Hardware
            self.configureTSI_Hardware()
            self.configurePD_Hardware()
            self.configureAttackHardware()
            self.configureIQ_Hardware()
            self.configureArchiveHardware()

        
    def _slotMenuSaveConfigurationClicked(self):
        """ Saves a new formatted YAML file with all the system configuration variables and values.
        """
        # Select a Filepath
        directory = os.path.dirname(os.path.realpath(__file__)) + "/YAML/User Configs/"  # Default Directory

        # This Method Allows ".yaml" to be Added to the End of the Name
        dialog = QtWidgets.QFileDialog()
        dialog.setDirectory(directory)
        dialog.setFilter(dialog.filter() | QtCore.QDir.Hidden)
        dialog.setDefaultSuffix('yaml')
        dialog.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
        dialog.setNameFilters(['Configuration Files (*.yaml)'])
        if dialog.exec_() == QtWidgets.QDialog.Accepted:
            file_name = str(dialog.selectedFiles()[0])
        else:
            file_name = ""   
        
        # Valid file
        if file_name:
            # Dump Dictionary to File
            stream = open(file_name, 'w')
            yaml.dump(self.dashboard_settings_dictionary, stream, default_flow_style=False, indent=5)                       
                
    def _slotSelectFilepath(self, table_index, get_row=-1, default_directory=os.path.dirname(os.path.realpath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/Attack Files/"):
        """ Allows the user to browse for a file for any flow graph variables named "filepath."
        """
        # Single-Stage or Multi-Stage Table
        if table_index > -1:
            get_table = self.table_list[table_index]
        else:
            get_table = self.tableWidget_attack_flow_graph_current_values
        
        # Look for a File
        fname = QtWidgets.QFileDialog.getSaveFileName(None,"Select File...", default_directory, filter="All Files (*)")[0]
          
        # Valid File
        if fname != "":
                                
            # Put it Back in the Table
            if get_row >= 0:
                new_text_item = QtWidgets.QTableWidgetItem(str(fname))
                get_table.setItem(get_row,0,new_text_item)
                
    def _slotGuessInterfaceTableClicked(self,table_index):
        """ Automatically inserts the wireless interface name into the attack attack table.
        """
        # Single-Stage or Multi-Stage Table
        if table_index > -1:
            get_table = self.table_list[table_index]
        else:
            get_table = self.tableWidget_attack_flow_graph_current_values
            
        # Find Row with "iface" 
        get_row = -1
        for rows in range(0,get_table.rowCount()):
            if get_table.verticalHeaderItem(rows).text() == "iface":
                get_row = rows
                break
               
        # Look for Existing Text                     
        get_text = ""
        if get_row != -1:
            get_text = str(get_table.item(get_row,0).text())
                        
            # Get the iwconfig Text
            proc=subprocess.Popen("iwconfig &", shell=True, stdout=subprocess.PIPE, )
            output=proc.communicate()[0].decode()

            # Reset Interface Index
            if len(get_text) == 0:
                self.guess_index_table = 0
            else:
                self.guess_index_table = self.guess_index_table + 1
            
            # Pull the Interfaces
            lines = output.split('\n')
            get_interface = ''
            wifi_interfaces = []
            for n in range(0,len(lines)):
                if 'ESSID' in lines[n]:
                    wifi_interfaces.append(lines[n].split(' ',1)[0])
            
            # Found an Interface
            if len(wifi_interfaces) > 0:
                
                # Check Interface Index
                if self.guess_index_table > (len(wifi_interfaces)-1):
                    self.guess_index_table = 0        
                
                # Update the Table
                get_interface = wifi_interfaces[self.guess_index_table]
                   
                # Find the Row
                get_row = -1
                for rows in range(0,get_table.rowCount()):
                    if get_table.verticalHeaderItem(rows).text() == "iface":
                        get_row = rows
                        break
                        
                # Put it Back in the Table
                if get_row != -1:
                    new_text_item = QtWidgets.QTableWidgetItem(get_interface)
                    get_table.setItem(get_row,0,new_text_item)
            

    def _slotAttackFuzzingSelectFilepath(self, get_row=-1, default_directory=os.path.dirname(os.path.realpath(__file__)) +"/Flow Graph Library/Single-Stage Flow Graphs/Attack Files/"):
        """ Allows the user to browse for a file for any flow graph variables named "filepath." This is directed towards the Fuzzing-Variables Current Values table.
        """
        # Look for a File
        fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select File...", default_directory, filter="All Files (*)")[0]

        # Valid File
        if fname != "":                    
            # Put it Back in the Table
            if get_row >= 0:
                new_text_item = QtWidgets.QTableWidgetItem(str(fname))
                self.tableWidget_attack_fuzzing_flow_graph_current_values.setItem(get_row,0,new_text_item)     
                
    def _slotAttackMultiStageSelectFilepath(self, get_row=-1, default_directory=os.path.dirname(os.path.realpath(__file__)) +"/Flow Graph Library/Single-Stage Flow Graphs/Attack Files/"):
        """ Allows the user to browse for a file for any flow graph variables named "filepath." This is directed towards the Multi-Stage Flow Graph 1 Current Values table.
        """
        # Look for a File
        fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select File...", default_directory, filter="All Files (*)")[0]

        # Valid File
        if fname != "":
            # Get the Current Table
            tab = self.tabWidget_attack_multi_stage.currentIndex()
            get_table = self.tabWidget_attack_multi_stage.children()[0].widget(tab).children()[1]  # TabWidget>>StackedLayout>>Tab>>Table
                                
            # Put it Back in the Table
            if get_row >= 0:
                new_text_item = QtWidgets.QTableWidgetItem(str(fname))
                get_table.setItem(get_row,0,new_text_item)  
                
    def _slotAttackHistoryDeleteClicked(self):
        """ Deletes the currently selected row from the attack history table.
        """
        # Remove the Current Row
        self.tableWidget_attack_attack_history.removeRow(self.tableWidget_attack_attack_history.currentRow())
        
    def _slotAttackMultiStageClearClicked(self):
        """ Clears the attack table.
        """
        # Clear Previous Attack Table
        for n in reversed(range(0,self.tabWidget_attack_multi_stage.count())):
            self.tabWidget_attack_multi_stage.removeTab(n)     
        
    def _slotPacketItemChanged(self, row, col):
        """ This is called whenever an item in the packet editor table is changed. It is used to update the current lengths of the fields.
        """
        # Only Look at the Data Column
        if col == 1:
            # Ignore Item Changes by the System
            if self.tableWidget_attack_packet_editor.cellWidget(self.tableWidget_attack_packet_editor.currentRow(),0) != None:  
                    
                # Ignore Strings
                if self.tableWidget_attack_packet_editor.cellWidget(self.tableWidget_attack_packet_editor.currentRow(),0).currentText() == "String":
                    pass
                else:
                    # Get the Current Item
                    current_item = self.tableWidget_attack_packet_editor.item(self.tableWidget_attack_packet_editor.currentRow(),1)
                    
                    # Binary or Hex
                    if self.tableWidget_attack_packet_editor.cellWidget(self.tableWidget_attack_packet_editor.currentRow(),0).currentText() == "Binary":
                        get_length_str = str(current_item.text()).replace(" ","")
                        get_length = len(get_length_str)
                    else:
                        get_length = 4*len(str(current_item.text()))
                        
                    # Update the Current Length Label     
                    new_length_item = QtWidgets.QTableWidgetItem(str(get_length)) 
                    new_length_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    new_length_item.setFlags(new_length_item.flags() & ~QtCore.Qt.ItemIsEditable)
                    self.tableWidget_attack_packet_editor.setItem(self.tableWidget_attack_packet_editor.currentRow(),2,new_length_item)
                    
                    # Calculate the Lengths
                    current_length_total = 0
                    for n in range(0,self.tableWidget_attack_packet_editor.rowCount()):
                        current_length_total += int(self.tableWidget_attack_packet_editor.item(n,2).text())
                    self.label_packet_current_length_total.setText(str(current_length_total))
            
    def _slotAttackFuzzingItemChanged(self, row, col):
        """ This is called whenever an item in the fuzzing fields table is changed. It is used to update the current lengths of the fields.
        """
        # Only Look at the Data Column
        if col == 5:
            
            # Ignore Item Changes by the System
            if self.tableWidget_attack_fuzzing_data_field.cellWidget(self.tableWidget_attack_fuzzing_data_field.currentRow(),4) != None:  
                          
                # Get the Current Item
                current_item = self.tableWidget_attack_fuzzing_data_field.item(self.tableWidget_attack_fuzzing_data_field.currentRow(),5)
                
                # Binary or Hex
                if self.tableWidget_attack_fuzzing_data_field.cellWidget(self.tableWidget_attack_fuzzing_data_field.currentRow(),4).currentText() == "Binary":
                    get_length_str = str(current_item.text()).replace(" ","")
                    get_length = len(get_length_str)
                else:
                    get_length = 4*len(str(current_item.text()))
                    
                # Update the Length Label     
                new_length_item = QtWidgets.QTableWidgetItem(str(get_length)) 
                new_length_item.setTextAlignment(QtCore.Qt.AlignCenter)
                new_length_item.setFlags(new_length_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_attack_fuzzing_data_field.setItem(self.tableWidget_attack_fuzzing_data_field.currentRow(),6,new_length_item)
                
                # Calculate the Lengths
                current_length_total = 0
                for n in range(0,self.tableWidget_attack_fuzzing_data_field.rowCount()):
                    current_length_total += int(self.tableWidget_attack_fuzzing_data_field.item(n,6).text())
                self.label_attack_fuzzing_current_length_total.setText(str(current_length_total))
        
    def _slotLibraryAddAttacksSelectClicked(self):
        """ This opens a file dialog to select a .py or .msa file as the source of the new attack template.
        """
        # Look for the Flow Graph Files or Multi-Stage Attack File
        directory = ""
        dialog_text = ""
        dialog_filter = ""
        if self.comboBox_library_attacks_attack_type.currentText() == "Multi-Stage":
            directory = os.path.dirname(os.path.realpath(__file__)) + "/Multi-Stage Attack Files/"
            dialog_text = "Select Multi-Stage Attack File..."
            dialog_filter = "Multi-Stage Attack Files (*.msa)"
        else:
            directory = os.path.dirname(os.path.realpath(__file__)) + "/"    
            dialog_text = "Select Python File..."
            dialog_filter = "Python Files (*.py)"
            
        fpath = str(QtWidgets.QFileDialog.getOpenFileName(None,dialog_text, directory, filter=dialog_filter)[0])

        # If a Valid File
        if fpath != "":
            fname = fpath.rsplit("/",1)[1]
            fname = fname.rsplit(".py",1)[0]
            fname = fname.rsplit(".msa",1)[0]
            self.label_library_attacks_filepath.setText(fpath)
            self.textEdit_library_attacks_new_name.setPlainText(fname)
            
            self.textEdit_library_attacks_name.setPlainText(fname)
            self.textEdit_library_attacks_new_name.setPlainText(fpath.rsplit("/",1)[1])
        else:
            if self.textEdit_library_attacks_name.toPlainText() != "":
                pass
 
        
    def _slotAttackImportAttackTypeChanged(self):
        """ This changes the items in the attack tree parent combobox to reflect single-stage or multi-stage categories.
        """
        # Add New Items
        self.comboBox_library_attacks_subcategory.clear()
        if self.comboBox_library_attacks_attack_type.currentText() == "Single-Stage":
            self.comboBox_library_attacks_subcategory.addItems(["Denial of Service","Jamming","Spoofing","Sniffing/Snooping","Probe Attacks","Installation of Malware","Misuse of Resources","File"])
            self.label_library_attacks_new_name.setHidden(False)
            self.label_library_attacks_new_name2.setHidden(False)
            self.textEdit_library_attacks_new_name.setHidden(False)
            self.label_library_attacks_file_select.setText(".py File:")
            self.label_library_attacks_modulation.setHidden(False)
            self.comboBox_library_attacks_modulation.setHidden(False)            
            
        # elif self.comboBox_library_attacks_attack_type.currentText() == "Multi-Stage":
            # self.comboBox_library_attacks_subcategory.addItems(["Multi-Stage"])
            # self.label_library_attacks_new_name.setHidden(True)
            # self.label_library_attacks_new_name2.setHidden(True)
            # self.textEdit_library_attacks_new_name.setHidden(True)
            # self.label_library_attacks_file_select.setText(".msa File:")
            # self.label_library_attacks_modulation.setHidden(True)
            # self.comboBox_library_attacks_modulation.setHidden(True)
         
        # Reset State
        self.label_library_attacks_filepath.setText("")
        self.textEdit_library_attacks_name.setPlainText("")
        self.textEdit_library_attacks_new_name.setPlainText("")          
        
    def _slotAttackImportProtocolChanged(self):
        """ This changes the items in the modulation combobox to reflect the currently selected protocol.
        """                       
        # Update Comboboxes     
        self.comboBox_library_attacks_modulation.clear()
        get_protocol = str(self.comboBox_library_pd_protocol.currentText())
        if get_protocol != "":
            try:
                modulation_types = self.pd_library["Protocols"][get_protocol]["Modulation Types"]
                self.comboBox_library_attacks_modulation.addItems(modulation_types)
            # No Modulation Types Available
            except KeyError:
                pass                

    def _slotLibraryAddAddFieldClicked(self):
        """ Adds a new row to the library packet table in the protocol discovery\add to library packet tab.
        """
        # Add Row
        self.tableWidget_library_pd_packet.setRowCount(self.tableWidget_library_pd_packet.rowCount()+1)
        header_item = QtWidgets.QTableWidgetItem("Field " + str(self.tableWidget_library_pd_packet.rowCount()))
        header_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_library_pd_packet.setVerticalHeaderItem(self.tableWidget_library_pd_packet.rowCount()-1,header_item)
        
        # CRC Range
        crc_range_item = QtWidgets.QTableWidgetItem("") 
        crc_range_item.setTextAlignment(QtCore.Qt.AlignCenter)
        crc_range_item.setFlags(crc_range_item.flags() ^ QtCore.Qt.ItemIsEnabled)
        crc_range_item.setFlags(crc_range_item.flags() ^ QtCore.Qt.ItemIsEditable)
        self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.rowCount()-1,4,crc_range_item)   
        
        # Is CRC Combobox
        new_combobox = QtWidgets.QComboBox(self)
        new_combobox.addItem("True")
        new_combobox.addItem("False")        
        new_combobox.setCurrentIndex(1)
        self.tableWidget_library_pd_packet.setCellWidget(self.tableWidget_library_pd_packet.rowCount()-1,3,new_combobox)
        new_combobox.currentIndexChanged.connect(self._slotPD_AddToLibraryIsCRC_Changed)
        new_combobox.setProperty("row", self.tableWidget_library_pd_packet.rowCount()-1)    

        # Resize the Table
        self.tableWidget_library_pd_packet.resizeRowsToContents()        
        self.tableWidget_library_pd_packet.setColumnWidth(0,125) 
        self.tableWidget_library_pd_packet.setColumnWidth(1,100) 
        self.tableWidget_library_pd_packet.setColumnWidth(3,75)
        self.tableWidget_library_pd_packet.setColumnWidth(4,130)
        self.tableWidget_library_pd_packet.horizontalHeader().setSectionResizeMode(2,QtWidgets.QHeaderView.Stretch)  
        
    def _slotPD_AddToLibraryIsCRC_Changed(self):
        """ Enable/Disable the "CRC Range" item in the protocol discovery add to library packet type table based on "Is CRC" value.
        """
        # Get Row, Value
        row = self.sender().property("row")  # FIX
        current_selection = self.tableWidget_library_pd_packet.cellWidget(row,3).currentText()
        
        # Enable
        if current_selection == "True":
            self.tableWidget_library_pd_packet.item(row,4).setFlags(self.tableWidget_library_pd_packet.item(row,4).flags() ^ QtCore.Qt.ItemIsEnabled)
            self.tableWidget_library_pd_packet.item(row,4).setFlags(self.tableWidget_library_pd_packet.item(row,4).flags() ^ QtCore.Qt.ItemIsEditable)
        
        # Disable
        else:
            self.tableWidget_library_pd_packet.item(row,4).setText("")  # Clear existing text
            self.tableWidget_library_pd_packet.item(row,4).setFlags(self.tableWidget_library_pd_packet.item(row,4).flags() ^ QtCore.Qt.ItemIsEnabled)
            self.tableWidget_library_pd_packet.item(row,4).setFlags(self.tableWidget_library_pd_packet.item(row,4).flags() ^ QtCore.Qt.ItemIsEditable)
            
    def _slotLibraryAddRemoveFieldClicked(self):
        """ Removes the current row from the library packet table in the protocol discovery\construct packet tab.
        """
        # Remove Row
        self.tableWidget_library_pd_packet.removeRow(self.tableWidget_library_pd_packet.currentRow())
    
        # Relabel the Rows
        for rows in range(0,self.tableWidget_library_pd_packet.rowCount()):
            header_item = QtWidgets.QTableWidgetItem("Field " + str(rows+1))
            header_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_library_pd_packet.setVerticalHeaderItem(rows,header_item)    
        
        # Resize
        self.tableWidget_library_pd_packet.resizeRowsToContents()  
            
    def _slotLibraryAddUpClicked(self):
        """ Moves the current field up one position in the field table.
        """
        if self.tableWidget_library_pd_packet.currentRow() != 0:  # Ignore top row
            # Take the Row Above
            above_item0 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow()-1,0)
            above_item1 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow()-1,1)
            above_item2 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow()-1,2)
            
            # Take the Current Row
            current_item0 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow(),0)
            current_item1 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow(),1)
            current_item2 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow(),2)
            
            # Set the Current Row
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow(),0,above_item0)
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow(),1,above_item1)
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow(),2,above_item2)
            
            # Set the Row Above
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow()-1,0,current_item0)
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow()-1,1,current_item1)
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow()-1,2,current_item2)
            
            # Change the Selected Row               
            self.tableWidget_library_pd_packet.setCurrentCell(self.tableWidget_library_pd_packet.currentRow()-1,0)
            
            # Resize
            self.tableWidget_library_pd_packet.resizeRowsToContents()
                
        
    def _slotLibraryAddDownClicked(self):
        """ Moves the current field down one position in the field table.
        """        
        # Get Bottom Row
        bottom_row = self.tableWidget_library_pd_packet.rowCount()
        
        # Move it Down
        if self.tableWidget_library_pd_packet.currentRow() != bottom_row-1:  # Ignore bottom row
            # Take the Row Below
            below_item0 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow()+1,0)
            below_item1 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow()+1,1)
            below_item2 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow()+1,2)
            
            # Take the Current Row
            current_item0 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow(),0)
            current_item1 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow(),1)
            current_item2 = self.tableWidget_library_pd_packet.takeItem(self.tableWidget_library_pd_packet.currentRow(),2)
            
            # Set the Current Row
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow(),0,below_item0)
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow(),1,below_item1)
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow(),2,below_item2)
            
            # Set the Row Above
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow()+1,0,current_item0)
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow()+1,1,current_item1)
            self.tableWidget_library_pd_packet.setItem(self.tableWidget_library_pd_packet.currentRow()+1,2,current_item2)
            
            # Change the Selected Row               
            self.tableWidget_library_pd_packet.setCurrentCell(self.tableWidget_library_pd_packet.currentRow()+1,0)
            
            # Resize
            self.tableWidget_library_pd_packet.resizeRowsToContents()    
            
    def _slotPD_DissectorsAddFieldClicked(self):
        """ Adds a new row to the Dissectors table in the Dissectors tab.
        """
        # Add Row
        self.tableWidget_pd_dissectors.setRowCount(self.tableWidget_pd_dissectors.rowCount()+1)
        header_item = QtWidgets.QTableWidgetItem("Field" + str(self.tableWidget_pd_dissectors.rowCount()))
        new_font = QtGui.QFont("Ubuntu",10)
        header_item.setFont(new_font)
        header_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_pd_dissectors.setVerticalHeaderItem(self.tableWidget_pd_dissectors.rowCount()-1,header_item)
        
        # Display Name
        table_item = QtWidgets.QTableWidgetItem("New Field")
        table_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.rowCount()-1,0,table_item)
        
        # Filter Name
        table_item = QtWidgets.QTableWidgetItem("new_field")
        table_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.rowCount()-1,1,table_item)
        
        # Type ComboBox
        new_combobox = QtWidgets.QComboBox(self)
        new_combobox.setSizeAdjustPolicy(0)
        new_combobox.addItem("ftypes.NONE")
        new_combobox.addItem("ftypes.BOOLEAN")
        new_combobox.addItem("ftypes.CHAR")
        new_combobox.addItem("ftypes.UINT8")
        new_combobox.addItem("ftypes.UINT16")
        new_combobox.addItem("ftypes.UINT24")
        new_combobox.addItem("ftypes.UINT32")
        new_combobox.addItem("ftypes.UINT64")
        new_combobox.addItem("ftypes.INT8")
        new_combobox.addItem("ftypes.INT16")
        new_combobox.addItem("ftypes.INT24")
        new_combobox.addItem("ftypes.INT32")
        new_combobox.addItem("ftypes.INT64")
        new_combobox.addItem("ftypes.FLOAT")
        new_combobox.addItem("ftypes.DOUBLE")
        new_combobox.addItem("ftypes.ABSOLUTE_TIME")
        new_combobox.addItem("ftypes.RELATIVE_TIME")
        new_combobox.addItem("ftypes.STRING")
        new_combobox.addItem("ftypes.STRINGZ")
        new_combobox.addItem("ftypes.UINT_STRING")
        new_combobox.addItem("ftypes.ETHER")
        new_combobox.addItem("ftypes.BYTES")
        new_combobox.addItem("ftypes.UINT_BYTES")
        new_combobox.addItem("ftypes.IPv4")
        new_combobox.addItem("ftypes.IPv6")        
        new_combobox.addItem("ftypes.IPXNET")        
        new_combobox.addItem("ftypes.FRAMENUM")
        new_combobox.addItem("ftypes.PCRE")
        new_combobox.addItem("ftypes.GUID")  
        new_combobox.addItem("ftypes.OID")
        new_combobox.addItem("ftypes.PROTOCOL")
        new_combobox.addItem("ftypes.REL_OID")
        new_combobox.addItem("ftypes.SYSTEM_ID")
        new_combobox.addItem("ftypes.EUI64")
        new_combobox.setCurrentIndex(0)
        new_combobox.currentIndexChanged.connect(self._slotPD_DissectorsTypeChanged)
        self.tableWidget_pd_dissectors.setCellWidget(self.tableWidget_pd_dissectors.rowCount()-1,2,new_combobox)
        
        # Display ComboBox
        new_combobox2 = QtWidgets.QComboBox(self)
        new_combobox2.setSizeAdjustPolicy(0)
        new_combobox2.addItem("base.NONE")
        new_combobox2.addItem("base.DEC")
        new_combobox2.addItem("base.HEX")
        new_combobox2.addItem("base.OCT")
        new_combobox2.addItem("base.DEC_HEX")
        new_combobox2.addItem("base.HEX_DEC")
        new_combobox2.addItem("base.UINT_STRING")
        new_combobox2.addItem("base.RANGE_STRING")        
        #new_combobox2.addItem("BASE_CUSTOM")  # Not listed for Lua ProtoField
        #new_combobox2.addItem("STR_ASCII")  # Same as BASE_NONE
        #new_combobox2.addItem("STR_UNICODE")
        #new_combobox2.addItem("BASE_EXT_STRING")
        #new_combobox2.addItem("BASE_VAL64_STRING")        
        new_combobox2.setCurrentIndex(0)
        self.tableWidget_pd_dissectors.setCellWidget(self.tableWidget_pd_dissectors.rowCount()-1,3,new_combobox2)
        
        # Bitmask
        table_item = QtWidgets.QTableWidgetItem("")
        table_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.rowCount()-1,4,table_item)
        
        # Buffer  
        table_item = QtWidgets.QTableWidgetItem("(,)")
        table_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.rowCount()-1,5,table_item)

        # Resize
        self.tableWidget_pd_dissectors.resizeColumnsToContents()
        self.tableWidget_pd_dissectors.horizontalHeader().setStretchLastSection(False) 
        self.tableWidget_pd_dissectors.horizontalHeader().setStretchLastSection(True) 
        self.tableWidget_pd_dissectors.resizeRowsToContents() 
        
        # Disable ftypes.NONE for ftypes.BYTES
        self._slotPD_DissectorsTypeChanged()
                    
    def _slotPD_DissectorsRemoveFieldClicked(self):
        """ Removes the current row in the dissector table in the Dissectors tab.
        """
        # Remove Row
        self.tableWidget_pd_dissectors.removeRow(self.tableWidget_pd_dissectors.currentRow())
    
        # Relabel the Rows
        new_font = QtGui.QFont("Ubuntu",10)
        for rows in range(0,self.tableWidget_pd_dissectors.rowCount()):
            header_item = QtWidgets.QTableWidgetItem("Field" + str(rows+1))
            header_item.setFont(new_font)
            header_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_pd_dissectors.setVerticalHeaderItem(rows,header_item)    
        
        # Resize
        self.tableWidget_pd_dissectors.resizeColumnsToContents() 
        self.tableWidget_pd_dissectors.horizontalHeader().setStretchLastSection(False)
        self.tableWidget_pd_dissectors.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_pd_dissectors.resizeRowsToContents() 
            
    def _slotPD_DissectorsUpClicked(self):
        """ Moves the current field up one position in the field table.
        """
        if self.tableWidget_pd_dissectors.currentRow() != 0:  # Ignore top row
            # Take the Row Above
            above_item0 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow()-1,0)
            above_item1 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow()-1,1)
            above_item2 = self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow()-1,2).currentIndex()
            above_item3 = self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow()-1,3).currentIndex()
            above_item4 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow()-1,4)
            above_item5 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow()-1,5)
            
            # Take the Current Row
            current_item0 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow(),0)
            current_item1 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow(),1)
            current_item2 = self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow(),2).currentIndex()
            current_item3 = self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow(),3).currentIndex()
            current_item4 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow(),4)
            current_item5 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow(),5)
            
            # Set the Current Row
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow(),0,above_item0)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow(),1,above_item1)
            self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow(),2).setCurrentIndex(above_item2)
            self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow(),3).setCurrentIndex(above_item3)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow(),4,above_item4)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow(),5,above_item5)
            
            # Set the Row Above
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow()-1,0,current_item0)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow()-1,1,current_item1)
            self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow()-1,2).setCurrentIndex(current_item2)
            self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow()-1,3).setCurrentIndex(current_item3)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow()-1,4,current_item4)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow()-1,5,current_item5)
            
            # Change the Selected Row               
            self.tableWidget_pd_dissectors.setCurrentCell(self.tableWidget_pd_dissectors.currentRow()-1,0)
            
            # Resize
            self.tableWidget_pd_dissectors.resizeRowsToContents()                
        
    def _slotPD_DissectorsDownClicked(self):
        """ Moves the current field down one position in the field table.
        """        
        # Get Bottom Row
        bottom_row = self.tableWidget_pd_dissectors.rowCount()
        
        # Move it Down
        if self.tableWidget_pd_dissectors.currentRow() != bottom_row-1:  # Ignore bottom row
            # Take the Row Below
            below_item0 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow()+1,0)
            below_item1 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow()+1,1)
            below_item2 = self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow()+1,2).currentIndex()
            below_item3 = self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow()+1,3).currentIndex()
            below_item4 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow()+1,4)
            below_item5 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow()+1,5)
            
            # Take the Current Row
            current_item0 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow(),0)
            current_item1 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow(),1)
            current_item2 = self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow(),2).currentIndex()
            current_item3 = self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow(),3).currentIndex()
            current_item4 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow(),4)
            current_item5 = self.tableWidget_pd_dissectors.takeItem(self.tableWidget_pd_dissectors.currentRow(),5)
            
            # Set the Current Row
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow(),0,below_item0)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow(),1,below_item1)
            self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow(),2).setCurrentIndex(below_item2)
            self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow(),3).setCurrentIndex(below_item3)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow(),4,below_item4)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow(),5,below_item5)
            
            # Set the Row Above
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow()+1,0,current_item0)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow()+1,1,current_item1)
            self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow()+1,2).setCurrentIndex(current_item2)
            self.tableWidget_pd_dissectors.cellWidget(self.tableWidget_pd_dissectors.currentRow()+1,3).setCurrentIndex(current_item3)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow()+1,4,current_item4)
            self.tableWidget_pd_dissectors.setItem(self.tableWidget_pd_dissectors.currentRow()+1,5,current_item5)
            
            # Change the Selected Row               
            self.tableWidget_pd_dissectors.setCurrentCell(self.tableWidget_pd_dissectors.currentRow()+1,0)
            
            # Resize
            self.tableWidget_pd_dissectors.resizeRowsToContents()    
      
                    
    def _slotPD_DissectorsConstructClicked(self, preview = False):
        """ Adds a new packet dissector to the library and the Dissectors folder and Wireshark Lua Default folder. 
        """  
        try:    
            my_error = "Input error."
              
            # Get Values
            get_filter_name = str(self.textEdit_pd_dissectors_filter_name.toPlainText())
            get_tree_name = str(self.textEdit_pd_dissectors_tree_name.toPlainText())
            get_udp_port = str(self.textEdit_pd_dissectors_udp_port.toPlainText())
            
            # Check Filter Name Format            
            good_chars = []
            good_chars.extend(range(48,58))  # Numbers
            good_chars.extend(range(97,123))  # Lower-Case Letters
            good_chars.append(45)  # '-'
            good_chars.append(95)  # '_'
            good_chars.append(46)  # '.'            
            if any(ord(x) not in good_chars for x in get_filter_name):
                my_error = "Filter Name must not contain upper-case letters, numbers, spaces, or symbols other than '-', '_', and '.'."
                raise NameError
        except:
            self.errorMessage(my_error)
                                
        # Get the Table Values
        get_display_names = []
        get_filter_names = []
        get_types = []        
        get_bases = []
        get_bitmasks = []
        get_buffer_locations = []
        for row in range(0,self.tableWidget_pd_dissectors.rowCount()):
            get_display_names.append(str(self.tableWidget_pd_dissectors.item(row,0).text()))
            get_filter_names.append(str(self.tableWidget_pd_dissectors.item(row,1).text()).replace('-','_'))  # Variable names cannot have '-'
            get_types.append(str(self.tableWidget_pd_dissectors.cellWidget(row,2).currentText()))
            get_bases.append(str(self.tableWidget_pd_dissectors.cellWidget(row,3).currentText()))
            if len(str(self.tableWidget_pd_dissectors.item(row,4).text())) == 0:
                get_bitmasks.append('nil')
            else:
                get_bitmasks.append(str(self.tableWidget_pd_dissectors.item(row,4).text()))
            get_buffer_locations.append(str(self.tableWidget_pd_dissectors.item(row,5).text()))
        
        # Assemble the Text   
        dissector_text = 'custom_protocol = Proto("' + get_filter_name + '", "' + get_filter_name + '")\n\n'            
        field_list = ''
        for n in range(0,len(get_filter_names)):
            dissector_text = dissector_text + get_filter_names[n] + ' = ProtoField.new("' + get_display_names[n] + '", "' + get_filter_name + '.' + get_filter_names[n] + '", ' + get_types[n] + ', nil, ' + get_bases[n] + ', ' + get_bitmasks[n] + ')\n'
            field_list = field_list + get_filter_names[n] + ', '
        
        dissector_text = dissector_text + '\ncustom_protocol.fields = {' + field_list[:-2] + '}\n\n'
        dissector_text = dissector_text + 'function custom_protocol.dissector(buffer, pinfo, tree)\n'
        dissector_text = dissector_text + '  length = buffer:len()\n'
        dissector_text = dissector_text + '  if length == 0 then return end\n\n'
        dissector_text = dissector_text + '  pinfo.cols.protocol = custom_protocol.name\n\n'
        dissector_text = dissector_text + '  local subtree = tree:add(custom_protocol, buffer(), "' + get_tree_name + '")\n'
        for n in range(0,len(get_filter_names)):
            dissector_text = dissector_text + '\n  subtree:add_le(' + get_filter_names[n] + ', buffer' + get_buffer_locations[n] + ')'
        dissector_text = dissector_text + '\nend\n\n'
        dissector_text = dissector_text + 'local udp_port = DissectorTable.get("udp.port")\n'
        dissector_text = dissector_text + 'udp_port:add(' + get_udp_port + ', custom_protocol)'
        
        # Preview Dissector (Clicked)
        if preview == True: 
            # Create a Dialog Window    
            msgBox = MyMessageBox(my_text = dissector_text,width = 950)
            msgBox.exec_()  
    
        # Save the File
        else:  
            # Select a Filepath
            directory = os.path.dirname(os.path.realpath(__file__)) + "/Dissectors/"  # Default Directory

            # This Method Allows ".lua" to be Added to the End of the Name
            dialog = QtWidgets.QFileDialog()
            dialog.setDirectory(directory)
            dialog.setFilter(dialog.filter() | QtCore.QDir.Hidden)
            dialog.setDefaultSuffix('lua')
            dialog.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
            dialog.setNameFilters(['Lua Dissectors (*.lua)'])
            if dialog.exec_() == QtWidgets.QDialog.Accepted:
                fileName = str(dialog.selectedFiles()[0])
            else:
                fileName = ""   
            
            # Valid file
            if fileName:
                # Write to File
                file = open(fileName,"wb")                               
                file.write(dissector_text)
                file.close()      
                    
                # Update Library
                get_protocol = str(self.comboBox_pd_dissectors_protocol.currentText())
                get_packet_type = str(self.comboBox_pd_dissectors_packet_type.currentText())
                if len(get_protocol) > 0 and len(get_packet_type) > 0:
                    dissector_file = fileName.rsplit('/')[-1]
                    dissector_port = int(get_udp_port)
                    new_dissector = [dissector_file, dissector_port]
                    self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Add To Library', Parameters = [get_protocol, get_packet_type, [], [], [], [], [], [], new_dissector])            
            
                
    def _slotPD_DissectorsPreviewClicked(self):
        """ Opens a message box with the code for the dissector and for the known-protocols.py cases.
        """
        self._slotPD_DissectorsConstructClicked(preview=True)
        
    def _slotPD_DissectorsTypeChanged(self):
        """ This is called when the type is changed. Its purpose is to assign ftypes.BYTES with ftypes.NONE so no errors are produced.
        """
        for row in range(0,self.tableWidget_pd_dissectors.rowCount()):
            if self.tableWidget_pd_dissectors.cellWidget(row,2).currentText() == "ftypes.BYTES":
                self.tableWidget_pd_dissectors.cellWidget(row,3).setEnabled(False)
                self.tableWidget_pd_dissectors.cellWidget(row,3).setCurrentIndex(0)
            else:
                self.tableWidget_pd_dissectors.cellWidget(row,3).setEnabled(True)
            
    def _slotPD_BitSlicingFindPreamblesClicked(self):
        """ Sends a message to the HIPRFISR/PD to begin searching for candidate preambles from within the buffer.
        """
        # Get the Window Parameters
        win_min = str(self.spinBox_pd_bit_slicing_min_window.value())
        win_max = str(self.spinBox_pd_bit_slicing_max_window.value())
        topx = str(self.spinBox_pd_bit_slicing_ranking.value())
        num_std_dev = str(self.spinBox_pd_bit_slicing_std_deviations.value())   
        
        # Adjust the SpinBox and Slider
        self.doubleSpinBox_pd_bit_slicing_window_size.setMinimum(int(win_min))
        self.doubleSpinBox_pd_bit_slicing_window_size.setMaximum(int(win_max))
        self.doubleSpinBox_pd_bit_slicing_window_size.setValue(int(win_min))
        self.horizontalSlider_pd_bit_slicing_preamble_stats.setMinimum(int(win_min))
        self.horizontalSlider_pd_bit_slicing_preamble_stats.setMaximum(int(win_max))
        self.horizontalSlider_pd_bit_slicing_preamble_stats.setValue(int(win_min))  
        self.doubleSpinBox_pd_bit_slicing_window_size_candidates.setMinimum(int(win_min))
        self.doubleSpinBox_pd_bit_slicing_window_size_candidates.setMaximum(int(win_max))
        self.doubleSpinBox_pd_bit_slicing_window_size_candidates.setValue(int(win_min))
        self.horizontalSlider_pd_bit_slicing_preamble_stats_candidates.setMinimum(int(win_min))
        self.horizontalSlider_pd_bit_slicing_preamble_stats_candidates.setMaximum(int(win_max))
        self.horizontalSlider_pd_bit_slicing_preamble_stats_candidates.setValue(int(win_min)) 
        
        # Clear the Table
        self.tableWidget_pd_bit_slicing_preamble_stats.clearContents()              
        
        # Send Message
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Window Parameters', Parameters = [win_min, win_max, topx, num_std_dev])
        
        # Send Message
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Find Preambles')
        
        # Show the Calculating Label
        self.label_pd_bit_slicing_calculating.setVisible(True)
        
    def _slotPD_BitSlicingPreamblesReturned(self, message):
        """ Stores the returned preambles to memory and loads them into the table.
        """
        # Store to Memory
        self.median_slicing_results = ast.literal_eval(message)[0]
        self.candidate_preamble_data = ast.literal_eval(message)[1]
        
        # Add the Values to the Table, Set the Slider
        self.pdBitSlicingSortPreambleStatsTable(int(self.doubleSpinBox_pd_bit_slicing_window_size.value()))
        self.pdBitSlicingSortCandidatePreambleTable(int(self.doubleSpinBox_pd_bit_slicing_window_size_candidates.value()))
        recommended_preamble = str(list(ast.literal_eval(message)[2].keys())[0])
        self.doubleSpinBox_pd_bit_slicing_window_size_candidates.setValue(len(recommended_preamble))
        self.textEdit_pd_bit_slicing_recommended_preamble.setPlainText(recommended_preamble)
    
        # Enable Controls
        self.label_pd_bit_slicing_window_size.setEnabled(True)
        self.doubleSpinBox_pd_bit_slicing_window_size.setEnabled(True)
        self.horizontalSlider_pd_bit_slicing_preamble_stats.setEnabled(True)
        self.label_pd_bit_slicing_window_size_candidates.setEnabled(True)
        self.doubleSpinBox_pd_bit_slicing_window_size_candidates.setEnabled(True)
        self.horizontalSlider_pd_bit_slicing_preamble_stats_candidates.setEnabled(True)        
        self.pushButton_pd_bit_slicing_slice_by_preamble.setEnabled(True)
        self.label_pd_bit_slicing_first_n.setEnabled(True)
        self.label_pd_bit_slicing_estimated_length.setEnabled(True)
        self.spinBox_pd_bit_slicing_return_limit.setEnabled(True)
        self.spinBox_pd_bit_slicing_estimated_length.setEnabled(True)
        self.tableWidget_pd_bit_slicing_lengths.setEnabled(True)
        self.tableWidget_pd_bit_slicing_packets.setEnabled(True)
        self.label_pd_bit_slicing_recommended_preamble.setEnabled(True)
        self.textEdit_pd_bit_slicing_recommended_preamble.setEnabled(True)
        
        # Hide the Calculating Label
        self.label_pd_bit_slicing_calculating.setVisible(False)
        
    def pdBitSlicingSortPreambleStatsTable(self, packet_length):
        """ This function adds the values to the Preamble Stats and sorts the values by occurrence.
        """
        # Initialize the Table
        for row in reversed(range(0,self.tableWidget_pd_bit_slicing_preamble_stats.rowCount())):
            self.tableWidget_pd_bit_slicing_preamble_stats.removeRow(row)
            
        # Add the Values to the Table           
        packet_size = packet_length
        for key,value in self.median_slicing_results.items():
            # Matching Packet Size
            if value[0] == packet_size:
                # Add First Preamble
                if self.tableWidget_pd_bit_slicing_preamble_stats.rowCount() == 0:
                    # Insert New Row
                    self.tableWidget_pd_bit_slicing_preamble_stats.insertRow(0)
                    
                    # Preamble
                    preamble_item = QtWidgets.QTableWidgetItem(key) 
                    preamble_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(0,0,preamble_item)   
                    
                    # Occurrences
                    occurrences_item = QtWidgets.QTableWidgetItem(str(value[4])) 
                    occurrences_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(0,1,occurrences_item) 
                    
                    # Packet Median
                    packet_median_item = QtWidgets.QTableWidgetItem(str("%.1f" % round(value[1],1))) 
                    packet_median_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(0,2,packet_median_item)   
                    
                    # Packet Mean
                    packet_mean_item = QtWidgets.QTableWidgetItem(str("%.1f" % round(value[2],1))) 
                    packet_mean_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(0,3,packet_mean_item)   
                    
                    # Packet Std. Dev.
                    packet_std_dev_item = QtWidgets.QTableWidgetItem(str("%.1f" % round(value[3],1))) 
                    packet_std_dev_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(0,4,packet_std_dev_item) 
                    
                # Sort by Occurrence
                else:
                    for row in range(0,self.tableWidget_pd_bit_slicing_preamble_stats.rowCount()):
                        insert_row = -1
                        # Insert New Row
                        if int(value[4]) > int(self.tableWidget_pd_bit_slicing_preamble_stats.item(row,1).text()):                                                                                  
                            insert_row = row
                            self.tableWidget_pd_bit_slicing_preamble_stats.insertRow(row)                            
                            break
            
                    # Insert Row at End        
                    if insert_row == -1:                        
                        insert_row = self.tableWidget_pd_bit_slicing_preamble_stats.rowCount()
                        self.tableWidget_pd_bit_slicing_preamble_stats.insertRow(self.tableWidget_pd_bit_slicing_preamble_stats.rowCount())
                                    
                    # Preamble
                    preamble_item = QtWidgets.QTableWidgetItem(key) 
                    preamble_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(insert_row,0,preamble_item)   
                    
                    # Occurrences
                    occurrences_item = QtWidgets.QTableWidgetItem(str(value[4])) 
                    occurrences_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(insert_row,1,occurrences_item) 
                    
                    # Packet Median
                    packet_median_item = QtWidgets.QTableWidgetItem(str("%.1f" % round(value[1],1))) 
                    packet_median_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(insert_row,2,packet_median_item)   
                    
                    # Packet Mean
                    packet_mean_item = QtWidgets.QTableWidgetItem(str("%.1f" % round(value[2],1))) 
                    packet_mean_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(insert_row,3,packet_mean_item)   
                    
                    # Packet Std. Dev.
                    packet_std_dev_item = QtWidgets.QTableWidgetItem(str("%.1f" % round(value[3],1))) 
                    packet_std_dev_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    self.tableWidget_pd_bit_slicing_preamble_stats.setItem(insert_row,4,packet_std_dev_item)   
                                  
        # Resize the Table
        self.tableWidget_pd_bit_slicing_preamble_stats.setColumnWidth(1,97)
        self.tableWidget_pd_bit_slicing_preamble_stats.setColumnWidth(2,111) 
        self.tableWidget_pd_bit_slicing_preamble_stats.setColumnWidth(3,111)
        self.tableWidget_pd_bit_slicing_preamble_stats.setColumnWidth(4,121)
        self.tableWidget_pd_bit_slicing_preamble_stats.horizontalHeader().setSectionResizeMode(0,QtWidgets.QHeaderView.Stretch)
        self.tableWidget_pd_bit_slicing_preamble_stats.resizeRowsToContents()
        
        # Select First Row
        self.tableWidget_pd_bit_slicing_preamble_stats.setCurrentCell(0,0)
        
    def pdBitSlicingSortCandidatePreambleTable(self, preamble_length):
        """ This function adds the values to the Preamble Stats and sorts the values by occurrence.
        """
        # Initialize the Table
        for row in reversed(range(0,self.tableWidget_pd_bit_slicing_candidate_preambles.rowCount())):
            self.tableWidget_pd_bit_slicing_candidate_preambles.removeRow(row)
            
        # Add the Values to the Table           
        for key,value in self.candidate_preamble_data.items():
            if len(key) == preamble_length:
                # Insert New Row
                self.tableWidget_pd_bit_slicing_candidate_preambles.insertRow(0)
                
                # Preamble
                preamble_item = QtWidgets.QTableWidgetItem(key) 
                preamble_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.tableWidget_pd_bit_slicing_candidate_preambles.setItem(0,0,preamble_item)  
                
        # Resize the Table
        self.tableWidget_pd_bit_slicing_candidate_preambles.resizeRowsToContents()
        
    def _slotLibrarySearchSearchLibraryClicked(self):
        """ Sends a message to the HIPRFISR/PD to check the library for occurences of the selected preamble.
        """
        # Get SOI Data
        soi_data = ["","","","","","","","","",""]
        if self.checkBox_library_search_frequency.isChecked():
            soi_data[0] = str(self.textEdit_library_search_frequency.toPlainText())
            soi_data[6] = str(self.textEdit_library_search_frequency_margin.toPlainText())                
        if self.checkBox_library_search_modulation.isChecked():
            soi_data[1] = str(self.textEdit_library_search_modulation.toPlainText())
        if self.checkBox_library_search_bandwidth.isChecked():
            soi_data[2] = str(self.textEdit_library_search_bandwidth.toPlainText())
            soi_data[7] = str(self.textEdit_library_search_bandwidth_margin.toPlainText())
        if self.checkBox_library_search_continuous.isChecked():                
            soi_data[3] = str(self.comboBox_library_search_continuous.currentText())                
        if self.checkBox_library_search_start_frequency.isChecked():
            soi_data[4] = str(self.textEdit_library_search_start_frequency.toPlainText())
            soi_data[8] = str(self.textEdit_library_search_start_frequency_margin.toPlainText())
        if self.checkBox_library_search_end_frequency.isChecked():
            soi_data[5] = str(self.textEdit_library_search_end_frequency.toPlainText())
            soi_data[9] = str(self.textEdit_library_search_end_frequency_margin.toPlainText())
            
        # Get Field Value
        field_data = ""
        if self.checkBox_library_search_field_value.isChecked():
            # Convert to Binary
            if self.radioButton_library_search_hex.isChecked():
                get_data = str(self.textEdit_library_search_field_value.toPlainText())
                get_data = get_data.replace(' ','')
                field_data = bin(int(get_data, 16))[2:].zfill(int(len(get_data)*4))
            else:
                field_data = str(self.textEdit_library_search_field_value.toPlainText())
                field_data.replace(' ','')
        
        # Clear Results Table
        self.tableWidget_library_search_results.setRowCount(0) 
        
        # Send Message
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Search Library', Parameters = [soi_data, field_data])
        
        # Show the Label
        self.label_library_search_searching.setVisible(True)
        
    def _slotPD_BitSlicingLibraryLookupReturned(self, message):
        """ Updates the listbox of library packet types and protocols that match a preamble.
        """
        # Remove Existing Items
        self.tableWidget_library_search_results.setRowCount(0) 
        
        # Convert Message to List
        message_list = ast.literal_eval(message)
        
        # Set the Values in the Results Table       
        for n in message_list:
            for m in n:
                self.tableWidget_library_search_results.setRowCount(self.tableWidget_library_search_results.rowCount()+1)
                
                # Protocol
                protocol_item = QtWidgets.QTableWidgetItem(str(n[m]['Protocol']))
                protocol_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                protocol_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_library_search_results.setItem(self.tableWidget_library_search_results.rowCount()-1,0,protocol_item)     
                
                # Subtype
                subtype_item = QtWidgets.QTableWidgetItem(str(m))
                subtype_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                subtype_item.setFlags(subtype_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_library_search_results.setItem(self.tableWidget_library_search_results.rowCount()-1,1,subtype_item)  
                
                # Center Frequency
                center_freq_item = QtWidgets.QTableWidgetItem(str(n[m]['Frequency']))
                center_freq_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                center_freq_item.setFlags(center_freq_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_library_search_results.setItem(self.tableWidget_library_search_results.rowCount()-1,2,center_freq_item)  
                
                # Start Frequency            
                start_freq_item = QtWidgets.QTableWidgetItem(str(n[m]['Start Frequency']))
                start_freq_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                start_freq_item.setFlags(start_freq_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_library_search_results.setItem(self.tableWidget_library_search_results.rowCount()-1,3,start_freq_item)  
                
                # End Frequency
                end_freq_item = QtWidgets.QTableWidgetItem(str(n[m]['End Frequency']))
                end_freq_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                end_freq_item.setFlags(end_freq_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_library_search_results.setItem(self.tableWidget_library_search_results.rowCount()-1,4,end_freq_item)  
                
                # Bandwidth
                bandwidth_item = QtWidgets.QTableWidgetItem(str(n[m]['Bandwidth']))
                bandwidth_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                bandwidth_item.setFlags(bandwidth_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_library_search_results.setItem(self.tableWidget_library_search_results.rowCount()-1,5,bandwidth_item) 
                
                # Modulation
                modulation_item = QtWidgets.QTableWidgetItem(str(n[m]['Modulation']))
                modulation_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                modulation_item.setFlags(modulation_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_library_search_results.setItem(self.tableWidget_library_search_results.rowCount()-1,6,modulation_item) 
                
                # Continuous
                continuous_item = QtWidgets.QTableWidgetItem(str(n[m]['Continuous']))
                continuous_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                continuous_item.setFlags(continuous_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_library_search_results.setItem(self.tableWidget_library_search_results.rowCount()-1,7,continuous_item) 
                
                # Notes
                notes_item = QtWidgets.QTableWidgetItem(str(n[m]['Notes']))
                notes_item.setTextAlignment(QtCore.Qt.AlignLeft) 
                notes_item.setFlags(notes_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_library_search_results.setItem(self.tableWidget_library_search_results.rowCount()-1,8,notes_item) 
                        
        # Resize the Table
        self.tableWidget_library_search_results.resizeColumnsToContents() 
        self.tableWidget_library_search_results.resizeRowsToContents()  
        #self.tableWidget_library_search_results.horizontalHeader().setStretchLastSection(False) 
        #self.tableWidget_library_search_results.horizontalHeader().setStretchLastSection(True) 
                      
        # Hide the Label
        self.label_library_search_searching.setVisible(False)
                        
    def _slotPD_BitSlicingSpinboxWindowChanged(self):
        """ This adjusts the preamble stats to display the results for the selected window size.
        """
        # Adjust the Slider to Match
        self.horizontalSlider_pd_bit_slicing_preamble_stats.setSliderPosition(int(self.doubleSpinBox_pd_bit_slicing_window_size.value()))
        
        # Change the Preamble Stats that are Displayed in the Table
        self.pdBitSlicingSortPreambleStatsTable(int(self.doubleSpinBox_pd_bit_slicing_window_size.value()))        
        
    def _slotPD_BitSlicingSliderWindowChanged(self):
        """ This adjusts the preamble stats to display the results.
        """
        # Adjust the Spinbox to Match
        self.doubleSpinBox_pd_bit_slicing_window_size.setValue(self.horizontalSlider_pd_bit_slicing_preamble_stats.value())
        
    def _slotPD_BitSlicingSpinboxWindowCandidatesChanged(self):
        """ This adjusts the preamble stats to display the results for the selected window size.
        """
        # Adjust the Slider to Match
        self.horizontalSlider_pd_bit_slicing_preamble_stats_candidates.setSliderPosition(int(self.doubleSpinBox_pd_bit_slicing_window_size_candidates.value()))
        
        # Change the Preamble Stats that are Displayed in the Table
        self.pdBitSlicingSortCandidatePreambleTable(int(self.doubleSpinBox_pd_bit_slicing_window_size_candidates.value()))   
        
    def _slotPD_BitSlicingSliderWindowCandidatesChanged(self):
        """ This adjusts the preamble stats to display the results.
        """
        # Adjust the Spinbox to Match
        self.doubleSpinBox_pd_bit_slicing_window_size_candidates.setValue(self.horizontalSlider_pd_bit_slicing_preamble_stats_candidates.value())         
        
    def _slotPD_BitSlicingSliceByPreambleClicked(self):
        """ Signals to PD to slices the buffer by a select preamble and return the lengths, length count, and first N packets.
        """
        # Get the Preamble
        get_preamble = str(self.textEdit_pd_bit_slicing_recommended_preamble.toPlainText())
        
        # Get the First N Value
        get_first_n = str(self.spinBox_pd_bit_slicing_return_limit.value())
        
        # Estimated Length
        get_estimated_length = str(self.spinBox_pd_bit_slicing_estimated_length.value())
        
        # Send the Message
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Slice By Preamble', Parameters = [get_preamble, get_first_n, get_estimated_length])
        
    def _slotPD_BitSlicingSliceByPreambleReturned(self, returned_values):
        """ Updates the tables with the return values from 'Slice By Preamble.'
        """        
        # Convert String to List
        returned_values = ast.literal_eval(returned_values)
        packet_lengths = returned_values[0]
        
        # Convert Hex Data to Binary
        self.first_n_packets = {}
        for p_length, packet in returned_values[1].items():
            packet_list = []
            for hex_data in packet:                
                packet_list.append(bin(int(hex_data, 16))[2:].zfill(int(len(hex_data)*4)))  # Converts packet to binary
            self.first_n_packets[4*int(p_length)] = packet_list

        # Clear the Packet Length Table
        for row in reversed(range(0,self.tableWidget_pd_bit_slicing_lengths.rowCount())):
            self.tableWidget_pd_bit_slicing_lengths.removeRow(row)
        for col in reversed(range(0,self.tableWidget_pd_bit_slicing_packets.columnCount())):
            self.tableWidget_pd_bit_slicing_packets.removeColumn(col)      
            
        # Insert into the Packet Length Table    
        for n in reversed(range(0,len(packet_lengths))):
            self.tableWidget_pd_bit_slicing_lengths.insertRow(0)
            
            # Packet Lengths
            packet_length_item = QtWidgets.QTableWidgetItem(str(4*packet_lengths[n][0]))  # In bits
            packet_length_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_pd_bit_slicing_lengths.setItem(0,0,packet_length_item)             
            
            # Packet Length Occurrences
            length_occurrences_item = QtWidgets.QTableWidgetItem(str(packet_lengths[n][1])) 
            length_occurrences_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_pd_bit_slicing_lengths.setItem(0,1,length_occurrences_item)  
        
        # Select the First Row
        self.tableWidget_pd_bit_slicing_lengths.setCurrentCell(0,0)            
        
        # Enable the Controls
        self.frame_pd_bit_slicing_manual_slicing.setEnabled(True)
        self.frame_pd_bit_slicing_automated_slicing.setEnabled(True)
        self.frame_pd_bit_slicing_library.setEnabled(True)
        self.label_pd_bit_slicing_interval.setEnabled(True)
        self.spinBox_pd_bit_slicing_interval.setEnabled(True)
        self.pushButton_pd_bit_slicing_slice.setEnabled(True)
        self.pushButton_pd_bit_slicing_reset.setEnabled(True)
        self.label_pd_bit_slicing_split_interval.setEnabled(True)
        self.spinBox_pd_bit_slicining_split_interval.setEnabled(True)
        self.pushButton_pd_bit_slicing_split_fields.setEnabled(True)
        self.pushButton_pd_bit_slicing_merge_fields.setEnabled(True)
        self.pushButton_pd_bit_slicing_search_library.setEnabled(True)
        self.pushButton_pd_bit_slicing_add_to_library.setEnabled(True)     
        self.checkBox_pd_bit_slicing_colors.setEnabled(True)  
        self.pushButton_pd_bit_slicing_plot_entropy.setEnabled(True)
        self.pushButton_pd_bit_slicing_shift_left.setEnabled(True)
        self.pushButton_pd_bit_slicing_shift_right.setEnabled(True)
           
        # Resize the Tables
        #~ self.tableWidget_pd_bit_slicing_lengths.resizeColumnsToContents()
        self.tableWidget_pd_bit_slicing_lengths.resizeRowsToContents()  
        
    def _slotPD_BitSlicingLengthsChanged(self):
        """ This updates the packet listings when an item is clicked in the packet length table.
        """
        # Get the Current Row
        get_row = self.tableWidget_pd_bit_slicing_lengths.currentRow()
        
        # Valid Case
        if get_row >= 0:
            # Clear the Packet Table
            for row in reversed(range(0,self.tableWidget_pd_bit_slicing_packets.rowCount())):
                self.tableWidget_pd_bit_slicing_packets.removeRow(row)  
            for col in reversed(range(0,self.tableWidget_pd_bit_slicing_packets.columnCount())):
                self.tableWidget_pd_bit_slicing_packets.removeColumn(col)  
                
            # Get Length Value
            length_item_value = int(self.tableWidget_pd_bit_slicing_lengths.item(get_row,0).text())    
                
            # Add Column
            self.tableWidget_pd_bit_slicing_packets.setColumnCount(1)            
            header_item = QtWidgets.QTableWidgetItem("Packets of Length " + str(length_item_value))
            header_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_pd_bit_slicing_packets.setHorizontalHeaderItem(0,header_item)      
            
            # Clear Field Delineations Table
            self.tableWidget_pd_bit_slicing_field_delineations.setRowCount(0)  
            
            # Add First Packet Length to the Packets Table            
            for n in range(0,len(self.first_n_packets[length_item_value])):
                new_row = self.tableWidget_pd_bit_slicing_packets.rowCount()
                self.tableWidget_pd_bit_slicing_packets.insertRow(new_row)            
                packet_item = QtWidgets.QTableWidgetItem(self.first_n_packets[length_item_value][n]) 
                self.tableWidget_pd_bit_slicing_packets.setItem(new_row,0,packet_item)  
            
            #~ # Resize the Table
            #~ self.tableWidget_pd_bit_slicing_packets.resizeColumnsToContents()
            #~ self.tableWidget_pd_bit_slicing_packets.resizeRowsToContents()
        
            # Reset the Packet Type
            self.bit_slicing_column_type = ["Binary"]
        
            # Slice the Data
            self._slotPD_BitSlicingSliceClicked(length_item_value) 
                
    def _slotPD_BitSlicingDetectFieldsClicked(self, field_locations = False, packet_data = None):
        """ Begins slicing the packets in the packet table by potential fields. The table then highlights the different detected fields.
        """      
        # Reset the Field Types
        self.bit_slicing_column_type = []
                
        # Get the Selected Packets of Length N
        get_row = self.tableWidget_pd_bit_slicing_lengths.currentRow()
        
        # Get the Table Data
        length_item_value = int(self.tableWidget_pd_bit_slicing_lengths.item(get_row,0).text())
        if packet_data == None:
            packet_data = self.first_n_packets[length_item_value]
        
        # Get the Field Delineations
        if type(field_locations) is bool:
            # Get the Field Locations
            field_locations = []
            for row in range(0,self.tableWidget_pd_bit_slicing_field_delineations.rowCount()):
                field_locations.append(int(self.tableWidget_pd_bit_slicing_field_delineations.item(row,0).text()))
        
        # Append the Data End
        field_locations.append(int(self.tableWidget_pd_bit_slicing_lengths.item(self.tableWidget_pd_bit_slicing_lengths.currentRow(),0).text()))
        
        # Clear the Packet Table
        for row in reversed(range(0,self.tableWidget_pd_bit_slicing_packets.rowCount())):
            self.tableWidget_pd_bit_slicing_packets.removeRow(row)   
        for col in reversed(range(0,self.tableWidget_pd_bit_slicing_packets.columnCount())):
            self.tableWidget_pd_bit_slicing_packets.removeColumn(col)               

        # Break up Packets By Field Lengths        
        self.tableWidget_pd_bit_slicing_packets.setRowCount(len(packet_data))         
        for n in range(0,len(field_locations)-1):
            # Add Column
            new_color = self.suitable_colors[n%len(self.suitable_colors)]  
            self.tableWidget_pd_bit_slicing_packets.setColumnCount(self.tableWidget_pd_bit_slicing_packets.columnCount() + 1)            
            header_item = QtWidgets.QTableWidgetItem(self.colnum_string(n+1))
            header_item.setTextAlignment(QtCore.Qt.AlignCenter)
            header_item.setForeground(QtGui.QColor(255,0,0))
            self.tableWidget_pd_bit_slicing_packets.setHorizontalHeaderItem(self.tableWidget_pd_bit_slicing_packets.columnCount()-1,header_item)
            
            # Add Field Values to the Packet Table for Each Packet          
            for m in range(0,len(packet_data)): 
                packet_item = QtWidgets.QTableWidgetItem(packet_data[m][field_locations[n]:field_locations[n+1]])   
                packet_item.setTextAlignment(QtCore.Qt.AlignCenter)   
                if self.checkBox_pd_bit_slicing_colors.isChecked():           
                    packet_item.setBackground(QtGui.QColor(new_color[0],new_color[1],new_color[2]))
                self.tableWidget_pd_bit_slicing_packets.setItem(m,n,packet_item) 
            
            # Default to Hex
            self.bit_slicing_column_type.append("Binary")
            if len(str(packet_item.text()))%4 == 0:
                self._slotPD_BitSlicingColumnClicked(n)                    
            
        # Resize the Table
        self.tableWidget_pd_bit_slicing_packets.resizeColumnsToContents()
        self.tableWidget_pd_bit_slicing_packets.resizeRowsToContents()  
        self.tableWidget_pd_bit_slicing_packets.horizontalHeader().setStretchLastSection(False)
        self.tableWidget_pd_bit_slicing_packets.horizontalHeader().setStretchLastSection(True)
        
        # Enable the Controls
        self.label_pd_bit_slicing_field_delineations.setEnabled(True)
        self.tableWidget_pd_bit_slicing_field_delineations.setEnabled(True)
        self.pushButton_pd_bit_slicing_add_to_library.setEnabled(True)
        self.pushButton_pd_bit_slicing_refresh.setEnabled(True)
        self.pushButton_pd_bit_slicing_insert_field.setEnabled(True)
        self.pushButton_pd_bit_slicing_remove_field.setEnabled(True)
        self.pushButton_pd_bit_slicing_search_library.setEnabled(True)
        self.pushButton_pd_bit_slicing_reset.setEnabled(True)
        
        # Populate Field Delineation Table
        self.tableWidget_pd_bit_slicing_field_delineations.setRowCount(self.tableWidget_pd_bit_slicing_packets.columnCount())
        for n in range(0,self.tableWidget_pd_bit_slicing_packets.columnCount()):
            # Header Item
            header_item = QtWidgets.QTableWidgetItem(str(self.tableWidget_pd_bit_slicing_packets.horizontalHeaderItem(n).text()))
            header_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_pd_bit_slicing_field_delineations.setVerticalHeaderItem(n,header_item)
            
            # Table Item
            table_item = QtWidgets.QTableWidgetItem(str(field_locations[n])) 
            table_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_pd_bit_slicing_field_delineations.setItem(n,0,table_item)  
            
        # Resize the Table
        self.tableWidget_pd_bit_slicing_field_delineations.resizeRowsToContents()        
        
        # Reset the Current Selection
        self.tableWidget_pd_bit_slicing_packets.setCurrentCell(0,0)    
        
    def colnum_string(self,n):
        """ Converts values from a number-based counting system to a letter-based counting system.
        """ 
        div=n
        string=""
        temp=0
        while div>0:
            module=(div-1)%26
            string=chr(65+module)+string
            div=int((div-module)/26)
        return string
        
    def _slotPD_BitSlicingRefreshClicked(self):
        """ Updates the packet table with the fields entered in the field delineation table
        """
        # Get the Field Locations
        field_locations = []
        for row in range(0,self.tableWidget_pd_bit_slicing_field_delineations.rowCount()):
            field_locations.append(int(self.tableWidget_pd_bit_slicing_field_delineations.item(row,0).text()))
            
        # Update the Packet Table    
        self._slotPD_BitSlicingDetectFieldsClicked(field_locations)
        
    def _slotPD_BitSlicingRemoveFieldClicked(self):
        """ Removes a field/row from the field delineation table.
        """
        # Remove the Current Row
        self.tableWidget_pd_bit_slicing_field_delineations.removeRow(self.tableWidget_pd_bit_slicing_field_delineations.currentRow())
        
        # Reset the Current Selection
        self.tableWidget_pd_bit_slicing_field_delineations.setCurrentCell(self.tableWidget_pd_bit_slicing_field_delineations.currentRow(),0)
        
    def _slotPD_BitSlicingInsertFieldClicked(self):
        """ Inserts a new field/row to the field delineation table.
        """
        # Insert after the Current Row
        self.tableWidget_pd_bit_slicing_field_delineations.insertRow(self.tableWidget_pd_bit_slicing_field_delineations.currentRow()+1)
        
        # Reset the Current Selection
        self.tableWidget_pd_bit_slicing_field_delineations.setCurrentCell(self.tableWidget_pd_bit_slicing_field_delineations.currentRow()+1,0)
        
        # Center the Text
        table_item = QtWidgets.QTableWidgetItem("") 
        table_item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget_pd_bit_slicing_field_delineations.setItem(self.tableWidget_pd_bit_slicing_field_delineations.currentRow(),0,table_item)  
        
    def _slotPD_BitSlicingAddToLibraryClicked(self):
        """ Populates the Add to Library Tab with the contents from the the bit slicing tab.
        """
        # Clear the "Add to Library" Table
        for row in reversed(range(0,self.tableWidget_library_pd_packet.rowCount())):
            self.tableWidget_library_pd_packet.removeRow(row)   
        
        # Insert Each Field
        for col in range(0,self.tableWidget_pd_bit_slicing_packets.columnCount()):
            # Insert Row
            self.tableWidget_library_pd_packet.setRowCount(self.tableWidget_library_pd_packet.rowCount() + 1)    
            
            # Row Header            
            header_item = QtWidgets.QTableWidgetItem("Field " + str(self.tableWidget_library_pd_packet.rowCount()))
            header_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_library_pd_packet.setVerticalHeaderItem(self.tableWidget_library_pd_packet.rowCount()-1,header_item)
            
            # Field Name
            table_item = QtWidgets.QTableWidgetItem(str(self.tableWidget_pd_bit_slicing_packets.horizontalHeaderItem(col).text()))
            table_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_library_pd_packet.setItem(col,0,table_item)  
            
            # Length
            if self.bit_slicing_column_type[col] == "Binary":
                length_item = QtWidgets.QTableWidgetItem(str(len(self.tableWidget_pd_bit_slicing_packets.item(self.tableWidget_pd_bit_slicing_packets.currentRow(),col).text())))
            else:                
                length_item = QtWidgets.QTableWidgetItem(str(4*len(self.tableWidget_pd_bit_slicing_packets.item(self.tableWidget_pd_bit_slicing_packets.currentRow(),col).text())))
            length_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_library_pd_packet.setItem(col,1,length_item)         
            
            # Default Value
            # Get the Data as Binary
            get_data = str(self.tableWidget_pd_bit_slicing_packets.item(self.tableWidget_pd_bit_slicing_packets.currentRow(),col).text())
            if self.bit_slicing_column_type[col] == "Binary":
                default_item_text = get_data
            else:                
                bin_str = bin(int(get_data, 16))[2:].zfill(int(len(get_data)*4))
                default_item_text = bin_str
            default_item = QtWidgets.QTableWidgetItem(default_item_text)
            default_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_library_pd_packet.setItem(col,2,default_item)   
            
            # CRC Range
            crc_range_item = QtWidgets.QTableWidgetItem("") 
            crc_range_item.setTextAlignment(QtCore.Qt.AlignCenter)
            crc_range_item.setFlags(crc_range_item.flags() ^ QtCore.Qt.ItemIsEnabled)
            crc_range_item.setFlags(crc_range_item.flags() ^ QtCore.Qt.ItemIsEditable)
            self.tableWidget_library_pd_packet.setItem(col,4,crc_range_item)  
                
            # Is CRC
            new_combobox = QtWidgets.QComboBox(self)
            new_combobox.addItem("True")
            new_combobox.addItem("False")
            new_combobox.setCurrentIndex(1)
            self.tableWidget_library_pd_packet.setCellWidget(col,3,new_combobox)
            new_combobox.currentIndexChanged.connect(self._slotPD_AddToLibraryIsCRC_Changed)
            new_combobox.setProperty("row", col)  
             
            # Resize the Table
            self.tableWidget_library_pd_packet.resizeRowsToContents()        
            self.tableWidget_library_pd_packet.setColumnWidth(0,125) 
            self.tableWidget_library_pd_packet.setColumnWidth(1,75) 
            self.tableWidget_library_pd_packet.setColumnWidth(3,75)
            self.tableWidget_library_pd_packet.setColumnWidth(4,130)
            self.tableWidget_library_pd_packet.horizontalHeader().setSectionResizeMode(2,QtWidgets.QHeaderView.Stretch)
            
            # Change the Tab
            self.tabWidget_library.setCurrentIndex(4)
            self.tabWidget.setCurrentIndex(7)
            
    def _slotPD_AddToLibraryProtocolChanged(self):
        """ Selects a protocol for the new packet type to be assigned to in the library.
        """
        # Clear Demodulation Flow Graph Modulation Combo Box
        self.comboBox_library_pd_modulation_types.clear()
        
        # Enable/Disable New Protocol Name
        get_protocol = str(self.comboBox_library_pd_protocol.currentText())
        if get_protocol != "":
            if get_protocol == "-- New Protocol --":
                self.label_library_add.setText("Add New Protocol to Library")
                self.stackedWidget_library_pd.setCurrentIndex(0)
                self.label_library_pd_data_type.setVisible(False)
                self.comboBox_library_pd_data_type.setVisible(False)
            else:
                self.label_library_pd_data_type.setVisible(True)
                self.comboBox_library_pd_data_type.setVisible(True)
                self._slotLibraryAddDataTypeChanged()
            
    def _slotLibraryAddAddToLibrary_Clicked(self):
        """ Collects the data to be added to the library and sends it to the HIPRFISR.
        """
        protocol_name = ""
        get_modulation = ""
        new_packet_name = ""
        get_packet_data = [] 
        get_soi_data = []
        get_statistical_data = []

        demodulation_fg_data = []
        get_demodulation_type = "" 
        
        # Protocol Name
        if self.stackedWidget_library_pd.currentIndex() == 0:
            protocol_name = str(self.textEdit_library_pd_new_protocol.toPlainText())
            protocols = getProtocols(self.pd_library)
            
            # Empty or Duplicate
            if (len(protocol_name) == 0) or (protocol_name in protocols):
                self.errorMessage("Enter valid protocol name.")
                return
        else:
            protocol_name = str(self.comboBox_library_pd_protocol.currentText())
            
        # Modulation Type
        if self.stackedWidget_library_pd.currentIndex() == 1:
            get_modulation = str(self.textEdit_library_pd_modulation_type.toPlainText())  
            modulation_types = getModulations(self.pd_library, protocol_name)
            
            # Empty or Duplicate
            if (len(get_modulation) == 0) or (get_modulation in modulation_types):
                self.errorMessage("Enter valid modulation type.")
                return
                
        # Packet Type
        elif self.stackedWidget_library_pd.currentIndex() == 2:
            # Valid Packet Name
            new_packet_name = str(self.textEdit_library_pd_packet_name.toPlainText())
            packet_types = getPacketTypes(self.pd_library, protocol_name)
            
            # Empty or Duplicate 
            if (len(new_packet_name) == 0) or (new_packet_name in packet_types):
                self.errorMessage("Enter valid packet name.")
                return                
                
            else:
                # Check for Content
                if self.tableWidget_library_pd_packet.rowCount() == 0:
                    self.errorMessage("The number of fields cannot be zero.")
                    return
                else:    
                    # Get Packet Data
                    for row in range(0,self.tableWidget_library_pd_packet.rowCount()):
                        get_packet_data.append([])
                        get_packet_data[row].append(str(self.tableWidget_library_pd_packet.item(row,0).text()))
                        get_packet_data[row].append(str(self.tableWidget_library_pd_packet.item(row,1).text()))
                        
                        # Check Default Values for Binary Characters
                        check_default_values = str(self.tableWidget_library_pd_packet.item(row,2).text())
                        if set(check_default_values).issubset({'0','1',' '}) and bool(check_default_values):
                            get_packet_data[row].append(check_default_values)
                        else:
                            self.errorMessage("Default values must be binary: 1010 0010 1111...")
                            return
                                                    
                        get_packet_data[row].append(str(self.tableWidget_library_pd_packet.cellWidget(row,3).currentText()))
                        get_packet_data[row].append(str(self.tableWidget_library_pd_packet.item(row,4).text()))

        # Signal of Interest
        elif self.stackedWidget_library_pd.currentIndex() == 3:
            # Must Have Subtype/Label
            if len(str(self.textEdit_library_pd_soi_subtype.toPlainText()).replace(" ","")) == 0:
                self.errorMessage("Requires Subtype/Label")
                return
                
            get_soi_data.append(str(self.textEdit_library_pd_soi_frequency.toPlainText()))
            get_soi_data.append(str(self.textEdit_library_pd_soi_modulation.toPlainText()))
            get_soi_data.append(str(self.textEdit_library_pd_soi_bandwidth.toPlainText()))
            get_soi_data.append(str(self.comboBox_library_pd_soi_continuous.currentText()))
            get_soi_data.append(str(self.textEdit_library_pd_soi_start_frequency.toPlainText()))
            get_soi_data.append(str(self.textEdit_library_pd_soi_end_frequency.toPlainText()))
            get_soi_data.append(str(self.textEdit_library_pd_soi_notes.toPlainText()))            
            get_soi_data.append(str(self.textEdit_library_pd_soi_subtype.toPlainText()))
            for n in range(0,len(get_soi_data)):
                if get_soi_data[n] == "":
                    # Ignore Notes
                    if n != 6:
                        get_soi_data[n] = "-1"
        
        # Statistics
        elif self.stackedWidget_library_pd.currentIndex() == 4:
            pass
            
        # Demodulation Flow Graph
        elif self.stackedWidget_library_pd.currentIndex() == 5:          
            get_demodulation_fg = str(self.textEdit_library_pd_demodulation_fg.toPlainText())    
            get_demodulation_type = str(self.comboBox_library_pd_modulation_types.currentText())       
            get_demodulation_hardware = str(self.comboBox_library_pd_hardware.currentText())
            if self.radioButton_library_add_demodulation_fg_stream.isChecked():
                get_sniffer_type = "Stream"
            elif self.radioButton_library_add_demodulation_fg_tagged_stream.isChecked():
                get_sniffer_type = "Tagged Stream"
            elif self.radioButton_library_add_demodulation_fg_msg_pdu.isChecked():
                get_sniffer_type = "Message/PDU"

            # Invalid Demodulation Flow Graph
            if get_demodulation_fg == "":
                self.errorMessage("Enter valid demodulation flow graph filepath.")
                return
            if get_demodulation_type == "":
                self.errorMessage("Add modulation type for demodulation flow graph.")
                return
                                                                           
            # Add .py and .grc to "PD Flow Graphs"
            try:
                demod_py_filepath = get_demodulation_fg
                get_demodulation_fg = get_demodulation_fg.rsplit("/",1)[1]
                
                # Check for Duplicate
                demod_fg_exists = os.path.exists(os.path.dirname(os.path.realpath(__file__)) + "/Flow Graph Library/PD Flow Graphs/" + get_demodulation_fg)
                if demod_fg_exists:
                    self.errorMessage("Duplicate demodulation flow graph name")
                    return
                
                shutil.copy(demod_py_filepath,os.path.dirname(os.path.realpath(__file__)) + "/Flow Graph Library/PD Flow Graphs/" + get_demodulation_fg) 
                demodulation_fg_data = [get_demodulation_type, get_demodulation_fg, get_demodulation_hardware, get_sniffer_type]
                
                demod_grc_file = get_demodulation_fg.replace('.py','.grc')
                demod_grc_filepath = demod_py_filepath.replace('.py','.grc')
                shutil.copy(demod_grc_filepath,os.path.dirname(os.path.realpath(__file__)) + "/Flow Graph Library/PD Flow Graphs/" + demod_grc_file) 
            except:
                self.errorMessage("New demodulation flow graph requires a valid .py and .grc file with the same name.")
                return
                
        # Attack
        elif self.stackedWidget_library_pd.currentIndex() == 6:    
            # Get Tree Parent, Attack Name, Hardware
            get_tree_parent = str(self.comboBox_library_attacks_subcategory.currentText())
            get_attack_name = str(self.textEdit_library_attacks_name.toPlainText())
            get_hardware = str(self.comboBox_library_attacks_hardware.currentText())
            get_file_type = str(self.comboBox_library_attacks_file_type.currentText())
            get_new_filename = str(self.textEdit_library_attacks_new_name.toPlainText())

            # Assemble New Attack Filepath, Determine Single-Stage or Multi-Stage
            get_filepath = str(self.label_library_attacks_filepath.text())
            
            # Invalid Filepath
            if len(get_filepath) == 0:
                self.errorMessage('Select attack file.')
                return  
                
            # Invalid Attack Template Name
            if len(get_attack_name) == 0:
                self.errorMessage('Enter new attack template name.')
                return              
                
            # Invalid Attack Name
            if len(get_new_filename) == 0:
                self.errorMessage('Enter new attack name.')
                return  
                
            # Format Filepath
            if get_filepath.rsplit(".",1)[-1] == "py":
                # Force it to End with ".py"
                if get_new_filename.rsplit(".",1)[-1] != "py":
                    get_new_filename = get_new_filename + ".py"
                    self.textEdit_library_attacks_new_name.setPlainText(get_new_filename)
                else:    
                    get_new_filename = str(self.textEdit_library_attacks_new_name.toPlainText())
                attack_type = "Single-Stage"
            elif get_filepath.rsplit(".",1)[1] == "msa":
                get_new_filename = get_filepath.rsplit("/",1)[-1]
                attack_type = "Multi-Stage"
            else:
                self.errorMessage('Attack needs to end with ".py" or ".msa"')
                return            
                
            # Get Protocols and Modulation Types
            get_protocol = []
            get_modulation = []
            if attack_type == "Single-Stage":
                get_protocol.append(str(self.comboBox_library_pd_protocol.currentText()))
                get_modulation.append(str(self.comboBox_library_attacks_modulation.currentText()))
                
                # No Modulation Type
                if len(get_modulation[0]) == 0:
                    self.errorMessage('Requires modulation type.')
                    return
                    
            # elif attack_type == "Multi-Stage":
                # # Read the File
                # f = open(get_filepath, "rb")           
                # data = yaml.load(f.read(), yaml.FullLoader)
                # attack_table_row_list = data[0]
                # f.close()
                
                # # Get the Protocols and Modulation Types
                # for rows in attack_table_row_list:
                    # get_protocol.append(rows[0])
                    # get_modulation.append(rows[1])
                
            # Check if File Already Exists     
            if os.path.isfile(os.path.dirname(os.path.realpath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/" + get_new_filename):
                self.errorMessage('File already exists in "Single-Stage Flow Graphs" folder.')
                return
            else:
                # Check if Attack Already Exists for the Protocol, Modulation, and Hardware Combination
                protocol_attack_exists = False
                current_protocol_attacks = []
                for m in range(0,len(get_protocol)):
                    try:
                        current_protocol_attacks = self.pd_library["Protocols"][get_protocol[m]]["Attacks"]
                        for n in current_protocol_attacks:
                            if n == get_attack_name:
                                if self.pd_library["Protocols"][get_protocol[m]]["Attacks"][n][get_modulation[m]["Hardware"][get_hardware]] != None:
                                    protocol_attack_exists = True
                                    break
                    except:
                        pass
                
                # No Previous Attacks Share the Name                           
                if protocol_attack_exists == False:
                    
                    # Check if Parent Already Exists for the Protocol
                    protocol_parent_exists = []
                    for n in current_protocol_attacks:
                        if n == get_tree_parent:  
                            protocol_parent_exists.append(True)
                        else:
                            protocol_parent_exists.append(False)                      
                                
                    ## Check if Attack Already Exists in the Tree Widget
                    #tree_widget_attack_exists = False
                    #if attack_type == "Single-Stage":
                        #current_tree_attacks = self.pd_library["Attacks"]["Single-Stage Attacks"]
                    #elif attack_type == "Multi-Stage":
                        #current_tree_attacks = self.pd_library["Attacks"]["Multi-Stage Attacks"]
                    #for n in current_tree_attacks:
                        #if n.split(",")[0] == get_attack_name.replace("_"," "):
                            #tree_widget_attack_exists = True
                    #if tree_widget_attack_exists == True:
                         #self.errorMessage("Warning: Attack already exists in Tree Widget")
                         #no_errors = False

                    # Send Message to Protocol Discovery to Update Library
                    attack_list = [get_attack_name, get_modulation[0], "Hardware", get_hardware, get_file_type, get_new_filename, attack_type, get_tree_parent]
                    self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Add To Library', Parameters = [get_protocol[0], [], [], [], [], [], [], attack_list, []])   
                    
                    # Add to "Flow Graph Library/Single-Stage Flow Graphs"
                    shutil.copy(get_filepath,os.path.dirname(os.path.realpath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/" + get_new_filename) 
                    
                    # Add .grc File to "Flow Graph Library/Single-Stage Flow Graphs"
                    if self.checkBox_library_attacks_grc_file.isChecked():
                        shutil.copy(get_filepath.replace(".py",".grc"),os.path.dirname(os.path.realpath(__file__)) + "/Flow Graph Library/Single-Stage Flow Graphs/" + get_new_filename.replace(".py",".grc")) 
                     
                    # Success Message and Reset Fields   
                    #self.errorMessage("Imported Successfully!")  # Needs to happen on component return message
                    self.label_library_attacks_filepath.setText("")
                    self.textEdit_library_attacks_name.setText("")
                    self.textEdit_library_attacks_new_name.setText("")
                                                             
                # Attack Already Exists for the Protocol
                else:
                    self.errorMessage("Attack name already exists for this protocol/modulation/hardware combination.")
                    return
            return
            
        # Valid Protocol Name
        if protocol_name != "":                                    
            # Send Message to HIPRFISR/Protocol Discovery    
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Add To Library', Parameters = [protocol_name, new_packet_name, get_packet_data, get_soi_data, get_statistical_data, get_modulation, demodulation_fg_data, [], []])   

                        
    def _slotPD_DissectorsProtocolChanged(self):
        """ Changes the combobox of packet types to reflect the selected protocol.
        """
        # Clear Tab if Blank Selected
        get_protocol = str(self.comboBox_pd_dissectors_protocol.currentText())
        if get_protocol == "":
            self.comboBox_pd_dissectors_packet_type.clear()
            self.comboBox_pd_dissectors_existing_dissectors.clear()
            self.frame_pd_dissectors_editor.setVisible(False)
        else:
            # Get the Packet Types
            get_packet_types = getPacketTypes(self.pd_library, get_protocol)
            
            # Clear the ComboBox
            self.comboBox_pd_dissectors_packet_type.clear()
            
            # Fill the ComboBox
            self.comboBox_pd_dissectors_packet_type.addItems(get_packet_types)
            
    def _slotPD_DissectorsPacketTypeChanged(self):
        """ Auto-populates the Dissectors tab with packet information from "library.yaml."
        """
        # Get Protocol
        protocol = str(self.comboBox_pd_dissectors_protocol.currentText())

        # Get Packet Type
        packet_type = str(self.comboBox_pd_dissectors_packet_type.currentText())

        # Make the Groupbox Invisible
        self.frame_pd_dissectors_editor.setVisible(False)
    
        # Clear Existing Dissectors
        self.comboBox_pd_dissectors_existing_dissectors.clear()
                             
        # Filter Name
        if len(protocol) == 0:
            filter_name = "protocol.packet_type"
        else:
            filter_name = (protocol + "." + packet_type).lower().replace(' ','_')
        self.textEdit_pd_dissectors_filter_name.setPlainText(filter_name)
        
        # Tree Name
        if len(protocol) == 0:
            self.textEdit_pd_dissectors_tree_name.setPlainText("Protocol: Packet Type")
        else:
            self.textEdit_pd_dissectors_tree_name.setPlainText(protocol + ": " + packet_type)
        
        # UDP Port
        if len(protocol) == 0:
            # Get Next Unassigned UDP Port
            next_port = getNextDissectorPort(self.pd_library)
            self.textEdit_pd_dissectors_udp_port.setPlainText(str(next_port))  
        else:
            # No Packet Type
            if len(packet_type) == 0:                
                # Get Next Unassigned UDP Port
                next_port = getNextDissectorPort(self.pd_library)
                self.textEdit_pd_dissectors_udp_port.setPlainText(str(next_port))  
            # Valid Packet Type
            else:
                get_port = getDissector(self.pd_library, protocol, packet_type)['Port']
                # No Assigned Dissector Port
                if (get_port == "None") or (get_port == None):
                    # Get Next Unassigned UDP Port
                    next_port = getNextDissectorPort(self.pd_library)
                    self.textEdit_pd_dissectors_udp_port.setPlainText(str(next_port))
                # Valid Dissector Port
                else:
                    self.textEdit_pd_dissectors_udp_port.setPlainText(str(get_port))                               
        
        # Clear the Tables
        for row in reversed(range(0,self.tableWidget_pd_dissectors.rowCount())):
            self.tableWidget_pd_dissectors.removeRow(row)           
                  
        # Add Field Names, Lengths, and Display Text to the Table  
        if protocol != "" and packet_type != "":
            # Load Dissectors for all Packets Types in the ComboBox
            get_packet_types = getPacketTypes(self.pd_library, protocol)
            self.comboBox_pd_dissectors_existing_dissectors.addItem('None') 
            get_dissectors = []
            for n in get_packet_types:
                get_dissectors.append(getDissector(self.pd_library, protocol, n)['Filename'])
            get_dissectors = sorted(list(set(get_dissectors)))
            if 'None' in get_dissectors: 
                get_dissectors.remove('None')
            self.comboBox_pd_dissectors_existing_dissectors.addItems(get_dissectors)
                        
            # Populate Existing Dissectors
            get_dissector = getDissector(self.pd_library, protocol, packet_type)['Filename']
            if get_dissector != None:
                dissector_index = self.comboBox_pd_dissectors_existing_dissectors.findText(get_dissector)
                if dissector_index > 0:
                    self.comboBox_pd_dissectors_existing_dissectors.setCurrentIndex(dissector_index)   
                        
            get_fields = getFields(self.pd_library, protocol, packet_type)            
            for n in range(0,len(get_fields)):
                # Add Row
                self._slotPD_DissectorsAddFieldClicked()
                
                # Display Name
                table_item = QtWidgets.QTableWidgetItem(get_fields[n])
                table_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.tableWidget_pd_dissectors.setItem(n,0,table_item)  
                
                # Filter Name
                table_item = QtWidgets.QTableWidgetItem(get_fields[n].replace(" ","_").lower())
                table_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.tableWidget_pd_dissectors.setItem(n,1,table_item)  # No Spaces, Lower-Case           
                
                # # Bitmask
                # get_length = str(int(math.floor(self.pd_library["Protocols"][protocol]['Packet Types'][packet_type]['Fields'][get_fields[n]]['Length']/8)))
                # table_item = QtWidgets.QTableWidgetItem(get_length)
                # table_item.setTextAlignment(QtCore.Qt.AlignCenter)
                # self.tableWidget_pd_dissectors.setItem(n,2,table_item)
            
        # Resize
        self.tableWidget_pd_dissectors.resizeColumnsToContents()
        self.tableWidget_pd_dissectors.horizontalHeader().setStretchLastSection(False)
        self.tableWidget_pd_dissectors.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_pd_dissectors.resizeRowsToContents()
                
    def _slotLibraryAddBrowseClicked(self):
        """ Opens a file dialog to choose an existing python file for demodulating the protocol.
        """            
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + '/Flow Graph Library/PD Flow Graphs'  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['Flow Graphs (*.py)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:
            self.textEdit_library_pd_demodulation_fg.setPlainText(str(folder))            
        except:
            pass
            
    def _slotPD_BufferSizeUpdate(self, buffer_size):
        """ Updates the status labels of the Dashboard with the latest protocol discovery buffer size.
        """       
        # Protocol Discovery Progress Bars
        self.progressBar_pd_status_buffer.setValue(int(buffer_size))
        self.progressBar_bit_slicing_buffer.setValue(int(buffer_size))
                
    def _slotPD_StatusBufferApplyClicked(self):
        """ Updates Protocol Discovery with the new buffer size limits.
        """
        # Get the Min/Max Sizes
        min_buffer = str(self.textEdit_pd_status_min_buffer_size.toPlainText())
        max_buffer = str(self.textEdit_pd_status_buffer_size.toPlainText())
        
        # Send the Message
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Set Buffer Size', Parameters = [min_buffer, max_buffer])
        
        # Insert Message into the Status Window
        get_text = time.strftime('%H:%M:%S', time.localtime()) + ": Applying Changes to Buffer Limits...\n"
        self._slotPD_AddStatus(get_text)
        
        # Adjust Protocol Discovery Progress Bars
        self.progressBar_pd_status_buffer.setMaximum(int(max_buffer))
        self.progressBar_bit_slicing_buffer.setMaximum(int(max_buffer))
        
    def _slotPD_StatusBufferClearClicked(self):
        """ Clears the Protocol Discovery buffer.
        """
        # Send the Message
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Clear PD Buffer')
        
        # Insert Message into the Status Window
        get_text = time.strftime('%H:%M:%S', time.localtime()) + ": Clearing Buffer...\n"
        self._slotPD_AddStatus(get_text)
        
    def _slotPD_BitSlicingCandidateDoubleClicked(self, row, col):
        """ This will update the preamble text edit box for bit slicing with the item that was double clicked in the "Candidate Preambles" table.
        """
        # Update the Edit Box
        self.textEdit_pd_bit_slicing_recommended_preamble.setPlainText(str(self.tableWidget_pd_bit_slicing_candidate_preambles.item(row,col).text()))
        
    def _slotPD_BitSlicingAllPreamblesDoubleClicked(self, row, col):
        """ This will update the preamble text edit box for bit slicing with the item that was double clicked in the "All Preambles" table.
        """
        # Update the Edit Box
        self.textEdit_pd_bit_slicing_recommended_preamble.setPlainText(str(self.tableWidget_pd_bit_slicing_preamble_stats.item(row,0).text()))
                   
    def _slotPD_StatusSearchLibraryClicked(self):
        """ Populates the Search Library Fields with the current SOI.
        """
        # Set the Fields
        self._slotLibrarySearchCurrentSOI_Clicked()
        
        # Change the Tab
        self.tabWidget_library.setCurrentIndex(2)
        self.tabWidget.setCurrentIndex(7)
        
    def _slotLibrarySearchCurrentSOI_Clicked(self):
        """ Populates the Search Library Fields with the current SOI.
        """
        # Set the Fields
        if len(self.target_soi) > 0:
            self.textEdit_library_search_frequency.setPlainText(self.target_soi[0])
            self.textEdit_library_search_modulation.setPlainText(self.target_soi[1])
            self.textEdit_library_search_bandwidth.setPlainText(self.target_soi[2])
            
            if self.target_soi[3] == "True":
                self.comboBox_library_search_continuous.setCurrentIndex(0)
            else:
                self.comboBox_library_search_continuous.setCurrentIndex(1)
                
            self.textEdit_library_search_start_frequency.setPlainText(self.target_soi[4])
            self.textEdit_library_search_end_frequency.setPlainText(self.target_soi[5])
        
    def _slotPD_BitSlicingSearchLibraryClicked(self):
        """ Takes the currently select field in the bit slicing table and puts it in the field data search box in the search tab.
        """
        # Get the Selected Items
        get_items = self.tableWidget_pd_bit_slicing_packets.selectedItems()
        
        # Get Selected Item Ranges
        selection_range = self.tableWidget_pd_bit_slicing_packets.selectedRanges()[0]
                
        # Get the First Column
        first_column = selection_range.leftColumn()
        
        if len(get_items) > 0:
            # Append Each Item
            new_text = ""
            for n in range(0,len(get_items)):
                # Get the Data as Binary
                get_data = str(get_items[n].text())
                if self.bit_slicing_column_type[first_column + n] == "Binary":
                    new_text += get_data
                else:                
                    bin_str = bin(int(get_data, 16))[2:].zfill(int(len(get_data)*4))
                    new_text += bin_str
                
            # Change the EditBox and Radio Button
            self.textEdit_library_search_field_value.setPlainText("")
            self.radioButton_library_search_binary.setChecked(True)
            self.textEdit_library_search_field_value.setPlainText(new_text)            
            
            # Change the Tab
            self.tabWidget_library.setCurrentIndex(2)
            self.tabWidget.setCurrentIndex(7)
            
    def _slotLibraryAddCurrentSOI_Clicked(self):
        """ Updates the edit boxes in the SOI Data section of the "Add to Library" tab with the current SOI information.
        """
        # Insert the Information
        if str(self.textEdit_pd_status_target.toPlainText()) != "":    
            if len(self.target_soi) > 0:        
                self.textEdit_library_pd_soi_frequency.setPlainText(self.target_soi[0])
                self.textEdit_library_pd_soi_modulation.setPlainText(self.target_soi[1])
                self.textEdit_library_pd_soi_bandwidth.setPlainText(self.target_soi[2])
                
                if self.target_soi[3] == "True":
                    self.comboBox_library_pd_soi_continuous.setCurrentIndex(0)
                else:
                    self.comboBox_library_pd_soi_continuous.setCurrentIndex(1)
                            
                self.textEdit_library_pd_soi_start_frequency.setPlainText(self.target_soi[4])
                self.textEdit_library_pd_soi_end_frequency.setPlainText(self.target_soi[5])
                self.textEdit_library_pd_soi_notes.setPlainText(self.target_soi[6])
                
    def _slotPD_DemodulationCurrentSOI_Clicked(self):
        """ Updates the edit boxes in the Flow Graph Lookup section of the "Flow Graphs" tab with the current SOI information.
        """
        # Display the Current Signal of Interest
        if len(self.target_soi) > 0:
            self.textEdit_pd_flow_graphs_frequency.setPlainText(self.target_soi[0])
            self.textEdit_pd_flow_graphs_modulation.setPlainText(self.target_soi[1])
            self.textEdit_pd_flow_graphs_bandwidth.setPlainText(self.target_soi[2])
            
            if self.target_soi[3] == "True":
                self.comboBox_pd_flow_graphs_continuous.setCurrentIndex(0)
            else:
                self.comboBox_pd_flow_graphs_continuous.setCurrentIndex(1)
            
            self.textEdit_pd_flow_graphs_start_frequency.setPlainText(self.target_soi[4])
            self.textEdit_pd_flow_graphs_end_frequency.setPlainText(self.target_soi[5])
        
    def _slotPD_BitSlicingSliceClicked(self, slicing_interval=0):
        """ Divides the remaining bits in the bit slicing table by byte.
        """        
        # Get the Slicing Interval
        if slicing_interval == 0:
            slicing_interval = int(self.spinBox_pd_bit_slicing_interval.value())
        
        # Divide the Bits
        column_text = ""
        for col in range(0,self.tableWidget_pd_bit_slicing_packets.columnCount()):
            # Get the Data as Binary
            get_data = str(self.tableWidget_pd_bit_slicing_packets.item(0,col).text())
            if self.bit_slicing_column_type[col] == "Binary":
                column_text += get_data
            else:                
                bin_str = bin(int(get_data, 16))[2:].zfill(int(len(get_data)*4))
                column_text += bin_str
        byte_list = [column_text[i:i+slicing_interval] for i in range(0, len(column_text), slicing_interval)] 
            
        # Add Field Delineations
        field_delineations = [0]
        for n in range(0,len(byte_list)):
            field_delineations.append((n+1)*slicing_interval)
                            
        # Update the Tables
        self._slotPD_BitSlicingDetectFieldsClicked(field_delineations[:-1])
        
    def _slotPD_BitSlicingMergeFieldsClicked(self):
        """ Assigns a field to the highlighted text in the bit slicing table.
        """        
        # Get Selected Items
        selection_range = self.tableWidget_pd_bit_slicing_packets.selectedRanges()[0]
                
        # Get the Unique Columns
        first_column = selection_range.leftColumn()
        last_column = selection_range.rightColumn()
        
        # Insert the Text/Bits to the First Column
        if first_column < last_column:                    
            for row in range(0,self.tableWidget_pd_bit_slicing_packets.rowCount()):
                new_text = ""            
                for col in range(first_column,last_column+1):
                    # Get the Data as Binary
                    get_data = str(self.tableWidget_pd_bit_slicing_packets.item(row,col).text())
                    if self.bit_slicing_column_type[col] == "Binary":
                        new_text += get_data
                    else:                
                        bin_str = bin(int(get_data, 16))[2:].zfill(int(len(get_data)*4))
                        new_text += bin_str
                
                # Set the Text
                table_item = QtWidgets.QTableWidgetItem(new_text)
                table_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.tableWidget_pd_bit_slicing_packets.setItem(row,first_column,table_item) 
                
            # Delete the Columns and Field Delineations
            for col in reversed(range(first_column+1,last_column+1)):
                self.tableWidget_pd_bit_slicing_packets.removeColumn(col)            
                self.tableWidget_pd_bit_slicing_field_delineations.removeRow(col)
                
                # Move the Colors to the End
                self.suitable_colors.insert(-1, self.suitable_colors.pop(col))  # Keeps the same color order for the other columns
            
        # Refresh the Table
        self._slotPD_BitSlicingRefreshClicked()
    
    def _slotPD_BitSlicingSplitFieldsClicked(self):
        """ Unassigns a field in the bit slicing table.
        """       
        # Get Selected Items
        selection_range = self.tableWidget_pd_bit_slicing_packets.selectedRanges()[0]
                
        # Get the Unique Columns
        first_column = selection_range.leftColumn()
        last_column = selection_range.rightColumn()
        
        # Get the Split Interval
        split_interval = int(self.spinBox_pd_bit_slicining_split_interval.value())
        
        # Get the Combined Text
        new_text = ""            
        for col in range(first_column,last_column+1):
            # Get the Data as Binary
            get_data = str(self.tableWidget_pd_bit_slicing_packets.item(0,col).text())
            if self.bit_slicing_column_type[col] == "Binary":
                new_text += get_data
            else:                
                bin_str = bin(int(get_data, 16))[2:].zfill(int(len(get_data)*4))
                new_text += bin_str

        # Divide the Bits
        bit_list = [new_text[i:i+split_interval] for i in range(0, len(new_text), split_interval)] 
                   
        # Remove Split Field Delineations
        first_location = int(self.tableWidget_pd_bit_slicing_field_delineations.item(first_column,0).text())
        for row in reversed(range(first_column,last_column+1)):
            self.tableWidget_pd_bit_slicing_field_delineations.removeRow(row)
                
        # Move the First Color to the End
        self.suitable_colors.insert(-1, self.suitable_colors.pop(first_column)) 
        
        # Add Field Delineations
        for col in range(first_column,first_column+len(bit_list)):
            # Insert a Row
            self.tableWidget_pd_bit_slicing_field_delineations.insertRow(col)
            
            # Set the Text
            table_item = QtWidgets.QTableWidgetItem(str((col-first_column)*split_interval+first_location))
            table_item.setTextAlignment(QtCore.Qt.AlignCenter)
            self.tableWidget_pd_bit_slicing_field_delineations.setItem(col,0,table_item) 
            
            # Move the Colors from the End
            self.suitable_colors.insert(col, self.suitable_colors.pop(-1))  # Keeps the same color order for the other columns
            
        # Refresh the Table
        self._slotPD_BitSlicingRefreshClicked()
        
    def _slotPD_BitSlicingColumnClicked(self,col):
        """ Toggles the contents of the bit slicing table between binary and hex.
        """  
        # Toggle the Text
        stay_binary = False
        for row in range(0,self.tableWidget_pd_bit_slicing_packets.rowCount()):
            # Get the Data 
            get_data = str(self.tableWidget_pd_bit_slicing_packets.item(row,col).text())
             
            # Hex to Binary
            if self.bit_slicing_column_type[col] == "Hex":
                bin_str = bin(int(get_data, 16))[2:].zfill(int(len(get_data)*4))
                #~ bin_str_spaces = ' '.join([bin_str[i:i+4] for i in range(0, len(bin_str), 4)])
                self.tableWidget_pd_bit_slicing_packets.item(row,col).setText(bin_str)
                
            # Binary to Hex    
            elif self.bit_slicing_column_type[col] == "Binary":
                get_data = get_data.replace(' ', '')
                if len(get_data) % 4 == 0:
                    hex_str = '%0*X' % ((len(get_data) + 3) // 4, int(get_data, 2))
                    self.tableWidget_pd_bit_slicing_packets.item(row,col).setText(hex_str)  
                else:
                    stay_binary = True
        
        # Save the Field Type
        if self.bit_slicing_column_type[col] == "Hex":
            self.bit_slicing_column_type[col] = "Binary"
            
            # Change the Header Font Color to Red
            header_item = QtWidgets.QTableWidgetItem(self.colnum_string(col+1))
            header_item.setTextAlignment(QtCore.Qt.AlignCenter)
            header_item.setForeground(QtGui.QColor(255,0,0))
            self.tableWidget_pd_bit_slicing_packets.setHorizontalHeaderItem(col,header_item)             
            
        else:
            if stay_binary == False:
                self.bit_slicing_column_type[col] = "Hex"
                
                # Change the Header Font Color to Black
                header_item = QtWidgets.QTableWidgetItem(self.colnum_string(col+1))
                header_item.setTextAlignment(QtCore.Qt.AlignCenter)
                header_item.setForeground(QtGui.QColor(0,0,0))
                self.tableWidget_pd_bit_slicing_packets.setHorizontalHeaderItem(col,header_item)      
                            
        # Resize the Table
        self.tableWidget_pd_bit_slicing_packets.resizeColumnsToContents() 
        self.tableWidget_pd_bit_slicing_packets.horizontalHeader().setStretchLastSection(False)
        self.tableWidget_pd_bit_slicing_packets.horizontalHeader().setStretchLastSection(True)
        
    def _slotLibrarySearchBinaryClicked(self):
        """ Converts the PD Search Field Values edit box to binary.
        """
        try:
            # Convert to Binary
            get_data = str(self.textEdit_library_search_field_value.toPlainText())
            get_data = get_data.replace(' ','')
            bin_str = bin(int(get_data, 16))[2:].zfill(int(len(get_data)*4))
            self.textEdit_library_search_field_value.setPlainText(bin_str)
        except:
            pass
            
    def _slotLibrarySearchHexClicked(self):
        """ Converts the PD Search Field Values edit box to hex.
        """
        try:
            # Convert to Hex
            get_data = str(self.textEdit_library_search_field_value.toPlainText())
            get_data = get_data.replace(' ','')
            hex_str = '%0*X' % ((len(get_data) + 3) // 4, int(get_data, 2))
            self.textEdit_library_search_field_value.setPlainText(hex_str)      
        except:
            pass
            
    def _slotPD_DissectorsNewClicked(self):
        """ Loads the dissector editor with default values.
        """
        # Repopulate the Contents
        self._slotPD_DissectorsPacketTypeChanged()
                
        # Make the Groupbox Visible
        self.frame_pd_dissectors_editor.setVisible(True)
        
    def _slotPD_DissectorsEditClicked(self):
        """ Loads the currently selected dissector for manual editing.
        """
        # Browse for a Lua Dissector
        directory = os.path.dirname(os.path.realpath(__file__)) + "/Dissectors/"  # Default Directory
        fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select Dissector...", directory, filter="Lua Dissector (*.lua);;All Files (*.*)")[0]
            
        # Open the Dissector in Gedit
        if fname != "":    
            osCommandString = "gedit " + str(fname)
            os.system(osCommandString+ " &")                      

    def _slotTSI_DetectorStartClicked(self):
        """ Toggles the TSI identifier and classifier on and off.
        """
        # Turn off TSI Detector
        if self.pushButton_tsi_detector_start.text() == "Stop":
            # Send the Message
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop TSI Detector')
            self.status_dialog.tableWidget_status_results.item(1,0).setText("Not Running")
            self.label_tsi_detector.setText("Detector - Not Running")
            self.label_tsi_classifier.setText("Classifier - Not Running")
            self.label_tsi_detector.raise_()
            self.label_tsi_classifier.raise_()
        
            # Change the Button Text
            self.pushButton_tsi_detector_start.setText("Start")
                        
            # Update the Labels
            self.label_tsi_current_band.setText("")
            self.label_tsi_current_frequency.setText("")
            
            # Disable Update TSI Configuration Pushbutton
            self.pushButton_tsi_update.setEnabled(False)
            self.pushButton_tsi_update.setStyleSheet("")
                        
            # Enable Comboboxes
            self.comboBox_tsi_detector.setEnabled(True)
            
            # Hide Update Configuration Label
            self.label_tsi_update_configuration.setVisible(False)
            
            # Refresh Axes
            #self._slotTSI_RefreshPlotClicked()
            
            # Enable the Advanced Options
            self.frame_tsi_detector_settings1.setEnabled(True)
            
        # Turn on TSI Detector
        elif self.pushButton_tsi_detector_start.text() == "Start":
            # Get Detector
            get_detector = str(self.comboBox_tsi_detector.currentText())
            
            # IQ File is Different
            if get_detector == "IQ File":                
                # Get Variable Names and Values
                variable_names = ['rx_freq','sample_rate', 'threshold', 'fft_size','filepath']
                get_sample_rate = str(self.textEdit_tsi_detector_iq_file_sample_rate.toPlainText())
                get_frequency = str(self.textEdit_tsi_detector_iq_file_frequency.toPlainText())
                get_threshold = str(self.spinBox_tsi_detector_iq_file_threshold.value())
                get_fft_size = str(self.comboBox_tsi_detector_iq_file_fft_size.currentText())
                get_filepath = str(self.textEdit_tsi_detector_iq_file_file.toPlainText())
                variable_values = [get_frequency, get_sample_rate, get_threshold, get_fft_size, get_filepath]

                # Valid Filepath                    
                if get_filepath == "":
                    msgBox = MyMessageBox(my_text = " Choose an IQ file.", height = 75, width = 140)
                    msgBox.exec_() 
                    return
                    
            elif get_detector == "Simulator":                
                # Get Variable Names and Values
                variable_names = ['filepath']
                get_filepath = str(self.textEdit_tsi_detector_csv_file.toPlainText())
                variable_values = [get_filepath]

                # Valid Filepath                    
                if get_filepath == "":
                    msgBox = MyMessageBox(my_text = " Choose a CSV file.", height = 75, width = 140)
                    msgBox.exec_() 
                    return                    
                    
            else:                
                # No Hardware Selected
                if len(self.dashboard_settings_dictionary['hardware_ip_tsi']) == 0 and len(self.dashboard_settings_dictionary['hardware_serial_tsi']) == 0 \
                    and ('x310' in get_detector) and ('b210' in get_detector):
                    
                    error_text = " Fill out the IP address or serial number by clicking the TSI hardware button."
                    
                    # Create a Dialog Window    
                    msgBox = MyMessageBox(my_text = error_text, height = 100, width = 510)
                    msgBox.exec_() 
                    return
                    
                # Valid Hardware
                else:
                    # Get Variable Names and Values
                    variable_names = ['rx_freq','sample_rate', 'threshold', 'fft_size','gain','channel','antenna']
                    get_sample_rate = str(self.textEdit_tsi_detector_fg_sample_rate.toPlainText())
                    get_threshold = str(self.spinBox_tsi_detector_fg_threshold.value())
                    get_fft_size = str(self.comboBox_tsi_detector_fg_fft_size.currentText())
                    get_gain = str(self.spinBox_tsi_detector_fg_gain.value())
                    get_channel = str(self.comboBox_tsi_detector_fg_channel.currentText())
                    get_antenna = str(self.comboBox_tsi_detector_fg_antenna.currentText())
                    variable_values = ['1.2e9',get_sample_rate, get_threshold, get_fft_size, get_gain, get_channel, get_antenna]
                    
                    # Hardware IP Address
                    variable_names.append('ip_address')
                    variable_values.append(self.dashboard_settings_dictionary['hardware_ip_tsi'])
                        
                    # Hardware Serial
                    if len(self.dashboard_settings_dictionary['hardware_serial_tsi']) > 0:
                        if self.dashboard_settings_dictionary['hardware_tsi'] == "HackRF":
                            get_serial = self.dashboard_settings_dictionary['hardware_serial_tsi']
                        else:
                            get_serial = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_tsi']                               
                    else:
                        if self.dashboard_settings_dictionary['hardware_tsi'] == "HackRF":
                            get_serial = ""  
                        else:
                            get_serial = "False"  
                    variable_names.append('serial')
                    variable_values.append(get_serial)

            # Disable Comboboxes
            self.comboBox_tsi_detector.setEnabled(False)
                       
            # Send the Message
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Start TSI Detector', Parameters = [get_detector, variable_names, variable_values])
            self.status_dialog.tableWidget_status_results.item(1,0).setText("Running TSI") 
            self.label_tsi_detector.setText("Detector - Running")
            self.label_tsi_detector.raise_()
            
            # Change the Button Text
            self.pushButton_tsi_detector_start.setText("Stop")
            
            # Enable Update TSI Configuration Pushbutton
            if self.tableWidget_tsi_scan_options.columnCount() > 0:
                self.pushButton_tsi_update.setEnabled(True)
                self.pushButton_tsi_update.setStyleSheet("border: 1px solid darkGray; border-radius: 6px; background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #ffff00, stop: 1 #d8d800); min-width: 80px;")
                
            # Show Update Configuration Label
            if (str(self.comboBox_tsi_detector.currentText()) == "Simulator") or (str(self.comboBox_tsi_detector.currentText()) == "IQ File"):
                self.label_tsi_update_configuration.setVisible(False)
            else:
                self.label_tsi_update_configuration.setVisible(True)
            
            # Disable the Advanced Options
            self.frame_tsi_detector_settings1.setEnabled(False)
            

        
    def _slotTSI_ClearDetectorPlotClicked(self):
        """ Clears the points on the detector plot.
        """
        # Clear the Narrowband Array
        self.wideband_data =  np.ones((self.wideband_height,self.wideband_width,3))

        # Plot and Draw Incoming Wideband Signals
        self.matplotlib_widget.axes.cla()
        self.matplotlib_widget.axes.imshow(self.wideband_data, cmap='rainbow', clim=(-100,30))                            
        self.matplotlib_widget.configureAxes(title='Detector History',xlabel='Frequency (MHz)',ylabel='Time Elapsed (s)', xlabels=['0', '','1000', '', '2000', '', '3000', '', '4000', '', '5000', '', '6000'],ylabels=['0', '5', '10', '15', '20', '25', '30', '35', '40'],ylim=self.wideband_height)
        self.matplotlib_widget.draw()  
            
    def _slotPD_BitSlicingPlotEntropyClicked(self):
        """ Sends a message to the HIPRFISR/PD to calculate the entropy for the bit positions of fixed-length messages in the buffer when sliced by the preamble.
        """
        # Get the Preamble
        get_preamble = str(self.textEdit_pd_bit_slicing_recommended_preamble.toPlainText())
        
        # Get the Message Length
        get_row = self.tableWidget_pd_bit_slicing_lengths.currentRow()
        get_message_length = int(self.tableWidget_pd_bit_slicing_lengths.item(get_row,0).text())
        
        # Send the Message
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Find Entropy', Parameters = [get_message_length, get_preamble])
        
    def _slotPD_BitSlicingEntropyReturn(self, entropy_data):
        """ Plots the entropy for the bit positions upon receiving the message from Protocol Discovery.
        """
        # Convert String to Float List
        entropy_data = ast.literal_eval(entropy_data)
        entropy_data_float = [float(i) for i in entropy_data]        
        
        # Create a Modeless Dialog Window    
        plotBox = MyPlotWindow(self.tabWidget, entropy_data)
        plotBox.exec_()          
        
    def _slotPD_BitSlicingShiftLeftClicked(self):
        """ Shifts the data in the bit slicing table to the left one bit (circular shift).
        """
        # Update the Shift Counter
        self.bit_shift_counter -= 1
        shifted_data = []
        
        # Get Length Value
        get_row = self.tableWidget_pd_bit_slicing_lengths.currentRow()
        length_item_value = int(self.tableWidget_pd_bit_slicing_lengths.item(get_row,0).text())   
        
        # Shift the Data to the Left        
        if self.bit_shift_counter < 0:        
            for n in range(0,len(self.first_n_packets[length_item_value])):
                shifted_data.append(self.first_n_packets[length_item_value][n][-self.bit_shift_counter:] + self.first_n_packets[length_item_value][n][0:-self.bit_shift_counter])
                
        # Shift the Data to the Right
        elif self.bit_shift_counter > 0:
            for n in range(0,len(self.first_n_packets[length_item_value])):
                shifted_data.append(self.first_n_packets[length_item_value][n][-self.bit_shift_counter] + self.first_n_packets[length_item_value][n][0:-self.bit_shift_counter+1])
            
        # Original Data
        else:
            shifted_data = self.first_n_packets[length_item_value]
            
        # Redraw the Table
        self._slotPD_BitSlicingDetectFieldsClicked(False, shifted_data)
        
    def _slotPD_BitSlicingShiftRightClicked(self):
        """ Shifts the data in the bit slicing table to the right one bit (circular shift).
        """
       # Update the Shift Counter
        self.bit_shift_counter += 1
        shifted_data = []
        
        # Get Length Value
        get_row = self.tableWidget_pd_bit_slicing_lengths.currentRow()
        length_item_value = int(self.tableWidget_pd_bit_slicing_lengths.item(get_row,0).text())   
        
        # Shift the Data to the Left        
        if self.bit_shift_counter < 0:        
            for n in range(0,len(self.first_n_packets[length_item_value])):
                shifted_data.append(self.first_n_packets[length_item_value][n][-self.bit_shift_counter:] + self.first_n_packets[length_item_value][n][0:-self.bit_shift_counter])
                
        # Shift the Data to the Right
        elif self.bit_shift_counter > 0:
            for n in range(0,len(self.first_n_packets[length_item_value])):
                shifted_data.append(self.first_n_packets[length_item_value][n][-self.bit_shift_counter] + self.first_n_packets[length_item_value][n][0:-self.bit_shift_counter+1])
            
        # Original Data
        else:
            shifted_data = self.first_n_packets[length_item_value]
            
        # Redraw the Table
        self._slotPD_BitSlicingDetectFieldsClicked(False, shifted_data)
        
    def _slotTSI_TabChanged(self):
        """ Used to clear the new classifications notification in the detector/classifier tabwidget.
        """
        # Delete the New Classifications Notification
        if self.tabWidget_tsi.currentIndex() == 0:
            self.tabWidget_tsi.setTabText(0,"Detector")
            self.new_detections = 0   
            
        #elif self.tabWidget_tsi.currentIndex() == 1:
        #    self.tabWidget_tsi.setTabText(1,"Feature Extractor")
            
        elif self.tabWidget_tsi.currentIndex() == 3:
            self.tabWidget_tsi.setTabText(3,"Classifier")
            self.new_classifications = 0    
               
    def _slotTSI_BandID_Returned(self, get_message):
        """ Updates the search bands plot with the current band and center frequency of the detector.
        """
        if self.pushButton_tsi_detector_start.text() == "Stop":
            
            #self.tuning_matplotlib_widget.axes.cla()  # TEST
            
            # Get the Band and Current Frequency
            band_id = ast.literal_eval(get_message)[0]
            center_freq = ast.literal_eval(get_message)[1]
            center_freq = round(float(center_freq)/1e6,2)  # In MHz, two decimal places
            
            # Update the Labels
            self.label_tsi_current_band.setText(str(band_id))
            self.label_tsi_current_frequency.setText(str(center_freq) + " MHz")
            
            # Change the Band Text in the Plot
            for col in range(0,len(self.tuning_matplotlib_widget.bands)):           
                ## Get Band Position
                #start_x,y = self.tuning_matplotlib_widget.bands[col].get_xy()
                    
                # Change the Band Labels
                if band_id-1 < len(self.tuning_matplotlib_widget.axes.texts):
                    if col == band_id-1:
                        self.tuning_matplotlib_widget.axes.texts[col].set_color('red')
                    else:
                        self.tuning_matplotlib_widget.axes.texts[col].set_color('black')
                        
            # Update Tuner
            get_bandwidth = int(float(str(self.textEdit_tsi_detector_fg_sample_rate.toPlainText()))/1000000)
            if get_bandwidth < 1:
                get_bandwidth = 1
            self.tuning_matplotlib_widget.updateTuned(int(band_id),int(center_freq),get_bandwidth)  # Rectangle width = sample_rate in MS/s rounded down
                            
            # Redraw the Plot
            self.tuning_matplotlib_widget.draw()    
            
    def _slotIQ_RefreshClicked(self):
        """ Reloads the files in the current folder of IQ Recordings
        """
        try:
            # Get the Folder Location
            get_folder = str(self.label_iq_folder.text())
                
            # Get the Files for the Listbox
            self.listWidget_iq_files.clear()
            temp_names = []
            for fname in os.listdir(get_folder):
                if os.path.isfile(get_folder+"/"+fname):
                    temp_names.append(fname)
                  
            # Sort and Add to the Listbox
            temp_names = sorted(temp_names)
            for n in temp_names:
                self.listWidget_iq_files.addItem(n)
                    
            # Set the Listbox Selection
            self.listWidget_iq_files.setCurrentRow(0)
        except:
            pass
            
    def _slotPD_StatusAddPubClicked(self):
        """ Connects the PD SUB socket to another PUB socket.
        """        
        # Check IP and Port
        ip_address = str(self.textEdit_pd_status_ip_address.toPlainText())
        port = str(self.textEdit_pd_status_port.toPlainText())
        full_address = ip_address + ":" + port
        
        address_exists = False
        if self.listWidget_pd_status_current_pubs.count() > 0:
            for n in range(0,self.listWidget_pd_status_current_pubs.count()):
                if full_address == str(self.listWidget_pd_status_current_pubs.item(n).text()):
                    address_exists = True
            
        if address_exists == False:
            # Send Message to HIPRFISR/Protocol Discovery
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Add Pub Socket', Parameters = [ip_address, port])
            
            # Add it to the List Widget
            self.listWidget_pd_status_current_pubs.addItem(full_address)
                    
    def _slotPD_StatusRemovePubClicked(self):
        """ Disconnects the selected PUB from the Protocol Discovery SUB.
        """
        if self.listWidget_pd_status_current_pubs.count() > 0:
            # Send Message to HIPRFISR/Protocol Discovery
            get_pub_address = str(self.listWidget_pd_status_current_pubs.currentItem().text())
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Remove Pub Socket', Parameters = [get_pub_address])
            
            # Remove the Item
            self.listWidget_pd_status_current_pubs.takeItem(self.listWidget_pd_status_current_pubs.currentRow())
            
    def _slotAutomationManualClicked(self):
        """ Changes the automation mode of the system to Manual.
        """
        # Change the Button Colors
        self.pushButton_automation_discovery.setStyleSheet("")
        self.pushButton_automation_target.setStyleSheet("")
        self.pushButton_automation_custom.setStyleSheet("")
        self.pushButton_automation_manual.setStyleSheet("border: 1px solid darkGray; border-radius: 6px; background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #ffb477, stop: 1 #db8d4e); min-width: 80px;")
        
        # Automation Settings
        self.label_automation_automation_mode_description.setText("User confirms all phases and can edit parameters.")
                    
        self.checkBox_automation_auto_start_tsi.setChecked(False)
        self.checkBox_automation_auto_start_tsi.setEnabled(False)
        
        self.checkBox_automation_auto_select_sois.setChecked(False)
        self.checkBox_automation_auto_select_sois.setEnabled(False)
        self._slotAutomationAutoSelectSOIsClicked()
        
        self.checkBox_automation_auto_select_pd_flow_graphs.setChecked(False)
        self.checkBox_automation_auto_select_pd_flow_graphs.setEnabled(False)
        self._slotAutomationAutoSelectPD_FlowGraphsClicked()
        
        self.checkBox_automation_auto_start_pd.setChecked(False)
        self.checkBox_automation_auto_start_pd.setEnabled(False)
        self._slotAutomationAutoStartPD_Clicked()
                    
        # Targeting Settings
        self.label_automation_target_protcol.setEnabled(True)
        self.comboBox_automation_target_protocol.setEnabled(True)
        
        # System Status
        self.status_dialog.tableWidget_status_results.item(0,0).setText("Manual")
                            
        # Control Over Flow Graph Tab
        self.frame_flow_graph.setEnabled(True)       
        
        # Save Automation Mode
        self.dashboard_settings_dictionary['startup_automation_mode'] = "Manual"
        
    def _slotAutomationDiscoveryClicked(self):
        """ Changes the automation mode of the system to Discovery.
        """
        # Change the Button Colors
        self.pushButton_automation_manual.setStyleSheet("")
        self.pushButton_automation_target.setStyleSheet("")
        self.pushButton_automation_custom.setStyleSheet("")
        self.pushButton_automation_discovery.setStyleSheet("border: 1px solid darkGray; border-radius: 6px; background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #ffb477, stop: 1 #db8d4e); min-width: 80px;")
            
        # Automation Settings
        self.label_automation_automation_mode_description.setText("Mostly automated. System chooses which signals to target and process.")

        self.checkBox_automation_auto_start_tsi.setChecked(True)
        self.checkBox_automation_auto_start_tsi.setEnabled(False)
        
        self.checkBox_automation_auto_select_sois.setChecked(True)
        self.checkBox_automation_auto_select_sois.setEnabled(False)
        self._slotAutomationAutoSelectSOIsClicked()
        
        self.tableWidget_automation_soi_list_priority.setEnabled(True)
        self.tableWidget_automation_soi_list_priority.setVisible(True)
        
        self.label_soi_list_priority.setEnabled(True)
        self.label_soi_list_priority.setVisible(True)
                
        self.checkBox_automation_auto_start_pd.setChecked(True)
        self.checkBox_automation_auto_start_pd.setEnabled(False)
        self._slotAutomationAutoStartPD_Clicked()
        
        self.checkBox_automation_auto_select_pd_flow_graphs.setChecked(True)
        self.checkBox_automation_auto_select_pd_flow_graphs.setEnabled(False)
        self._slotAutomationAutoSelectPD_FlowGraphsClicked()
                    
        # Targeting Settings    
        self.label_automation_target_protcol.setEnabled(False)
        self.comboBox_automation_target_protocol.setEnabled(False)
        self.comboBox_automation_target_protocol.setCurrentIndex(0)
        self.tableWidget_automation_soi_list_priority.setColumnHidden(2,True)
        self.tableWidget_automation_soi_list_priority.setRowHidden(1,True)
        self.tableWidget_automation_soi_list_priority.setRowHidden(2,True)
        self.tableWidget_automation_soi_list_priority.resizeColumnsToContents()
        self.tableWidget_automation_soi_list_priority.resizeRowsToContents()
        self.tableWidget_automation_soi_list_priority.horizontalHeader().setStretchLastSection(False)
        self.tableWidget_automation_soi_list_priority.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_automation_soi_list_priority.cellWidget(0,0).setCurrentIndex(0)
        self.tableWidget_automation_soi_list_priority.cellWidget(0,1).setCurrentIndex(0)
        self.tableWidget_automation_soi_list_priority.cellWidget(0,0).setEnabled(False)
        self.tableWidget_automation_soi_list_priority.cellWidget(0,1).setEnabled(False)
        self.pushButton_automation_soi_priority_add_level.setEnabled(False)
        self.pushButton_automation_soi_priority_remove_level.setEnabled(False)
        self.label_soi_priority_row2.setVisible(False)
        self.label_soi_priority_row3.setVisible(False)
        
        # System Status
        self.status_dialog.tableWidget_status_results.item(0,0).setText("Discovery")
                                    
        # Control Over Flow Graph Tab
        self.frame_flow_graph.setEnabled(False)  
        
        # Save Automation Mode
        self.dashboard_settings_dictionary['startup_automation_mode'] = "Discovery"
                              
    def _slotAutomationTargetClicked(self):
        """ Changes the automation mode of the system to Target.
        """
        # Change the Button Colors
        self.pushButton_automation_manual.setStyleSheet("")
        self.pushButton_automation_discovery.setStyleSheet("")
        self.pushButton_automation_custom.setStyleSheet("")
        self.pushButton_automation_target.setStyleSheet("border: 1px solid darkGray; border-radius: 6px; background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #ffb477, stop: 1 #db8d4e); min-width: 80px;")
        
        # Automation Settings
        self.label_automation_automation_mode_description.setText("User-defined specifications. Only pursue targets fitting certain criteria.")

        self.checkBox_automation_auto_start_tsi.setChecked(True)
        self.checkBox_automation_auto_start_tsi.setEnabled(False)
        
        self.checkBox_automation_auto_select_sois.setChecked(True)
        self.checkBox_automation_auto_select_sois.setEnabled(False)
        self._slotAutomationAutoSelectSOIsClicked()
        
        self.tableWidget_automation_soi_list_priority.setEnabled(True)
        self.tableWidget_automation_soi_list_priority.setVisible(True)
        
        self.label_soi_list_priority.setEnabled(True)
        self.label_soi_list_priority.setVisible(True)
        
        self.checkBox_automation_auto_select_pd_flow_graphs.setChecked(True)
        self.checkBox_automation_auto_select_pd_flow_graphs.setEnabled(False)
        self._slotAutomationAutoSelectPD_FlowGraphsClicked()
        
        self.checkBox_automation_auto_start_pd.setChecked(True)
        self.checkBox_automation_auto_start_pd.setEnabled(False)
        self._slotAutomationAutoStartPD_Clicked()
                                
        # Targeting Settings
        self.label_automation_target_protcol.setEnabled(True)
        self.comboBox_automation_target_protocol.setEnabled(True)
        self.tableWidget_automation_soi_list_priority.setColumnHidden(2,False)
        self.tableWidget_automation_soi_list_priority.setRowHidden(1,False)
        self.tableWidget_automation_soi_list_priority.setRowHidden(2,False)
        self.tableWidget_automation_soi_list_priority.resizeColumnsToContents()
        self.tableWidget_automation_soi_list_priority.resizeRowsToContents()
        self.tableWidget_automation_soi_list_priority.horizontalHeader().setStretchLastSection(False)
        self.tableWidget_automation_soi_list_priority.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_automation_soi_list_priority.cellWidget(self.tableWidget_automation_soi_list_priority.rowCount()-1,0).setEnabled(True)
        self.tableWidget_automation_soi_list_priority.cellWidget(0,1).setEnabled(True)
        self.pushButton_automation_soi_priority_add_level.setEnabled(True)
        self.pushButton_automation_soi_priority_remove_level.setEnabled(True)
        
        # System Status
        self.status_dialog.tableWidget_status_results.item(0,0).setText("Target")
                    
        # Control Over Flow Graph Tab
        self.frame_flow_graph.setEnabled(False)        
        
        # Save Automation Mode
        self.dashboard_settings_dictionary['startup_automation_mode'] = "Target"        
        
    def _slotAutomationCustomClicked(self):
        """ Changes the automation mode of the system to Custom.
        """
        # Change the Button Colors
        self.pushButton_automation_manual.setStyleSheet("")
        self.pushButton_automation_discovery.setStyleSheet("")
        self.pushButton_automation_target.setStyleSheet("")
        self.pushButton_automation_custom.setStyleSheet("border: 1px solid darkGray; border-radius: 6px; background-color: qlineargradient(x1: 0, y1: 0, x2: 0, y2: 1,stop: 0 #ffb477, stop: 1 #db8d4e); min-width: 80px;")    
        
        # Automation Settings
        self.label_automation_automation_mode_description.setText("User creates any combination of settings.")
                                    
        self.checkBox_automation_auto_start_tsi.setEnabled(True)
        
        self.checkBox_automation_auto_select_sois.setEnabled(True)
        self._slotAutomationAutoSelectSOIsClicked()
        
        self.checkBox_automation_auto_select_pd_flow_graphs.setEnabled(True)
        self._slotAutomationAutoSelectPD_FlowGraphsClicked()
                    
        self.checkBox_automation_auto_start_pd.setEnabled(True)
        self._slotAutomationAutoStartPD_Clicked()                
                    
        # Targeting Settings
        self.label_automation_target_protcol.setEnabled(True)
        self.comboBox_automation_target_protocol.setEnabled(True)
        self.tableWidget_automation_soi_list_priority.setColumnHidden(2,False)
        self.tableWidget_automation_soi_list_priority.setRowHidden(1,False)
        self.tableWidget_automation_soi_list_priority.setRowHidden(2,False)
        self.tableWidget_automation_soi_list_priority.resizeColumnsToContents()
        self.tableWidget_automation_soi_list_priority.resizeRowsToContents()
        self.tableWidget_automation_soi_list_priority.horizontalHeader().setStretchLastSection(False)
        self.tableWidget_automation_soi_list_priority.horizontalHeader().setStretchLastSection(True)
        self.tableWidget_automation_soi_list_priority.cellWidget(self.tableWidget_automation_soi_list_priority.rowCount()-1,0).setEnabled(True)
        self.tableWidget_automation_soi_list_priority.cellWidget(0,1).setEnabled(True)
        self.pushButton_automation_soi_priority_add_level.setEnabled(True)
        self.pushButton_automation_soi_priority_remove_level.setEnabled(True)    
        
        # System Status
        self.status_dialog.tableWidget_status_results.item(0,0).setText("Custom")
                                
        # Control Over Flow Graph Tab
        self.frame_flow_graph.setEnabled(True)
        
        # Save Automation Mode
        self.dashboard_settings_dictionary['startup_automation_mode'] = "Custom"

    def _slotLibraryRemoveAttacksRemoveClicked(self):
        """ Permanently removes the selected protocol, modulation, and/or attack from the library.
        """
        # Get the Values
        get_protocol = str(self.comboBox_library_browse_protocol.currentText())
        
        get_attack_name = [str(self.listWidget_library_browse_attacks.item(self.listWidget_library_browse_attacks.currentRow()).text())]
        get_attack_text = str(self.listWidget_library_browse_attacks3.item(self.listWidget_library_browse_attacks3.currentRow()).text())
        get_attack_text = get_attack_text.split(':')
        get_hardware = [get_attack_text[0]]
        get_modulation = [str(self.listWidget_library_browse_attacks_modulation.item(self.listWidget_library_browse_attacks_modulation.currentRow()).text())]

        if self.checkBox_library_attacks_remove_flow_graphs.isChecked():
            get_remove_flow_graphs = True
        else:
            get_remove_flow_graphs = False
        
        # Send Message to HIPRFISR/Protocol Discovery    
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Remove Attack from Library', Parameters = [get_protocol, get_attack_name, get_modulation, get_hardware, False, get_remove_flow_graphs])   
    
		# Success Message   
        #self.errorMessage("Removed Successfully!")
                
    def _slotPD_CRC_StartClicked(self):
        """ Calculates the CRC Polynomial based on two inputs and the expected CRCs for each input. 32 is too much memory.
        """
        # Conversions
        #get_input1 = bin(int(get_input1, 16))[2:].zfill(int(len(get_input1)*4))  # Convert to binary strings
        ##get_input1 = int(get_input1,16)  # Convert entire string to int
        #hex_str = '%0*X' % ((len(get_data) + 3) // 4, int(get_data, 2))  #binary to hex
        # "0x%0.2X" % 255  # int to hex
        # int('{:08b}'.format(int(new_byte,16))[::-1], 2)  # reverse byte
        
        # Reset the Progress Bar
        self.progressBar_pd_crc_progress.setValue(0)

        # Get the Values
        get_width = str(self.comboBox_pd_crc_find_poly.currentText())
        get_seed = str(self.textEdit_pd_crc_seed.toPlainText())
        get_final_xor = str(self.textEdit_pd_crc_final_xor.toPlainText())
        get_input1 = str(self.textEdit_pd_crc_input1.toPlainText())
        get_input2 = str(self.textEdit_pd_crc_input2.toPlainText())
        get_crc1 = str(self.textEdit_pd_crc_crc1.toPlainText())
        get_crc2 = str(self.textEdit_pd_crc_crc2.toPlainText())
        get_reverse_input = self.checkBox_pd_crc_reverse_input.isChecked()
        get_reverse_output = self.checkBox_pd_crc_reverse_final_xor.isChecked()
        
        # # Special Cases for 32
        # if get_width == "32":
            # # Flip the Poly
            # #get_poly = int('{:08b}'.format(get_poly).zfill(32)[::-1],2)
            
            # # Make the Seed an int
            # get_seed = int(get_seed,16)
            
            # # Invert the Reverse Logic
            # get_reverse_input = not get_reverse_input
            # get_reverse_output = not get_reverse_output

        # Calculate Polynomial from Two Known Inputs and CRCs
        match = "No Match"
        if get_width == "8":
            max_poly = 256
        elif get_width == "16":
            max_poly = 65536
        # elif get_width == "32":
            # max_poly = 4294967295
            
        for p1 in range(0,max_poly):
            # Update the Progress Bar
            self.progressBar_pd_crc_progress.setValue(int(100*p1/max_poly))
            
            # Known Seed
            acc = get_seed                             
            for n in range(0,int(len(get_input1)/2)):
                # Reverse Input
                if get_reverse_input == True:
                    new_byte = get_input1[2*n:2*n+2]
                    new_byte = int('{:08b}'.format(int(new_byte,16))[::-1], 2)
                    new_byte = "%0.2X" % new_byte                 
                else:
                    new_byte = get_input1[2*n:2*n+2]
                    
                acc = self.updateCRC(p1, acc, new_byte, int(get_width))
            
            # Reverse Output
            if get_reverse_output == True:            
                if get_width == "8":
                    acc = int('{:08b}'.format(int(acc,16))[::-1], 2)
                    acc = "%0.2X" % acc  
                elif get_width == "16":
                    new_byte1 = acc[0:2]
                    new_byte1 = int('{:08b}'.format(int(new_byte1,16))[::-1], 2)
                    new_byte1 = "%0.2X" % new_byte1                
                    new_byte2 = acc[2:4]
                    new_byte2 = int('{:08b}'.format(int(new_byte2,16))[::-1], 2)
                    new_byte2 = "%0.2X" % new_byte2  
                    acc = new_byte2 + new_byte1    
                # elif get_width == "32":
                    # acc = int('{:08b}'.format(acc).zfill(32)[::-1],2)
                
            # Final XOR
            # if get_width == "32":            
                # acc = (acc^int(get_final_xor,16)) & 0xFFFFFFFF            
            # else:
            acc = int(acc,16)^int(get_final_xor,16)
                
            # Format the Data
            if get_width == "8":
                acc = "%0.2X" % acc  
            elif get_width == "16":
                acc = "%0.4X" % acc  
            # elif get_width == "32":
                # acc = "%0.8X" % acc  
                        
            # Input 1 Match
            if acc == get_crc1:
                acc = get_seed
                for n in range(0,int(len(get_input2)/2)):
                    # Reverse Input
                    if get_reverse_input == True:
                        new_byte = get_input2[2*n:2*n+2]
                        new_byte = int('{:08b}'.format(int(new_byte,16))[::-1], 2)
                        new_byte = "%0.2X" % new_byte                 
                    else:
                        new_byte = get_input2[2*n:2*n+2]
                                                
                    acc = self.updateCRC(p1, acc, new_byte, int(get_width))
                    
                # Reverse Output
                if get_reverse_output == True:            
                    if get_width == "8":
                        acc = int('{:08b}'.format(int(acc,16))[::-1], 2)
                        acc = "%0.2X" % acc  
                    elif get_width == "16":
                        new_byte1 = acc[0:2]
                        new_byte1 = int('{:08b}'.format(int(new_byte1,16))[::-1], 2)
                        new_byte1 = "%0.2X" % new_byte1                
                        new_byte2 = acc[2:4]
                        new_byte2 = int('{:08b}'.format(int(new_byte2,16))[::-1], 2)
                        new_byte2 = "%0.2X" % new_byte2  
                        acc = new_byte2 + new_byte1    
                    # elif get_width == "32":
                        # acc = int('{:08b}'.format(acc).zfill(32)[::-1],2)
                    
                # Final XOR
                # if get_width == "32":            
                    # acc = (acc^int(get_final_xor,16)) & 0xFFFFFFFF            
                # else:
                acc = int(acc,16)^int(get_final_xor,16)
                    
                # Format the Data
                if get_width == "8":
                    acc = "%0.2X" % acc  
                elif get_width == "16":
                    acc = "%0.4X" % acc  
                # elif get_width == "32":
                    # acc = "%0.8X" % acc  
                
                # Input 1 and Input 2 Match
                if acc == get_crc2:
                    if get_width == "8":
                        match = "%0.2X" % p1 
                    elif get_width == "16":
                        match = "%0.4X" % p1 
                    # elif get_width == "32":
                        # match = "%0.8X" % p1                    
        
        # Update the Polynomial Edit Box
        self.textEdit_pd_crc_polynomial.setText(match)
        self.textEdit_pd_crc_polynomial.setAlignment(QtCore.Qt.AlignCenter)
        
        # Set the Progress Bar
        self.progressBar_pd_crc_progress.setValue(100)

    def updateCRC(self, crc_poly, crc_acc, crc_input, crc_length):
        """ Calculates CRC for bytes.
        """
        # 8-bit CRC
        if crc_length == 8:            
            # Convert Hex Byte String to int
            crc_input_int = int(crc_input,16) 
            crc_acc_int = int(crc_acc,16)
            crc_acc_int = crc_acc_int ^ crc_input_int
            for _ in range(8):
                crc_acc_int <<= 1
                if crc_acc_int & 0x0100:
                    crc_acc_int ^= crc_poly
                #crc &= 0xFF
                
            # Convert to Hex String
            crc_acc = ("%0.2X" % crc_acc_int)[-2:]
                        
        # 16-bit CRC
        elif crc_length == 16:
            # Convert Hex Byte String to int
            crc_input_int = int(crc_input,16) 
            crc_acc_int = int(crc_acc,16)
            crc_acc_int = crc_acc_int ^ (crc_input_int << 8)
            for i in range(0,8):
                if (crc_acc_int & 32768) == 32768:
                    crc_acc_int = crc_acc_int << 1
                    crc_acc_int = crc_acc_int^crc_poly
                else:
                    crc_acc_int = crc_acc_int << 1
            
            # Convert to Hex String
            crc_acc = "%0.4X" % crc_acc_int
            
            # Keep Only the Last 2 Bytes
            crc_acc = crc_acc[-4:]  
            
        # 32-bit CRC
        elif crc_length == 32:
            crc_input_int = int(crc_input,16) 
            crc_acc = crc_acc ^ crc_input_int
            for _ in range(0,8):
                mask = -(crc_acc & 1)
                crc_acc = (crc_acc >> 1) ^ (crc_poly & mask)  
        
        return crc_acc
        
    def _slotPD_CRC_AlgorithmChanged(self):
        """ Updates the CRC widgets to the corresponding algorithm.
        """
        # Disable from a Custom Selection
        self.textEdit_pd_crc_polynomial_common.setEnabled(False)
        self.textEdit_pd_crc_seed_common.setEnabled(False)
        self.textEdit_pd_crc_final_xor_common.setEnabled(False)
        self.checkBox_pd_crc_reverse_input_common.setEnabled(False)
        self.checkBox_pd_crc_reverse_final_xor_common.setEnabled(False)
            
        # Switch on Algorithm
        if self.comboBox_pd_crc_algorithm.currentText() == "CRC8":
            self.textEdit_pd_crc_polynomial_common.setText("07")
            self.textEdit_pd_crc_seed_common.setText("00")
            self.textEdit_pd_crc_final_xor_common.setText("00")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC8_CDMA2000":
            self.textEdit_pd_crc_polynomial_common.setText("9B")
            self.textEdit_pd_crc_seed_common.setText("FF")
            self.textEdit_pd_crc_final_xor_common.setText("00")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC8_DARC":
            self.textEdit_pd_crc_polynomial_common.setText("39")
            self.textEdit_pd_crc_seed_common.setText("00")
            self.textEdit_pd_crc_final_xor_common.setText("00")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC8_DVB-S2":
            self.textEdit_pd_crc_polynomial_common.setText("D5")
            self.textEdit_pd_crc_seed_common.setText("00")
            self.textEdit_pd_crc_final_xor_common.setText("00")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC8_EBU":
            self.textEdit_pd_crc_polynomial_common.setText("1D")
            self.textEdit_pd_crc_seed_common.setText("FF")
            self.textEdit_pd_crc_final_xor_common.setText("00")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC8_I-CODE":
            self.textEdit_pd_crc_polynomial_common.setText("1D")
            self.textEdit_pd_crc_seed_common.setText("FD")
            self.textEdit_pd_crc_final_xor_common.setText("00")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")     
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC8_ITU":
            self.textEdit_pd_crc_polynomial_common.setText("07")
            self.textEdit_pd_crc_seed_common.setText("00")
            self.textEdit_pd_crc_final_xor_common.setText("55")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC8_MAXIM":
            self.textEdit_pd_crc_polynomial_common.setText("31")
            self.textEdit_pd_crc_seed_common.setText("00")
            self.textEdit_pd_crc_final_xor_common.setText("00")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC8_ROHC":
            self.textEdit_pd_crc_polynomial_common.setText("07")
            self.textEdit_pd_crc_seed_common.setText("FF")
            self.textEdit_pd_crc_final_xor_common.setText("00")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC8_WCDMA":
            self.textEdit_pd_crc_polynomial_common.setText("9B")
            self.textEdit_pd_crc_seed_common.setText("00")
            self.textEdit_pd_crc_final_xor_common.setText("00")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")  
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_CCIT_ZERO":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_ARC":
            self.textEdit_pd_crc_polynomial_common.setText("8005")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_AUG_CCITT (Z-Wave)":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("1D0F")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_BUYPASS":
            self.textEdit_pd_crc_polynomial_common.setText("8005")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_CCITT_FALSE":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("FFFF")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_CDMA2000":
            self.textEdit_pd_crc_polynomial_common.setText("C867")
            self.textEdit_pd_crc_seed_common.setText("FFFF")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_DDS_110":
            self.textEdit_pd_crc_polynomial_common.setText("8005")
            self.textEdit_pd_crc_seed_common.setText("800D")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_DECT_R":
            self.textEdit_pd_crc_polynomial_common.setText("0589")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("0001")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_DECT_X":
            self.textEdit_pd_crc_polynomial_common.setText("0589")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")          
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_DNP":
            self.textEdit_pd_crc_polynomial_common.setText("3D65")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("FFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")  
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_EN_13757":
            self.textEdit_pd_crc_polynomial_common.setText("3D65")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("FFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")  
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_GENIBUS":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("FFFF")
            self.textEdit_pd_crc_final_xor_common.setText("FFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")  
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_MAXIM":
            self.textEdit_pd_crc_polynomial_common.setText("8005")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("FFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")                                                    
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_MCRF4XX":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("FFFF")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")  
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_RIELLO":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("B2AA")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")  
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_T10_DIF":
            self.textEdit_pd_crc_polynomial_common.setText("8BB7")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")     
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_TELEDISK":
            self.textEdit_pd_crc_polynomial_common.setText("A097")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")     
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_TMS37157":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("89EC")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")     
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_USB":
            self.textEdit_pd_crc_polynomial_common.setText("8005")
            self.textEdit_pd_crc_seed_common.setText("FFFF")
            self.textEdit_pd_crc_final_xor_common.setText("FFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")     
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_A":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("C6C6")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")                                                                                      
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_KERMIT":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_MODBUS":
            self.textEdit_pd_crc_polynomial_common.setText("8005")
            self.textEdit_pd_crc_seed_common.setText("FFFF")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_X_25":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("FFFF")
            self.textEdit_pd_crc_final_xor_common.setText("FFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC16_XMODEM":
            self.textEdit_pd_crc_polynomial_common.setText("1021")
            self.textEdit_pd_crc_seed_common.setText("0000")
            self.textEdit_pd_crc_final_xor_common.setText("0000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")           
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC32":
            self.textEdit_pd_crc_polynomial_common.setText("04C11DB7")
            self.textEdit_pd_crc_seed_common.setText("FFFFFFFF")
            self.textEdit_pd_crc_final_xor_common.setText("FFFFFFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC32_BZIP2":
            self.textEdit_pd_crc_polynomial_common.setText("04C11DB7")
            self.textEdit_pd_crc_seed_common.setText("FFFFFFFF")
            self.textEdit_pd_crc_final_xor_common.setText("FFFFFFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC32_C":
            self.textEdit_pd_crc_polynomial_common.setText("1EDC6F41")
            self.textEdit_pd_crc_seed_common.setText("FFFFFFFF")
            self.textEdit_pd_crc_final_xor_common.setText("FFFFFFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC32_D":
            self.textEdit_pd_crc_polynomial_common.setText("A833982B")
            self.textEdit_pd_crc_seed_common.setText("FFFFFFFF")
            self.textEdit_pd_crc_final_xor_common.setText("FFFFFFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC32_MPEG-2":
            self.textEdit_pd_crc_polynomial_common.setText("04C11DB7")
            self.textEdit_pd_crc_seed_common.setText("FFFFFFFF")
            self.textEdit_pd_crc_final_xor_common.setText("00000000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC32_POSIX":
            self.textEdit_pd_crc_polynomial_common.setText("04C11DB7")
            self.textEdit_pd_crc_seed_common.setText("00000000")
            self.textEdit_pd_crc_final_xor_common.setText("FFFFFFFF")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")      
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC32-32Q":
            self.textEdit_pd_crc_polynomial_common.setText("814141AB")
            self.textEdit_pd_crc_seed_common.setText("00000000")
            self.textEdit_pd_crc_final_xor_common.setText("00000000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC32_JAMCRC":
            self.textEdit_pd_crc_polynomial_common.setText("04C11DB7")
            self.textEdit_pd_crc_seed_common.setText("FFFFFFFF")
            self.textEdit_pd_crc_final_xor_common.setText("00000000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(True)
            self.textEdit_pd_crc_crc_common.setText("")   
        elif self.comboBox_pd_crc_algorithm.currentText() == "CRC32_XFER":
            self.textEdit_pd_crc_polynomial_common.setText("000000AF")
            self.textEdit_pd_crc_seed_common.setText("00000000")
            self.textEdit_pd_crc_final_xor_common.setText("00000000")
            self.checkBox_pd_crc_reverse_input_common.setChecked(False)
            self.checkBox_pd_crc_reverse_final_xor_common.setChecked(False)
            self.textEdit_pd_crc_crc_common.setText("")                         
        elif self.comboBox_pd_crc_algorithm.currentText() == "Custom":
            self.textEdit_pd_crc_polynomial_common.setEnabled(True)
            self.textEdit_pd_crc_seed_common.setEnabled(True)
            self.textEdit_pd_crc_final_xor_common.setEnabled(True)
            self.checkBox_pd_crc_reverse_input_common.setEnabled(True)
            self.checkBox_pd_crc_reverse_final_xor_common.setEnabled(True)
            self.textEdit_pd_crc_crc_common.setText("") 
            
    def _slotPD_CRC_CalculateClicked(self):
        """ Calculates the CRC using the selected algorithm.
        """        
        # Get Width
        get_width = str(self.comboBox_pd_crc_common_width.currentText())
        
        # Get the Values
        get_input = str(self.textEdit_pd_crc_input_common.toPlainText())
        get_poly = int(str(self.textEdit_pd_crc_polynomial_common.toPlainText()),16)
        get_seed = str(self.textEdit_pd_crc_seed_common.toPlainText())           
        get_final_xor = str(self.textEdit_pd_crc_final_xor_common.toPlainText())
        get_reverse_input = self.checkBox_pd_crc_reverse_input_common.isChecked()
        get_reverse_output = self.checkBox_pd_crc_reverse_final_xor_common.isChecked()
        
        # Special Cases for 32
        if get_width == "32":
            # Flip the Poly
            get_poly = int('{:08b}'.format(get_poly).zfill(32)[::-1],2)
            
            # Make the Seed an int
            get_seed = int(get_seed,16)
            
            # Invert the Reverse Logic
            get_reverse_input = not get_reverse_input
            get_reverse_output = not get_reverse_output
    
        # Known Seed       
        acc = get_seed                             
        for n in range(0,int(len(get_input)/2)):
            # Reverse Input
            if get_reverse_input == True:
                new_byte = get_input[2*n:2*n+2]
                new_byte = int('{:08b}'.format(int(new_byte,16))[::-1], 2)
                new_byte = "%0.2X" % new_byte                 
            else:
                new_byte = get_input[2*n:2*n+2]
            
            # Do CRC
            acc = self.updateCRC(get_poly, acc, new_byte, int(get_width))
                                
        # This sort of works, but only if get_rev_input and get_rev_output are the same (which is typical). Also, half of the CRC32 defaults are wrong.
        #crc8class = crcmod.Crc(get_poly, initCrc=get_seed, rev=get_rev_input,xorOut=get_final_xor)
        #crc8class = crcmod.Crc(get_poly, initCrc=get_seed, rev=False,xorOut=get_final_xor)
        #crc8class.update(binascii.unhexlify(get_input))
        #crc = crc8class.hexdigest()[-2:]
        
        # Reverse Output
        if get_reverse_output == True:            
            if get_width == "8":
                acc = int('{:08b}'.format(int(acc,16))[::-1], 2)
                acc = "%0.2X" % acc  
            elif get_width == "16":
                new_byte1 = acc[0:2]
                new_byte1 = int('{:08b}'.format(int(new_byte1,16))[::-1], 2)
                new_byte1 = "%0.2X" % new_byte1                
                new_byte2 = acc[2:4]
                new_byte2 = int('{:08b}'.format(int(new_byte2,16))[::-1], 2)
                new_byte2 = "%0.2X" % new_byte2  
                acc = new_byte2 + new_byte1    
            elif get_width == "32":
                acc = int('{:08b}'.format(acc).zfill(32)[::-1],2)
            
        # Final XOR
        if get_width == "32":            
            acc = (acc^int(get_final_xor,16)) & 0xFFFFFFFF            
        else:
            acc = int(acc,16)^int(get_final_xor,16)
            
        # Format the Data
        if get_width == "8":
            acc = "%0.2X" % acc  
        elif get_width == "16":
            acc = "%0.4X" % acc  
        elif get_width == "32":
            acc = "%0.8X" % acc                      
        self.textEdit_pd_crc_crc_common.setText(acc)
        self.textEdit_pd_crc_crc_common.setAlignment(QtCore.Qt.AlignCenter)
        
    def _slotLibraryRemoveProtocolChanged(self):
        """ Updates the Browse Library section with library information.
        """
        # Get Protocol
        get_protocol = str(self.comboBox_library_browse_protocol.currentText())
        if get_protocol == "Unknown":
            self.pushButton_library_remove_protocol.setEnabled(False)
        else:
            self.pushButton_library_remove_protocol.setEnabled(True)
        
        # Clear Boxes
        self.textEdit_library_browse_sois.setPlainText("")
        self.listWidget_library_browse_packet_types2.clear()
        self.textEdit_library_browse_packet_types.setPlainText("")
        self.listWidget_library_browse_attacks_modulation.clear()
        self.listWidget_library_browse_attacks3.clear()
        self.listWidget_library_browse_statistics2.clear()
        
        # Disable the Buttons
        self.pushButton_library_browse_remove_demod_fg.setEnabled(False)
        self.pushButton_library_browse_remove_soi.setEnabled(False)
        self.pushButton_library_browse_remove_packet_type.setEnabled(False)
        self.pushButton_library_browse_remove_modulation.setEnabled(False)
        
        # Populate the Listbox with the Associated Attacks
        self.listWidget_library_browse_attacks.clear()
        get_attacks = getAttacks(self.pd_library, get_protocol)
        for n in get_attacks:
            self.listWidget_library_browse_attacks.addItem(n)                     
        
        # Populate the Listbox with the Associated Modulation Types
        self.listWidget_library_browse_modulation_types.clear()
        get_modulation_types = getModulations(self.pd_library, get_protocol)
        for n in get_modulation_types:
            self.listWidget_library_browse_modulation_types.addItem(n) 
            
        # Populate the Listbox with the Associated Packet Types
        self.listWidget_library_browse_packet_types.clear()
        get_packet_types = getPacketTypes(self.pd_library, get_protocol)
        for n in get_packet_types:
            self.listWidget_library_browse_packet_types.addItem(n)             
        
        # Populate the Listbox with the Associated Demodulation Flow Graphs
        self.listWidget_library_browse_demod_fgs_modulation.clear()
        self.listWidget_library_browse_demod_fgs_hardware.clear()
        self.listWidget_library_browse_demod_fgs.clear()
        get_modulation = getDemodulationFlowGraphsModulation(self.pd_library, protocol=get_protocol)
        for n in get_modulation:
            self.listWidget_library_browse_demod_fgs_modulation.addItem(n)
            
        # Populate the Listbox with the Associated SOIs
        self.listWidget_library_browse_sois.clear()
        get_sois = sorted(getSOIs(self.pd_library, get_protocol))
        for n in get_sois:
            self.listWidget_library_browse_sois.addItem(n)  
            
        # Populate the Listbox with the Associated Statistics
        self.listWidget_library_browse_statistics.clear()
        get_statistics = getStatistics(self.pd_library, get_protocol)
        for n in get_statistics:
            self.listWidget_library_browse_statistics.addItem(n)  
                    
    def _slotLibraryBrowseSOIsChanged(self):
        """ Updates details for the selected SOI.
        """
        try:
            # Get SOI Information
            get_protocol = str(self.comboBox_library_browse_protocol.currentText())
            get_soi = str(self.listWidget_library_browse_sois.item(self.listWidget_library_browse_sois.currentRow()).text())
            get_soi_data = self.pd_library["Protocols"][get_protocol]['SOI Data'][get_soi]
            
            # Update the Text
            self.textEdit_library_browse_sois.setPlainText("Frequency (MHz): " + str(get_soi_data['Frequency']))        
            self.textEdit_library_browse_sois.append("Modulation: " + str(get_soi_data['Modulation']))
            self.textEdit_library_browse_sois.append("Bandwidth (MHz): " + str(get_soi_data['Bandwidth']))
            self.textEdit_library_browse_sois.append("Continuous: " + str(get_soi_data['Continuous']))
            self.textEdit_library_browse_sois.append("Start Frequency (MHz): " + str(get_soi_data['Start Frequency']))
            self.textEdit_library_browse_sois.append("End Frequency (MHz): " + str(get_soi_data['End Frequency']))                       
            self.textEdit_library_browse_sois.append("Notes: " + str(get_soi_data['Notes']))                       
        
        except:
            pass
            
    def _slotLibraryBrowsePacketTypesChanged(self):
        """ Updates fields for the selected packet type.
        """
        try:
            # Clear Boxes
            self.listWidget_library_browse_packet_types2.clear()
            self.textEdit_library_browse_packet_types.setPlainText("")
            
            # Get Packet Type Information
            get_protocol = str(self.comboBox_library_browse_protocol.currentText())
            get_packet_type = str(self.listWidget_library_browse_packet_types.item(self.listWidget_library_browse_packet_types.currentRow()).text())
            get_fields = getFields(self.pd_library, get_protocol, get_packet_type)
            
            # Populate the Listbox with the Associated Packet Types
            for n in get_fields:
                self.listWidget_library_browse_packet_types2.addItem(n) 
        except:
            pass
            
    def _slotLibraryBrowsePacketTypesFieldsChanged(self):
        """ Updates lengths and default values for the selected fields.
        """
        try:
            # Clear Box
            self.textEdit_library_browse_packet_types.setPlainText("")
            
            # Get Field Information
            get_protocol = str(self.comboBox_library_browse_protocol.currentText())
            get_packet_type = str(self.listWidget_library_browse_packet_types.item(self.listWidget_library_browse_packet_types.currentRow()).text())
            get_field = str(self.listWidget_library_browse_packet_types2.item(self.listWidget_library_browse_packet_types2.currentRow()).text())
            get_field_properties = getFieldProperties(self.pd_library, get_protocol, get_packet_type, get_field)
            
            # Populate the Listbox with the Associated Fields
            self.textEdit_library_browse_packet_types.setPlainText("Length (Bits): " + str(get_field_properties['Length']))
            self.textEdit_library_browse_packet_types.append("Default Value: " + str(get_field_properties['Default Value']))
        except:
            pass

    def _slotLibraryBrowseAttackChanged(self):
        """ Updates modulation types for the selected attack.
        """
        try:
            # Clear Boxes
            self.listWidget_library_browse_attacks_modulation.clear()
            
            # Get Attack Modulation Types
            get_protocol = str(self.comboBox_library_browse_protocol.currentText())
            get_attack = str(self.listWidget_library_browse_attacks.item(self.listWidget_library_browse_attacks.currentRow()).text())
            get_modulation_types = getModulations(self.pd_library, get_protocol)
            
            # Populate the Listbox with the Associated Attack Modulation Types
            for n in get_modulation_types:
                self.listWidget_library_browse_attacks_modulation.addItem(n) 
        except:
            pass

    def _slotLibraryBrowseAttackModulationChanged(self):
        """ Updates modulation types for the selected attack.
        """
        try:
            # Clear Boxes
            self.listWidget_library_browse_attacks3.clear()
            
            # Get Attack Hardware Types
            get_protocol = str(self.comboBox_library_browse_protocol.currentText())
            get_attack = str(self.listWidget_library_browse_attacks.item(self.listWidget_library_browse_attacks.currentRow()).text())
            get_modulation_type = str(self.listWidget_library_browse_attacks_modulation.item(self.listWidget_library_browse_attacks_modulation.currentRow()).text())
            get_hardware = self.pd_library['Protocols'][get_protocol]['Attacks'][get_attack][get_modulation_type]['Hardware'].keys()
            
            # Populate the Listbox with the Associated Attack Hardware Types
            for n in get_hardware:
                get_file_type = list(self.pd_library['Protocols'][get_protocol]['Attacks'][get_attack][get_modulation_type]['Hardware'][n].keys())[0]
                get_flow_graph = self.pd_library['Protocols'][get_protocol]['Attacks'][get_attack][get_modulation_type]['Hardware'][n][get_file_type]
                self.listWidget_library_browse_attacks3.addItem(n + ": " + get_file_type + ": " + get_flow_graph) 
        except:
            pass   
            
    def _slotLibraryBrowseStatisticsChanged(self):
        """ Updates the statistical information for the selected statistic.
        """
        try:
            # Clear Boxes
            self.listWidget_library_browse_statistics2.clear()
            
            # Get Statistic
            get_protocol = str(self.comboBox_library_browse_protocol.currentText())
            get_statistic = str(self.listWidget_library_browse_statistics.item(self.listWidget_library_browse_statistics.currentRow()).text())
            get_values = getStatisticValues(self.pd_library, get_protocol, get_statistic)

            # Populate the Listbox with the Associated Statistical Values
            for n in get_values:
                self.listWidget_library_browse_statistics2.addItem(str(n)) 
        except:
            pass     
            
    def _slotAttackImportFileTypeChanged(self):
        """ Toggles the "include .grc" check box.
        """
        # Enable Check Box
        if str(self.comboBox_library_attacks_file_type.currentText()) == "Flow Graph":
            self.checkBox_library_attacks_grc_file.setEnabled(True)
            self.checkBox_library_attacks_grc_file.setChecked(True)
        elif str(self.comboBox_library_attacks_file_type.currentText()) == "Flow Graph - GUI":
            self.checkBox_library_attacks_grc_file.setEnabled(True)
            self.checkBox_library_attacks_grc_file.setChecked(True)
        else:
            self.checkBox_library_attacks_grc_file.setEnabled(False)
            self.checkBox_library_attacks_grc_file.setChecked(False)
    
    def findX310(self, widget_ip, widget_serial, widget_daughterboard, widget_probing_label):
        """ Parses the results of 'uhd_find_devices' and sets the X310 IP and serial for two edit boxes.
        """
        # Get the Text
        proc = subprocess.Popen("uhd_find_devices &", shell=True, stdout=subprocess.PIPE, )
        output = proc.communicate()[0].decode()
        
        # Get the Variables and Values
        device_index = -1
        device_dict = {}
        record_values = False
        for line in output.splitlines():
            if len(line.strip()) == 0:
                record_values = False
            if record_values == True:
                get_var = line.split(':')[0].strip(' ')
                get_val = line.split(':')[1].strip(' ')
                device_dict[device_index].append((get_var,get_val))
            if "Device Address" in line:                    
                device_index = device_index + 1
                device_dict.update({device_index:[]})
                record_values = True
                
        # Find X310
        for n in range(0,len(device_dict)):
            for nn in device_dict[n]:
                if 'X310' or 'X300' in nn: 
                    # Update Dashboard                      
                    for m in device_dict[n]:
                        if m[0] == 'addr':
                            widget_ip.setText(m[1])
                            widget_ip.setAlignment(QtCore.Qt.AlignCenter)
                        if m[0] == 'serial':
                            widget_serial.setText(m[1]) 
                            widget_serial.setAlignment(QtCore.Qt.AlignCenter) 
                            
        # Find Daughterboard
        try:
            # Probe
            get_ip = str(widget_ip.toPlainText())
            widget_probing_label.setVisible(True)
            QtWidgets.QApplication.processEvents()
            proc = subprocess.Popen('uhd_usrp_probe --args="addr=' + get_ip + '" &', shell=True, stdout=subprocess.PIPE, )
            output = str(proc.communicate()[0].decode())
            widget_probing_label.setVisible(False)
            
            if "CBX" in output:
                widget_daughterboard.setCurrentIndex(0)
            elif "SBX" in output:
                widget_daughterboard.setCurrentIndex(1)
            elif "UBX" in output:
                widget_daughterboard.setCurrentIndex(2)
            elif "WBX" in output:
                widget_daughterboard.setCurrentIndex(3)            
        except:
            widget_probing_label.setVisible(False)
            
                            
    def findB210(self, widget_serial):      
        """ Parses the results of 'uhd_find_devices' and sets the B210 serial for an edit box.
        """   
        # Get the Text
        proc = subprocess.Popen("uhd_find_devices &", shell=True, stdout=subprocess.PIPE, )
        output = proc.communicate()[0].decode()
        
        # Get the Variables and Values
        device_index = -1
        device_dict = {}
        record_values = False
        for line in output.splitlines():
            if len(line.strip()) == 0:
                record_values = False
            if record_values == True:
                get_var = line.split(':')[0].strip(' ')
                get_val = line.split(':')[1].strip(' ')
                device_dict[device_index].append((get_var,get_val))
            if "Device Address" in line:                    
                device_index = device_index + 1
                device_dict.update({device_index:[]})
                record_values = True
                
        # Find B210
        for n in range(0,len(device_dict)):
            for nn in device_dict[n]:
                if 'B210' in nn: 
                    # Update Dashboard                      
                    for m in device_dict[n]:
                        if m[0] == 'serial':
                            widget_serial.setText(m[1]) 
                            widget_serial.setAlignment(QtCore.Qt.AlignCenter)
                            
    def findB205mini(self, widget_serial):      
        """ Parses the results of 'uhd_find_devices' and sets the B205mini serial for an edit box.
        """   
        # Get the Text
        proc = subprocess.Popen("uhd_find_devices &", shell=True, stdout=subprocess.PIPE, )
        output = proc.communicate()[0].decode()
        
        # Get the Variables and Values
        device_index = -1
        device_dict = {}
        record_values = False
        for line in output.splitlines():
            if len(line.strip()) == 0:
                record_values = False
            if record_values == True:
                get_var = line.split(':')[0].strip(' ')
                get_val = line.split(':')[1].strip(' ')
                device_dict[device_index].append((get_var,get_val))
            if "Device Address" in line:                    
                device_index = device_index + 1
                device_dict.update({device_index:[]})
                record_values = True
                
        # Find B205i
        for n in range(0,len(device_dict)):
            for nn in device_dict[n]:
                if 'B205i' in nn: 
                    # Update Dashboard                      
                    for m in device_dict[n]:
                        if m[0] == 'serial':
                            widget_serial.setText(m[1]) 
                            widget_serial.setAlignment(QtCore.Qt.AlignCenter)
                            
    def find80211x(self, widget_interface):
        """ Parses the results of 'iwconfig' and sets the 802.11x Adapter interface for an edit box.
        """
        # Get the Text
        proc = subprocess.Popen("iwconfig &", shell=True, stdout=subprocess.PIPE, )
        output = proc.communicate()[0].decode()
        
        # Reset Interface Index
        get_text = str(widget_interface.toPlainText())
        if len(get_text) == 0:
            self.guess_index = 0
        else:
            self.guess_index = self.guess_index + 1
        
        # Pull the Interfaces
        lines = output.split('\n')
        get_interface = ''
        wifi_interfaces = []
        for n in range(0,len(lines)):
            if 'ESSID' in lines[n]:
                wifi_interfaces.append(lines[n].split(' ',1)[0])
        
        # Found an Interface
        if len(wifi_interfaces) > 0:
            
            # Check Interface Index
            if self.guess_index > (len(wifi_interfaces)-1):
                self.guess_index = 0        
            
            # Update the Edit Box
            get_interface = wifi_interfaces[self.guess_index]
            widget_interface.setText(get_interface) 
            widget_interface.setAlignment(QtCore.Qt.AlignCenter)    
            
    def findLimeSDR(self, widget_serial):
        """  Parses the results of 'LimeUtil --find' and sets the serial number for an edit box.
        """
        # Get the Text
        proc = subprocess.Popen("LimeUtil --find &", shell=True, stdout=subprocess.PIPE, )
        output = proc.communicate()[0].decode()
        
        # Extract the Serial
        get_serial = output[output.find('serial=')+7:output.rfind(']')]
        
        # Update the Edit Box
        widget_serial.setText(get_serial) 
        widget_serial.setAlignment(QtCore.Qt.AlignCenter)
        
    def findHackRF(self, widget_serial):      
        """ Parses the results of 'hackrf_info' and sets the HackRF serial for an edit box.
        """   
        # Get the Text
        proc = subprocess.Popen("hackrf_info &", shell=True, stdout=subprocess.PIPE, )
        output = proc.communicate()[0].decode()
        
        # Reset Guess Index
        get_text = str(widget_serial.toPlainText())
        if len(get_text) == 0:
            self.guess_index = 0
        else:
            self.guess_index = self.guess_index + 1
        
        # Get the Variables and Values
        device_index = -1
        device_dict = {}
        for line in output.splitlines():
            if "Serial number" in line:                    
                device_index = device_index + 1
                device_dict.update({device_index:[]})
                get_var = line.split(':')[0].strip(' ')
                get_val = line.split(':')[1].strip(' ').lstrip('0')
                device_dict[device_index].append((get_var,get_val))
                
        # Check Interface Index
        if self.guess_index > (len(device_dict)-1):
            self.guess_index = 0  
                    
        # Update GUI 
        try:
            m = device_dict[self.guess_index][0]   
            if m[0] == 'Serial number':
                widget_serial.setText(m[1]) 
                widget_serial.setAlignment(QtCore.Qt.AlignCenter)     
        except:
            widget_serial.setText("") 
            widget_serial.setAlignment(QtCore.Qt.AlignCenter)       
                
    def _slotLibraryBrowseRemoveDemodFG_Clicked(self):
        """ Removes selected demodulation flow graph from the library.
        """
        # Get the Values
        get_protocol = str(self.comboBox_library_browse_protocol.currentText())
        get_modulation = str(self.listWidget_library_browse_demod_fgs_modulation.item(self.listWidget_library_browse_demod_fgs_modulation.currentRow()).text())        
        get_hardware = str(self.listWidget_library_browse_demod_fgs_hardware.item(self.listWidget_library_browse_demod_fgs_hardware.currentRow()).text())          
        get_demodulation_fg = str(self.listWidget_library_browse_demod_fgs.item(self.listWidget_library_browse_demod_fgs.currentRow()).text())
                
        # Send Message to HIPRFISR/Protocol Discovery  
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Remove Demodulation Flow Graph', Parameters = [get_protocol, get_modulation, get_hardware, get_demodulation_fg])   
        
        # Update the Demodulation Combo Box
        self._slotPD_DemodHardwareChanged()
    
    def _slotLibraryBrowseDemodFGsClicked(self):
        """ Enables the "Remove" button near the demodulation flow graphs list widget.
        """
        # Enable the Button
        self.pushButton_library_browse_remove_demod_fg.setEnabled(True)
        
    def _slotLibraryBrowseSOIsClicked(self):
        """ Enables the "Remove" button near the SOI list widget.
        """
        # Enable the Button       
        self.pushButton_library_browse_remove_soi.setEnabled(True)
        
    def _slotLibraryBrowseAttacksClicked(self):
        """ Enables the "Remove" button and "Delete Files" checkbox after clicking the attack list widget.
        """
        # Enable the Button and Checkbox
        self.pushButton_library_attacks_remove.setEnabled(True)        
        self.checkBox_library_attacks_remove_flow_graphs.setEnabled(True)   
        
    def _slotLibraryBrowseRemoveSOI_Clicked(self):
        """ Removes selected SOI from the library.
        """
        # Get the Values
        get_protocol = str(self.comboBox_library_browse_protocol.currentText())
        get_soi = str(self.listWidget_library_browse_sois.item(self.listWidget_library_browse_sois.currentRow()).text())
        
        # Send Message to HIPRFISR/Protocol Discovery  
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Remove SOI', Parameters = [get_protocol, get_soi])   
            
    def _slotLibraryBrowsePacketTypesClicked(self):
        """ Enables the "Remove" button near the packet types list widget.
        """
        # Enable the Button
        self.pushButton_library_browse_remove_packet_type.setEnabled(True)
        
    def _slotLibraryBrowseRemovePacketTypeClicked(self):
        """ Removes the selected packet type from the library.
        """
        # Get the Values
        get_protocol = str(self.comboBox_library_browse_protocol.currentText())
        get_packet_type = str(self.listWidget_library_browse_packet_types.item(self.listWidget_library_browse_packet_types.currentRow()).text())
        
        # Send Message to HIPRFISR/Protocol Discovery  
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Remove Packet Type', Parameters = [get_protocol, get_packet_type])   
            
    def _slotLibraryBrowseModulationsClicked(self):
        """ Enables the "Remove" button near the modulation types list widget.
        """
        # Enable the Button
        self.pushButton_library_browse_remove_modulation.setEnabled(True)

    def _slotLibraryBrowseRemoveModulationClicked(self):
        """ Removes the selected modulation from the library.
        """
        # Get the Values
        get_protocol = str(self.comboBox_library_browse_protocol.currentText())
        get_modulation = str(self.listWidget_library_browse_modulation_types.item(self.listWidget_library_browse_modulation_types.currentRow()).text())
        
        # Send Message to HIPRFISR/Protocol Discovery  
        self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Remove Modulation Type', Parameters = [get_protocol, get_modulation])   
         
    def _slotPD_SnifferWireshark80211Clicked(self):
        """ Opens Wireshark to an 802.11x interface.
        """
        # Start Wireshark
        get_interface = str(self.textEdit_pd_sniffer_interface.toPlainText())
        
        # Find Wireshark
        out = subprocess.Popen(['which', 'wireshark'],stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
        stdout,stderr = out.communicate()
        wireshark_cmd = str(stdout.replace('\n',''))
        
        if len(get_interface) == 0 and len(wireshark_cmd) > 0:
            p = subprocess.Popen([wireshark_cmd])
        else:
            p = subprocess.Popen([wireshark_cmd, '-k', '-i', get_interface])
        
    def _slotPD_SnifferGuessClicked(self):
        """ Guesses the wireless interface to use for Wireshark.
        """
        # Guess and Store
        self.find80211x(self.textEdit_pd_sniffer_interface)
        
    def _slotTSI_ZoomInClicked(self):
        """ Zooms in on the currently configured SDR bands.
        """
        # Get Min and Max Frequency
        start_frequency = []
        end_frequency = []
                            
        for col in range(0,self.tableWidget_tsi_scan_options.columnCount()):            
            start_frequency.append(int(int(self.tableWidget_tsi_scan_options.item(0,col).text())*1e6))
            end_frequency.append(int(int(self.tableWidget_tsi_scan_options.item(1,col).text())*1e6))
        
        min_freq = min(start_frequency)
        max_freq = float(max(end_frequency))
        
        # Round Frequencies by 100 MHz
        min_freq = min_freq - (min_freq%100e6)
        if (max_freq%100e6) != 0:
            max_freq = max_freq + 100e6 - (max_freq%100e6)
         
        # Resize the Plot Window
        self.tuning_matplotlib_widget.configureAxesZoom(xmin=min_freq,xmax=max_freq)
        
        # Resize the Detector Window
        self._slotTSI_ClearDetectorPlotClicked()
        self.wideband_zoom_start = min_freq
        self.wideband_zoom_end = max_freq
        self.wideband_zoom = True        
        self.matplotlib_widget.configureAxesZoom1(self.wideband_zoom_start, self.wideband_zoom_end, self.wideband_height)

        #self.matplotlib_widget.configureAxesZoom1(xmin=min_freq,xmax=max_freq)
        self.matplotlib_widget.draw()
         
        # Delete the Band Labels
        for n in reversed(range(0,len(self.tuning_matplotlib_widget.axes.texts))):   
            self.tuning_matplotlib_widget.axes.texts[n].remove()

        # Draw Text Label
        axis_scale = (self.tuning_matplotlib_widget.axes.get_xlim()[1] - self.tuning_matplotlib_widget.axes.get_xlim()[0])/600
        x_offset = 10 * (1*axis_scale)
        
        for col in range(0,self.tableWidget_tsi_scan_options.columnCount()):         
            band_number = str(col+1)
            if band_number == "10":
                x_offset = 15                            
            if min_freq <= max_freq:  # Makes it appear next to the left-most value
                x_pos = start_frequency[col]/1e6
            else:
                x_pos = end_frequency[col]/1e6
                        
            self.tuning_matplotlib_widget.axes.text(x_pos/10 - x_offset,(self.tuning_matplotlib_widget.band_height*(col+2)) - 5,band_number,fontsize=10)      
            
        self.tuning_matplotlib_widget.draw()
                
    def _slotMenuIwlistScanClicked(self):
        """ Opens the 'iwlist scan' command in a terminal.
        """
        # ~ # Get the Text
        # ~ #command_text = "iwlist scanning | egrep 'Cell |Encryption|Quality|Last beacon|ESSID' &"
        # ~ command_text = "sudo iwlist scan &"
        # ~ proc = subprocess.Popen(command_text, shell=True, stdout=subprocess.PIPE)
        # ~ output = proc.communicate()[0].decode()        
        
        # ~ # Create a Dialog Window    
        # ~ msgBox = MyMessageBox(my_text = output)
        # ~ msgBox.exec_() 

        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo iwlist scan"', shell=True)        
        
    def _slotMenuKismetClicked(self):
        """ Opens Kismet for viewing wireless networks.
        """
        # Run Kismet
        command_text = 'gnome-terminal -- kismet &'
        proc = subprocess.Popen(command_text, shell=True)

    def _slotMenuQSpectrumAnalyzerClicked(self):
        """ Opens QSpectrumAnalyzer for viewing RF signals.
        """
        # Run QSpectrumAnalyzer
        proc=subprocess.Popen("qspectrumanalyzer &", shell=True)
        
    def _slotMenuGQRX_Clicked(self):
        """ Opens GQRX for viewing RF signals.
        """
        # Run GQRX
        proc=subprocess.Popen("gqrx &", shell=True) 
        
    def _slotPD_DemodHardwareChanged(self):
        """ Updates the list of demodulation flow graphs.
        """                           
        # Get Hardware
        get_hardware = str(self.comboBox_pd_demod_hardware.currentText())
        
        # Clear the List
        self.listWidget_pd_flow_graphs_all_fgs.clear()
        
        # Get All Demodulation Flow Graphs
        all_demod_fgs = getDemodulationFlowGraphs(self.pd_library,protocol=None,modulation=None,hardware=get_hardware)

        # Update the List Widget
        for fg in sorted(all_demod_fgs,key=str.lower):
            self.listWidget_pd_flow_graphs_all_fgs.addItem(fg)
            
    def _slotLibraryBrowseDemodFGsHardwareClicked(self):
        """ Updates the demodulation flow graph list widget for a given protocol, modulation type, and hardware type.
        """
        # Clear the List Widget
        self.listWidget_library_browse_demod_fgs.clear()
        
        # Get Protocol
        get_protocol = str(self.comboBox_library_browse_protocol.currentText())
        
        try:
            # Get Modulation
            get_modulation = str(self.listWidget_library_browse_demod_fgs_modulation.item(self.listWidget_library_browse_demod_fgs_modulation.currentRow()).text())
        
            # Get Hardware
            get_hardware = str(self.listWidget_library_browse_demod_fgs_hardware.item(self.listWidget_library_browse_demod_fgs_hardware.currentRow()).text())
            
            # Get Demodulation Flow Graphs
            get_demod_fgs = getDemodulationFlowGraphs(self.pd_library, protocol=get_protocol, modulation=get_modulation, hardware=get_hardware)
            for n in sorted(get_demod_fgs,key=str.lower):
                self.listWidget_library_browse_demod_fgs.addItem(n)  
        except:
            pass
            
    def _slotLibraryBrowseDemodFGsModulationClicked(self):
        """ Updates the demodulation flow graph hardware list for a given protocol and modulation type
        """
        # Clear the List Widgets
        self.listWidget_library_browse_demod_fgs_hardware.clear()
        self.listWidget_library_browse_demod_fgs.clear()
        
        # Get Protocol
        get_protocol = str(self.comboBox_library_browse_protocol.currentText())
             
        try:
            # Get Modulation
            get_modulation = str(self.listWidget_library_browse_demod_fgs_modulation.item(self.listWidget_library_browse_demod_fgs_modulation.currentRow()).text())
            
            # Get Demodulation Flow Graphs
            get_hardware = getDemodulationFlowGraphsHardware(self.pd_library, protocol=get_protocol, modulation=get_modulation)
            for n in sorted(get_hardware,key=str.lower):
                self.listWidget_library_browse_demod_fgs_hardware.addItem(n)  
        except:
            pass

    def _slotIQ_InspectionHardwareChanged(self):
        """ Updates the list of inspection tools.
        """
        # Clear Widgets
        self.listWidget_iq_inspection_flow_graphs.clear()
        
        # Get Hardware
        get_hardware = str(self.dashboard_settings_dictionary['hardware_iq'])
        
        if len(get_hardware) > 0:
            # Update Flow Graphs
            get_fgs = []
            get_fgs.extend(self.pd_library["Inspection Flow Graphs"][get_hardware])
            for n in sorted(get_fgs,key=str.lower):
                if n != "None":
                    self.listWidget_iq_inspection_flow_graphs.addItem(n)  
            self.listWidget_iq_inspection_flow_graphs.setCurrentRow(0) 
            
            # Update Tools    
            if get_hardware == "Computer":
                self.stackedWidget_iq_inspection.setCurrentIndex(0)                
            elif get_hardware == "USRP X310":
                self.stackedWidget_iq_inspection.setCurrentIndex(1)
            elif get_hardware == "USRP B210":
                self.stackedWidget_iq_inspection.setCurrentIndex(2)
            elif get_hardware == "HackRF":
                self.stackedWidget_iq_inspection.setCurrentIndex(3)
            elif get_hardware == "RTL2832U":
                self.stackedWidget_iq_inspection.setCurrentIndex(4)
            elif get_hardware == "802.11x Adapter":
                self.stackedWidget_iq_inspection.setCurrentIndex(5)
            elif get_hardware == "USRP B205mini":
                self.stackedWidget_iq_inspection.setCurrentIndex(6)
            elif get_hardware == "LimeSDR":
                self.stackedWidget_iq_inspection.setCurrentIndex(7)  
            elif get_hardware == "bladeRF":
                self.stackedWidget_iq_inspection.setCurrentIndex(8)    
            elif get_hardware == "Open Sniffer":
                self.stackedWidget_iq_inspection.setCurrentIndex(9)                
                
            # Enable Frame
            self.frame_iq_inspection_fg.setEnabled(True)
            
    def _slotIQ_InspectionFlowGraphClicked(self):
        """ Loads the selected inspector flow graph's default variables.
        """
        new_font = QtGui.QFont("Times",10)#,QtGui.QFont.Bold)
        
        # Flow Graph - GUI (Inspection)   
        self.tableWidget_iq_inspection_fg_values.setRowCount(0)
                          
        # Get the Flow Graph Filepath
        no_errors = True
        try:
            fname = str(self.listWidget_iq_inspection_flow_graphs.item(self.listWidget_iq_inspection_flow_graphs.currentRow()).text())        
            flow_graph_directory = os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Inspection Flow Graphs/"
            fname_path = flow_graph_directory + fname
        except:
            no_errors = False
            
        if no_errors == True:
            # Read Flow Graph Variables
            f = open(fname_path,'r')
            parsing = False
            for line in f:
                if line.startswith("        # Variables"):
                    parsing = True
                elif line.startswith("        # Blocks"):
                    parsing = False
                if parsing:
                    # Strip Extra Text
                    get_line = line.split('=',1)[-1]
                    get_line = get_line.split('#',1)[0]
                    get_line = get_line.lstrip()
                    
                    if get_line != "":       
                        # Get Default Variable Name and Value
                        variable_name = get_line.split(' = ')[0]
                        variable_name_item = QtWidgets.QTableWidgetItem(variable_name)
                        
                        # Replace with Global Constants
                        if variable_name == "ip_address":
                            value_text = self.dashboard_settings_dictionary['hardware_ip_iq']
                        elif variable_name == "serial":
                            if len(self.dashboard_settings_dictionary['hardware_serial_iq']) > 0:
                                if self.dashboard_settings_dictionary['hardware_iq'] == "HackRF":
                                    value_text = self.dashboard_settings_dictionary['hardware_serial_iq']
                                else:
                                    value_text = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_iq']                               
                            else:
                                if self.dashboard_settings_dictionary['hardware_iq'] == "HackRF":
                                    value_text = ""
                                else:
                                    value_text = "False"   
                        else:
                            value_text = get_line.split(' = ')[1].rstrip('\n')
                            value_text = value_text.replace('"','')
                          
                        # Fill in the "Current Values" Table
                        variable_name_item.setFont(new_font)                                                                                                  
                        value = QtWidgets.QTableWidgetItem(value_text)
                        value.setFont(new_font)
                        value.setFlags(variable_name_item.flags() & ~QtCore.Qt.ItemIsEditable)
                        self.tableWidget_iq_inspection_fg_values.setRowCount(self.tableWidget_iq_inspection_fg_values.rowCount()+1)
                        self.tableWidget_iq_inspection_fg_values.setVerticalHeaderItem(self.tableWidget_iq_inspection_fg_values.rowCount()-1,variable_name_item)   
                        self.tableWidget_iq_inspection_fg_values.setItem(self.tableWidget_iq_inspection_fg_values.rowCount()-1,0,value)                                     
            
            # Close the File
            f.close()                 
            
            # Disable the Table
            #self.tableWidget_iq_inspection_fg_values.setEnabled(False)
            
            # Rename the Column Header
            header_name = get_line.split(' = ')[0]
            header_name_item = QtWidgets.QTableWidgetItem(fname)
            header_name_item.setFont(new_font)
            self.tableWidget_iq_inspection_fg_values.setHorizontalHeaderItem(0,header_name_item)
            
            # Adjust Table
            #self.tableWidget_iq_inspection_fg_values.verticalHeader().setFont(new_header_font)
            #self.tableWidget_iq_inspection_fg_values.horizontalHeader().setFont(new_header_font)
            self.tableWidget_iq_inspection_fg_values.resizeRowsToContents()
        
    def _slotIQ_InspectionFG_StartClicked(self):
        """ Starts the inspector flow graph.
        """
        # Stop Flow Graph
        if self.pushButton_iq_inspection_fg_start.text() == "Stop":
            # Send Message
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Inspection Flow Graph', Parameters = ['Flow Graph - GUI'])
                        
            # Toggle the Text
            self.pushButton_iq_inspection_fg_start.setText("Start")  
                        
            # Enable Attack Switching
            self.listWidget_iq_inspection_flow_graphs.setEnabled(True)
            self.pushButton_iq_inspection_fg_load.setEnabled(True)

        # Start Flow Graph
        elif self.pushButton_iq_inspection_fg_start.text() == "Start":       
                                
            # Send Message(s) to the HIPRFISR for each Variable Name and Value
            variable_names = []
            variable_values = []
            
            no_errors = True
            try:
                # Get the Flow Graph Filepath
                fname = str(self.listWidget_iq_inspection_flow_graphs.item(self.listWidget_iq_inspection_flow_graphs.currentRow()).text())              
                flow_graph_directory = os.path.dirname(os.path.abspath(__file__)) + "/Flow Graph Library/Inspection Flow Graphs/"
                fname = flow_graph_directory + fname
                
                # Rebuild Flow Graph (New OS Sometimes Causes Errors)
                if self.checkBox_iq_inspection_rebuild.isChecked():
                    #os.system('grcc "' + fname.replace('.py','.grc') + '" -d "' + str(flow_graph_directory) + '" &')
                    os.system('grcc "' + fname.replace('.py','.grc') + '" -d "' + str(flow_graph_directory) + '"')
                    
            except:
                no_errors = False
            
            if no_errors == True:
                # Send "Run Attack Flow Graph" Message to the HIPRFISR
                get_file_type = "Flow Graph - GUI"
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Run Inspection Flow Graph', Parameters = [fname, variable_names, variable_values, get_file_type]) 
                    
                # Toggle the Text       
                self.pushButton_iq_inspection_fg_start.setText("Stop") 
                #self.pushButton_attack_start_stop.setEnabled(False)
                
                # Disable Attack Switching
                self.listWidget_iq_inspection_flow_graphs.setEnabled(False)
                self.pushButton_iq_inspection_fg_load.setEnabled(False) 
                    
                ## Update the Status Dialog
                # ~ self.status_dialog.tableWidget_status_results.item(3,0).setText('Starting... ' + fname.split('/')[-1])
          
    def _slotMenuDump1090_Clicked(self):
        """ Launches Dump1090 for RTL2832U devices.
        """
        # Run Dump1090
        dump1090_directory = os.path.expanduser("~/Installed_by_FISSURE/dump1090/")
        proc=subprocess.Popen("gnome-terminal -- ./dump1090 --interactive --net --freq 1090000000 --net-http-port 8081", cwd=dump1090_directory, shell=True)
        webbrowser.open("http://127.0.0.1:8081")
        
    def _slotMenuLimeSuite_Clicked(self):
        """ Launches LimeSuiteGUI for the LimeSDR.
        """
        # Run LimeSuitGUI
        command_text = 'gnome-terminal -- LimeSuiteGUI &'
        proc = subprocess.Popen(command_text, shell=True)
        
    def _slotStatusbarTSI_Clicked(self):
        """ Restarts tsi.py.
        """
        if self.statusbar_tsi.text() == "TSI: XX":
            self.statusbar_tsi.setText("TSI: --")
            os.system("python3 " + os.path.dirname(os.path.realpath(__file__)) + "/tsi_component.py &")
        
    def _slotStatusbarPD_Clicked(self):
        """ Restarts protocol_discovery.py.
        """
        if self.statusbar_pd.text() == "PD: XX":
            self.statusbar_pd.setText("PD: --")
            os.system("python3 " + os.path.dirname(os.path.realpath(__file__)) + "/protocol_discovery.py &")
    
    def _slotStatusbarFGE_Clicked(self):
        """ Restart fg_executor.py.
        """
        if self.statusbar_fge.text() == "FGE: XX":
            self.statusbar_fge.setText("FGE: --")
            os.system("python3 " + os.path.dirname(os.path.realpath(__file__)) + "/fg_executor.py &")
        
    def _slotStatusbarHIPRFISR_Clicked(self):
        """ Restart hiprfisr.py.
        """
        if self.statusbar_hiprfisr.text() == "HIPRFISR: XX":
            self.statusbar_hiprfisr.setText("HIPRFISR: --")
            os.system("python3 " + os.path.dirname(os.path.realpath(__file__)) + "/hiprfisr.py &")
        
    def _slotTopTSI_Clicked(self):
        """ Select TSI hardware option at the top of the window.
        """       
        hardware_select_dlg = HardwareSelectDialog(parent=self, mode="TSI:",
            hardware=self.dashboard_settings_dictionary['hardware_tsi'], ip=self.dashboard_settings_dictionary['hardware_ip_tsi'], serial=self.dashboard_settings_dictionary['hardware_serial_tsi'], interface=self.dashboard_settings_dictionary['hardware_interface_tsi'], daughterboard=self.dashboard_settings_dictionary['hardware_daughterboard_tsi'])
        hardware_select_dlg.show()
        hardware_select_dlg.exec_()         
        
    def _slotTopPD_Clicked(self):
        """ Select PD hardware option at the top of the window.
        """
        hardware_select_dlg = HardwareSelectDialog(parent=self, mode="PD:",
            hardware=self.dashboard_settings_dictionary['hardware_pd'], ip=self.dashboard_settings_dictionary['hardware_ip_pd'], serial=self.dashboard_settings_dictionary['hardware_serial_pd'], interface=self.dashboard_settings_dictionary['hardware_interface_pd'], daughterboard=self.dashboard_settings_dictionary['hardware_daughterboard_pd'])
        hardware_select_dlg.show()
        hardware_select_dlg.exec_() 
        
    def _slotTopAttackClicked(self):
        """ Select Attack hardware option at the top of the window.
        """
        hardware_select_dlg = HardwareSelectDialog(parent=self, mode="Attack:",
            hardware=self.dashboard_settings_dictionary['hardware_attack'], ip=self.dashboard_settings_dictionary['hardware_ip_attack'], serial=self.dashboard_settings_dictionary['hardware_serial_attack'], interface=self.dashboard_settings_dictionary['hardware_interface_attack'], daughterboard=self.dashboard_settings_dictionary['hardware_daughterboard_attack'])
        hardware_select_dlg.show()
        hardware_select_dlg.exec_() 
        
    def _slotTopIQ_Clicked(self):
        """ Select IQ hardware option at the top of the window.
        """
        hardware_select_dlg = HardwareSelectDialog(parent=self, mode="IQ:",
            hardware=self.dashboard_settings_dictionary['hardware_iq'], ip=self.dashboard_settings_dictionary['hardware_ip_iq'], serial=self.dashboard_settings_dictionary['hardware_serial_iq'], interface=self.dashboard_settings_dictionary['hardware_interface_iq'], daughterboard=self.dashboard_settings_dictionary['hardware_daughterboard_iq'])
        hardware_select_dlg.show()
        hardware_select_dlg.exec_() 
        
    def _slotTopArchiveClicked(self):
        """ Select Archive hardware option at the top of the window.
        """
        hardware_select_dlg = HardwareSelectDialog(parent=self, mode="Archive:",
            hardware=self.dashboard_settings_dictionary['hardware_archive'], ip=self.dashboard_settings_dictionary['hardware_ip_archive'], serial=self.dashboard_settings_dictionary['hardware_serial_archive'], interface=self.dashboard_settings_dictionary['hardware_interface_archive'], daughterboard=self.dashboard_settings_dictionary['hardware_daughterboard_archive'])
        hardware_select_dlg.show()
        hardware_select_dlg.exec_()         
        
    def configureTSI_Hardware(self):
        """ Configures TSI after new hardware selection.
        """
        if self.dashboard_settings_dictionary['hardware_tsi'] == "Computer":
            self.comboBox_tsi_detector.setCurrentIndex(0)  
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png")) 
            
            # Tuning Widget Limits
            self.tuning_matplotlib_widget.freq_start_limit = 1
            self.tuning_matplotlib_widget.freq_end_limit = 6000        
            
        elif self.dashboard_settings_dictionary['hardware_tsi'] == "USRP X310":
            self.comboBox_tsi_detector.setCurrentIndex(0)
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_X310.png")) 
            
            # Tuning Widget Limits
            if self.dashboard_settings_dictionary['hardware_daughterboard_tsi'] == "CBX":
                self.tuning_matplotlib_widget.freq_start_limit = 1200
                self.tuning_matplotlib_widget.freq_end_limit = 6000
            elif self.dashboard_settings_dictionary['hardware_daughterboard_tsi'] == "SBX":
                self.tuning_matplotlib_widget.freq_start_limit = 400
                self.tuning_matplotlib_widget.freq_end_limit = 4400
            elif self.dashboard_settings_dictionary['hardware_daughterboard_tsi'] == "UBX":
                self.tuning_matplotlib_widget.freq_start_limit = 10
                self.tuning_matplotlib_widget.freq_end_limit = 6000         
            elif self.dashboard_settings_dictionary['hardware_daughterboard_tsi'] == "WBX":
                self.tuning_matplotlib_widget.freq_start_limit = 25
                self.tuning_matplotlib_widget.freq_end_limit = 2200         
                   
        elif self.dashboard_settings_dictionary['hardware_tsi'] == "USRP B210":
            self.comboBox_tsi_detector.setCurrentIndex(1)
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B210.png")) 
            
            # Tuning Widget Limits
            self.tuning_matplotlib_widget.freq_start_limit = 70
            self.tuning_matplotlib_widget.freq_end_limit = 6000
                
        elif self.dashboard_settings_dictionary['hardware_tsi'] == "HackRF":
            self.comboBox_tsi_detector.setCurrentIndex(2)            
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/HackRF.png")) 
            
            # Tuning Widget Limits
            self.tuning_matplotlib_widget.freq_start_limit = 1
            self.tuning_matplotlib_widget.freq_end_limit = 6000
                        
        elif self.dashboard_settings_dictionary['hardware_tsi'] == "RTL2832U":
            self.comboBox_tsi_detector.setCurrentIndex(4)
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/RTL2832U.png")) 
            
            # Tuning Widget Limits
            self.tuning_matplotlib_widget.freq_start_limit = 64
            self.tuning_matplotlib_widget.freq_end_limit = 1700
            
        elif self.dashboard_settings_dictionary['hardware_tsi'] == "802.11x Adapter":
            self.comboBox_tsi_detector.setCurrentIndex(0)  
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/802_11.png")) 
            
            # Tuning Widget Limits
            self.tuning_matplotlib_widget.freq_start_limit = 1
            self.tuning_matplotlib_widget.freq_end_limit = 6000
            
        elif self.dashboard_settings_dictionary['hardware_tsi'] == "USRP B205mini":
            self.comboBox_tsi_detector.setCurrentIndex(3)
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B205mini.png")) 
            
            # Tuning Widget Limits
            self.tuning_matplotlib_widget.freq_start_limit = 70
            self.tuning_matplotlib_widget.freq_end_limit = 6000            
            
        elif self.dashboard_settings_dictionary['hardware_tsi'] == "LimeSDR":
            self.comboBox_tsi_detector.setCurrentIndex(5)
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/LimeSDR.png")) 
            
            # Tuning Widget Limits
            self.tuning_matplotlib_widget.freq_start_limit = 1
            self.tuning_matplotlib_widget.freq_end_limit = 3800
            
        elif self.dashboard_settings_dictionary['hardware_tsi'] == "bladeRF":
            self.comboBox_tsi_detector.setCurrentIndex(6)
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/BladeRF.png")) 
            
            # Tuning Widget Limits
            self.tuning_matplotlib_widget.freq_start_limit = 280
            self.tuning_matplotlib_widget.freq_end_limit = 3800
            
        elif self.dashboard_settings_dictionary['hardware_tsi'] == "Open Sniffer":
            self.comboBox_tsi_detector.setCurrentIndex(0)  
            self.label_top_tsi_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/Open_Sniffer.png")) 
            
            # Tuning Widget Limits
            self.tuning_matplotlib_widget.freq_start_limit = 1
            self.tuning_matplotlib_widget.freq_end_limit = 6000            
            
        # Hardware Button Tooltip
        if len(self.dashboard_settings_dictionary['hardware_tsi']) > 0:
            self.pushButton_top_tsi.setToolTip(self.dashboard_settings_dictionary['hardware_tsi'])
        else:
            self.pushButton_top_tsi.setToolTip('None')
                        
    def configurePD_Hardware(self):
        """ Configures PD after new hardware selection.
        """
        self.textEdit_pd_sniffer_interface.setPlainText(self.dashboard_settings_dictionary['hardware_interface_pd']) 
        if self.dashboard_settings_dictionary['hardware_pd'] == "Computer":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png")) 
            self.comboBox_pd_demod_hardware.setCurrentIndex(0)        
        elif self.dashboard_settings_dictionary['hardware_pd'] == "USRP X310":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_X310.png"))
            self.comboBox_pd_demod_hardware.setCurrentIndex(0)
        elif self.dashboard_settings_dictionary['hardware_pd'] == "USRP B210":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B210.png"))
            self.comboBox_pd_demod_hardware.setCurrentIndex(1)
        elif self.dashboard_settings_dictionary['hardware_pd'] == "HackRF":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/HackRF.png"))         
            self.comboBox_pd_demod_hardware.setCurrentIndex(2)
        elif self.dashboard_settings_dictionary['hardware_pd'] == "RTL2832U":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/RTL2832U.png"))
            self.comboBox_pd_demod_hardware.setCurrentIndex(3)
        elif self.dashboard_settings_dictionary['hardware_pd'] == "802.11x Adapter":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/802_11.png")) 
            self.comboBox_pd_demod_hardware.setCurrentIndex(4)
        elif self.dashboard_settings_dictionary['hardware_pd'] == "USRP B205mini":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B205mini.png"))
            self.comboBox_pd_demod_hardware.setCurrentIndex(5)
        elif self.dashboard_settings_dictionary['hardware_pd'] == "LimeSDR":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/LimeSDR.png")) 
            self.comboBox_pd_demod_hardware.setCurrentIndex(6)
        elif self.dashboard_settings_dictionary['hardware_pd'] == "bladeRF":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/BladeRF.png")) 
            self.comboBox_pd_demod_hardware.setCurrentIndex(7)
        elif self.dashboard_settings_dictionary['hardware_pd'] == "Open Sniffer":
            self.label_top_pd_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/Open_Sniffer.png")) 
            self.comboBox_pd_demod_hardware.setCurrentIndex(0)
            
        # Hardware Button Tooltip
        if len(self.dashboard_settings_dictionary['hardware_pd']) > 0:
            self.pushButton_top_pd.setToolTip(self.dashboard_settings_dictionary['hardware_pd'])
        else:
            self.pushButton_top_pd.setToolTip('None')
        
    def configureAttackHardware(self):
        """ Configures Attack after new hardware selection.
        """
        if self.dashboard_settings_dictionary['hardware_attack'] == "Computer":
            self.comboBox_attack_hardware.setCurrentIndex(0)
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png"))
        elif self.dashboard_settings_dictionary['hardware_attack'] == "USRP X310":
            self.comboBox_attack_hardware.setCurrentIndex(1)
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_X310.png"))
        elif self.dashboard_settings_dictionary['hardware_attack'] == "USRP B210":
            self.comboBox_attack_hardware.setCurrentIndex(2)
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B210.png"))
        elif self.dashboard_settings_dictionary['hardware_attack'] == "HackRF":
            self.comboBox_attack_hardware.setCurrentIndex(3)   
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/HackRF.png"))         
        elif self.dashboard_settings_dictionary['hardware_attack'] == "RTL2832U":
            self.comboBox_attack_hardware.setCurrentIndex(4)
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/RTL2832U.png"))
        elif self.dashboard_settings_dictionary['hardware_attack'] == "802.11x Adapter":
            self.comboBox_attack_hardware.setCurrentIndex(5)   
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/802_11.png")) 
        elif self.dashboard_settings_dictionary['hardware_attack'] == "USRP B205mini":
            self.comboBox_attack_hardware.setCurrentIndex(6)
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B205mini.png"))
        elif self.dashboard_settings_dictionary['hardware_attack'] == "LimeSDR":
            self.comboBox_attack_hardware.setCurrentIndex(7)  
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/LimeSDR.png")) 
        elif self.dashboard_settings_dictionary['hardware_attack'] == "bladeRF":
            self.comboBox_attack_hardware.setCurrentIndex(8)  
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/BladeRF.png"))    
        elif self.dashboard_settings_dictionary['hardware_attack'] == "Open Sniffer":
            self.comboBox_attack_hardware.setCurrentIndex(8)  
            self.label_top_attack_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/Open_Sniffer.png"))    
            
        # Hardware Button Tooltip
        if len(self.dashboard_settings_dictionary['hardware_attack']) > 0:
            self.pushButton_top_attack.setToolTip(self.dashboard_settings_dictionary['hardware_attack'])
        else:
            self.pushButton_top_attack.setToolTip('None')
        
    def configureIQ_Hardware(self):
        """ Configures IQ after new hardware selection.
        """
        if self.dashboard_settings_dictionary['hardware_iq'] == "Computer":
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png")) 
            self._slotIQ_InspectionHardwareChanged()
            self.frame_iq_playback.setEnabled(False)
            self.frame_iq_record.setEnabled(False)        
        
        elif self.dashboard_settings_dictionary['hardware_iq'] == "USRP X310":
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_X310.png"))
            
            # IQ Record
            comboBox_channel = QtWidgets.QComboBox(self)
            comboBox_channel.addItem("A:0")
            comboBox_channel.addItem("B:0") 
            self.tableWidget_iq_record.setCellWidget(0,2,comboBox_channel)
            comboBox_antenna = QtWidgets.QComboBox(self)
            comboBox_antenna.addItem("TX/RX")
            comboBox_antenna.addItem("RX2") 
            self.tableWidget_iq_record.setCellWidget(0,3,comboBox_antenna)      
            gain_item = QtWidgets.QTableWidgetItem("30")
            gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_record.setItem(0,4,gain_item)
            comboBox_antenna = self.tableWidget_iq_record.cellWidget(0,3)
            self.tableWidget_iq_record.resizeColumnsToContents()
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(False)  # Needs to toggle in PyQt5
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(True)
            
            # IQ Playback
            comboBox_playback_channel = QtWidgets.QComboBox(self)            
            comboBox_playback_channel.addItem("A:0")
            comboBox_playback_channel.addItem("B:0") 
            self.tableWidget_iq_playback.setCellWidget(0,1,comboBox_playback_channel)
            comboBox_playback_antenna = QtWidgets.QComboBox(self)
            comboBox_playback_antenna.addItem("TX/RX")
            self.tableWidget_iq_playback.setCellWidget(0,2,comboBox_playback_antenna)             
            playback_gain_item = QtWidgets.QTableWidgetItem("30")
            playback_gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_playback.setItem(0,3,playback_gain_item)
            self.tableWidget_iq_playback.resizeColumnsToContents() 
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(True)
            
            self._slotIQ_InspectionHardwareChanged()
            self.frame_iq_record.setEnabled(True)
            
        elif self.dashboard_settings_dictionary['hardware_iq'] == "USRP B210":
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B210.png"))
            
            # IQ Record
            comboBox_channel = QtWidgets.QComboBox(self)
            comboBox_channel.addItem("A:A")
            comboBox_channel.addItem("A:B") 
            self.tableWidget_iq_record.setCellWidget(0,2,comboBox_channel)
            comboBox_antenna = QtWidgets.QComboBox(self)
            comboBox_antenna.addItem("TX/RX")
            comboBox_antenna.addItem("RX2") 
            self.tableWidget_iq_record.setCellWidget(0,3,comboBox_antenna)      
            gain_item = QtWidgets.QTableWidgetItem("60")
            gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_record.setItem(0,4,gain_item)
            comboBox_antenna = self.tableWidget_iq_record.cellWidget(0,3)
            self.tableWidget_iq_record.resizeColumnsToContents()
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(False)  # Needs to toggle in PyQt5
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(True)
            
            # IQ Playback
            comboBox_playback_channel = QtWidgets.QComboBox(self)            
            comboBox_playback_channel.addItem("A:A")
            comboBox_playback_channel.addItem("A:B") 
            self.tableWidget_iq_playback.setCellWidget(0,1,comboBox_playback_channel)
            comboBox_playback_antenna = QtWidgets.QComboBox(self)
            comboBox_playback_antenna.addItem("TX/RX")
            self.tableWidget_iq_playback.setCellWidget(0,2,comboBox_playback_antenna)             
            playback_gain_item = QtWidgets.QTableWidgetItem("60")
            playback_gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_playback.setItem(0,3,playback_gain_item)
            self.tableWidget_iq_playback.resizeColumnsToContents()
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(True)            
            
            self._slotIQ_InspectionHardwareChanged()   
            self.frame_iq_record.setEnabled(True)
                            
        elif self.dashboard_settings_dictionary['hardware_iq'] == "HackRF":
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/HackRF.png"))   
            
            # IQ Record
            comboBox_channel = QtWidgets.QComboBox(self)
            comboBox_channel.addItem("")
            self.tableWidget_iq_record.setCellWidget(0,2,comboBox_channel)
            comboBox_antenna = QtWidgets.QComboBox(self)
            comboBox_antenna.addItem("")
            self.tableWidget_iq_record.setCellWidget(0,3,comboBox_antenna)      
            gain_item = QtWidgets.QTableWidgetItem("20")
            gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_record.setItem(0,4,gain_item)
            comboBox_antenna = self.tableWidget_iq_record.cellWidget(0,3)
            self.tableWidget_iq_record.resizeColumnsToContents()
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(False)  # Needs to toggle in PyQt5
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(True)
            
            # IQ Playback
            comboBox_playback_channel = QtWidgets.QComboBox(self)            
            comboBox_playback_channel.addItem("")
            self.tableWidget_iq_playback.setCellWidget(0,1,comboBox_playback_channel)
            comboBox_playback_antenna = QtWidgets.QComboBox(self)
            comboBox_playback_antenna.addItem("")
            self.tableWidget_iq_playback.setCellWidget(0,2,comboBox_playback_antenna)             
            playback_gain_item = QtWidgets.QTableWidgetItem("20")
            playback_gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_playback.setItem(0,3,playback_gain_item)
            self.tableWidget_iq_playback.resizeColumnsToContents()
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(True)            
            
            self._slotIQ_InspectionHardwareChanged()
            self.frame_iq_record.setEnabled(True)
                 
        elif self.dashboard_settings_dictionary['hardware_iq'] == "RTL2832U":  # To Do
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/RTL2832U.png"))
            
            # IQ Record
            comboBox_channel = QtWidgets.QComboBox(self)
            comboBox_channel.addItem("")
            self.tableWidget_iq_record.setCellWidget(0,2,comboBox_channel)
            comboBox_antenna = QtWidgets.QComboBox(self)
            comboBox_antenna.addItem("")
            self.tableWidget_iq_record.setCellWidget(0,3,comboBox_antenna)      
            gain_item = QtWidgets.QTableWidgetItem("20")
            gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_record.setItem(0,4,gain_item)
            comboBox_antenna = self.tableWidget_iq_record.cellWidget(0,3)
            self.tableWidget_iq_record.resizeColumnsToContents()
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(False)  # Needs to toggle in PyQt5
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(True)
            
            self._slotIQ_InspectionHardwareChanged()
            self.frame_iq_playback.setEnabled(False)
            self.frame_iq_record.setEnabled(True)
            
        elif self.dashboard_settings_dictionary['hardware_iq'] == "802.11x Adapter":
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/802_11.png")) 
            self._slotIQ_InspectionHardwareChanged()
            self.frame_iq_playback.setEnabled(False)
            self.frame_iq_record.setEnabled(False)
            
        elif self.dashboard_settings_dictionary['hardware_iq'] == "USRP B205mini":
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B205mini.png"))
            self._slotIQ_InspectionHardwareChanged()
            
            # IQ Record
            comboBox_channel = QtWidgets.QComboBox(self)
            comboBox_channel.addItem("A:A")
            comboBox_channel.addItem("A:B") 
            self.tableWidget_iq_record.setCellWidget(0,2,comboBox_channel)
            comboBox_antenna = QtWidgets.QComboBox(self)
            comboBox_antenna.addItem("TX/RX")
            comboBox_antenna.addItem("RX2") 
            self.tableWidget_iq_record.setCellWidget(0,3,comboBox_antenna)      
            gain_item = QtWidgets.QTableWidgetItem("60")
            gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_record.setItem(0,4,gain_item)
            comboBox_antenna = self.tableWidget_iq_record.cellWidget(0,3)
            self.tableWidget_iq_record.resizeColumnsToContents()
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(False)  # Needs to toggle in PyQt5
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(True)
            
            # IQ Playback
            comboBox_playback_channel = QtWidgets.QComboBox(self)            
            comboBox_playback_channel.addItem("A:A")
            comboBox_playback_channel.addItem("A:B") 
            self.tableWidget_iq_playback.setCellWidget(0,1,comboBox_playback_channel)
            comboBox_playback_antenna = QtWidgets.QComboBox(self)
            comboBox_playback_antenna.addItem("TX/RX")
            self.tableWidget_iq_playback.setCellWidget(0,2,comboBox_playback_antenna)             
            playback_gain_item = QtWidgets.QTableWidgetItem("60")
            playback_gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_playback.setItem(0,3,playback_gain_item)       
            self.tableWidget_iq_playback.resizeColumnsToContents()  
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(True)            
            
            self.frame_iq_record.setEnabled(True)    
                      
        elif self.dashboard_settings_dictionary['hardware_iq'] == "LimeSDR":
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/LimeSDR.png")) 
            self._slotIQ_InspectionHardwareChanged()
            
            # IQ Record
            comboBox_channel = QtWidgets.QComboBox(self)
            comboBox_channel.addItem("A")
            comboBox_channel.addItem("B") 
            self.tableWidget_iq_record.setCellWidget(0,2,comboBox_channel)
            comboBox_antenna = QtWidgets.QComboBox(self)
            comboBox_antenna.addItem("RX1")
            comboBox_antenna.addItem("RX2") 
            self.tableWidget_iq_record.setCellWidget(0,3,comboBox_antenna)      
            gain_item = QtWidgets.QTableWidgetItem("55")
            gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_record.setItem(0,4,gain_item)
            comboBox_antenna = self.tableWidget_iq_record.cellWidget(0,3)
            self.tableWidget_iq_record.resizeColumnsToContents()
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(False)  # Needs to toggle in PyQt5
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(True)
            
            # IQ Playback
            comboBox_playback_channel = QtWidgets.QComboBox(self)            
            comboBox_playback_channel.addItem("A")
            comboBox_playback_channel.addItem("B") 
            self.tableWidget_iq_playback.setCellWidget(0,1,comboBox_playback_channel)
            comboBox_playback_antenna = QtWidgets.QComboBox(self)
            comboBox_playback_antenna.addItem("TX1")
            comboBox_playback_antenna.addItem("TX2")
            self.tableWidget_iq_playback.setCellWidget(0,2,comboBox_playback_antenna)             
            playback_gain_item = QtWidgets.QTableWidgetItem("55")
            playback_gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_playback.setItem(0,3,playback_gain_item)
            self.tableWidget_iq_playback.resizeColumnsToContents()
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(True)            
            
            self.frame_iq_record.setEnabled(True)
            
        elif self.dashboard_settings_dictionary['hardware_iq'] == "bladeRF":  # To Do
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/BladeRF.png"))
            self._slotIQ_InspectionHardwareChanged()
            
            # IQ Record
            comboBox_channel = QtWidgets.QComboBox(self)
            comboBox_channel.addItem("")
            comboBox_channel.addItem("") 
            self.tableWidget_iq_record.setCellWidget(0,2,comboBox_channel)
            comboBox_antenna = QtWidgets.QComboBox(self)
            comboBox_antenna.addItem("")
            comboBox_antenna.addItem("") 
            self.tableWidget_iq_record.setCellWidget(0,3,comboBox_antenna)      
            gain_item = QtWidgets.QTableWidgetItem("20")
            gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_record.setItem(0,4,gain_item)
            comboBox_antenna = self.tableWidget_iq_record.cellWidget(0,3)
            self.tableWidget_iq_record.resizeColumnsToContents()
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(False)  # Needs to toggle in PyQt5
            self.tableWidget_iq_record.horizontalHeader().setStretchLastSection(True)
            
            # IQ Playback
            comboBox_playback_channel = QtWidgets.QComboBox(self)            
            comboBox_playback_channel.addItem("")
            comboBox_playback_channel.addItem("") 
            self.tableWidget_iq_playback.setCellWidget(0,1,comboBox_playback_channel)
            comboBox_playback_antenna = QtWidgets.QComboBox(self)
            comboBox_playback_antenna.addItem("")
            comboBox_playback_antenna.addItem("")
            self.tableWidget_iq_playback.setCellWidget(0,2,comboBox_playback_antenna)             
            playback_gain_item = QtWidgets.QTableWidgetItem("20")
            playback_gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            self.tableWidget_iq_playback.setItem(0,3,playback_gain_item)
            self.tableWidget_iq_playback.resizeColumnsToContents()
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_iq_playback.horizontalHeader().setStretchLastSection(True)            
            
            self.frame_iq_record.setEnabled(True)
            
        elif self.dashboard_settings_dictionary['hardware_iq'] == "Open Sniffer":
            self.label_top_iq_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/Open_Sniffer.png")) 
            self._slotIQ_InspectionHardwareChanged()
            self.frame_iq_playback.setEnabled(False)
            self.frame_iq_record.setEnabled(False)            
        
            
        # # Adjust Existing Channel ComboBoxes and Gain in Replay Tab
        # for n in range(0, self.tableWidget_archive_replay.rowCount()):
            # get_combobox = self.tableWidget_archive_replay.cellWidget(n,6)
            # get_combobox.clear()            
            # if self.dashboard_settings_dictionary['hardware_archive'] == "USRP X310":
                # get_combobox.addItem("A:0")
                # get_combobox.addItem("B:0")    
                # gain_item = QtWidgets.QTableWidgetItem("30")
                # gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                # self.tableWidget_archive_replay.setItem(n,7,gain_item)
            # elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B210":
                # get_combobox.addItem("A:A")
                # get_combobox.addItem("A:B")
                # gain_item = QtWidgets.QTableWidgetItem("60")
                # gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                # self.tableWidget_archive_replay.setItem(n,7,gain_item)
            # elif self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
                # get_combobox.addItem("")
                # gain_item = QtWidgets.QTableWidgetItem("20")
                # gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                # self.tableWidget_archive_replay.setItem(n,7,gain_item)
            # elif self.dashboard_settings_dictionary['hardware_archive'] == "RTL2832U":
                # get_combobox.addItem("")
            # elif self.dashboard_settings_dictionary['hardware_archive'] == "802.11x Adapter":
                # get_combobox.addItem("")
            # elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B205mini":
                # get_combobox.addItem("A:A")
                # get_combobox.addItem("A:B")          
                # gain_item = QtWidgets.QTableWidgetItem("60")
                # gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                # self.tableWidget_archive_replay.setItem(n,7,gain_item)          
            # elif self.dashboard_settings_dictionary['hardware_archive'] == "LimeSDR":
                # get_combobox.addItem("A")
                # get_combobox.addItem("B")
                # gain_item = QtWidgets.QTableWidgetItem("55")
                # gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                # self.tableWidget_archive_replay.setItem(n,7,gain_item)
            # elif self.dashboard_settings_dictionary['hardware_archive'] == "bladeRF":      
                # get_combobox.addItem("")      
                # gain_item = QtWidgets.QTableWidgetItem("20")
                # gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                # self.tableWidget_archive_replay.setItem(n,7,gain_item)   
            # else:
                # get_combobox.addItem("")            
        
        # Enable Playback and Recording
        self.pushButton_iq_playback.setEnabled(True)
        self.label_iq_playback_status.setEnabled(True)
        self.pushButton_iq_record.setEnabled(True)
        self.label_iq_status_files.setEnabled(True)
        self.pushButton_iq_playback_record_freq.setEnabled(True)
        self.pushButton_iq_playback_record_gain.setEnabled(True)
        self.pushButton_iq_playback_record_rate.setEnabled(True)
        
        # Hardware Button Tooltip
        if len(self.dashboard_settings_dictionary['hardware_iq']) > 0:
            self.pushButton_top_iq.setToolTip(self.dashboard_settings_dictionary['hardware_iq'])
        else:
            self.pushButton_top_iq.setToolTip('None')        
        
    def configureArchiveHardware(self):
        """ Configures Archive after new hardware selection.
        """        
        if self.dashboard_settings_dictionary['hardware_archive'] == "Computer":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/computer.png"))
        elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP X310":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_X310.png"))
        elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B210":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B210.png"))
        elif self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/HackRF.png"))         
        elif self.dashboard_settings_dictionary['hardware_archive'] == "RTL2832U":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/RTL2832U.png"))
        elif self.dashboard_settings_dictionary['hardware_archive'] == "802.11x Adapter":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/802_11.png")) 
        elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B205mini":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/USRP_B205mini.png"))
        elif self.dashboard_settings_dictionary['hardware_archive'] == "LimeSDR":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/LimeSDR.png")) 
        elif self.dashboard_settings_dictionary['hardware_archive'] == "bladeRF":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/BladeRF.png"))    
        elif self.dashboard_settings_dictionary['hardware_archive'] == "Open Sniffer":
            self.label_top_archive_picture.setPixmap(QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Icons/Open_Sniffer.png"))    
            
        # Adjust Existing Channel ComboBoxes and Gain in Replay Tab
        for n in range(0, self.tableWidget_archive_replay.rowCount()):
            get_combobox = self.tableWidget_archive_replay.cellWidget(n,6)
            get_combobox.clear()         
            if self.dashboard_settings_dictionary['hardware_archive'] == "Computer":
                get_combobox.addItem("")               
            elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP X310":
                get_combobox.addItem("A:0")
                get_combobox.addItem("B:0")    
                gain_item = QtWidgets.QTableWidgetItem("30")
                gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                self.tableWidget_archive_replay.setItem(n,7,gain_item)
            elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B210":
                get_combobox.addItem("A:A")
                get_combobox.addItem("A:B")
                gain_item = QtWidgets.QTableWidgetItem("60")
                gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                self.tableWidget_archive_replay.setItem(n,7,gain_item)
            elif self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
                get_combobox.addItem("")
                gain_item = QtWidgets.QTableWidgetItem("20")
                gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                self.tableWidget_archive_replay.setItem(n,7,gain_item)
            elif self.dashboard_settings_dictionary['hardware_archive'] == "RTL2832U":
                get_combobox.addItem("")
            elif self.dashboard_settings_dictionary['hardware_archive'] == "802.11x Adapter":
                get_combobox.addItem("")
            elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B205mini":
                get_combobox.addItem("A:A")
                get_combobox.addItem("A:B")          
                gain_item = QtWidgets.QTableWidgetItem("60")
                gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                self.tableWidget_archive_replay.setItem(n,7,gain_item)          
            elif self.dashboard_settings_dictionary['hardware_archive'] == "LimeSDR":
                get_combobox.addItem("A")
                get_combobox.addItem("B")
                gain_item = QtWidgets.QTableWidgetItem("55")
                gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                self.tableWidget_archive_replay.setItem(n,7,gain_item)
            elif self.dashboard_settings_dictionary['hardware_archive'] == "bladeRF":      
                get_combobox.addItem("")      
                gain_item = QtWidgets.QTableWidgetItem("20")
                gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                self.tableWidget_archive_replay.setItem(n,7,gain_item)   
            elif self.dashboard_settings_dictionary['hardware_archive'] == "Open Sniffer":
                get_combobox.addItem("")            
            else:
                get_combobox.addItem("")
                
        # Hardware Button Tooltip
        if len(self.dashboard_settings_dictionary['hardware_archive']) > 0:
            self.pushButton_top_archive.setToolTip(self.dashboard_settings_dictionary['hardware_archive'])
        else:
            self.pushButton_top_archive.setToolTip('None')
        
    def _slotMenuHelpClicked(self):
        """ Opens a new window with help information following a menu click.
        """
        help_dlg = HelpMenuDialog()
        help_dlg.show()
        help_dlg.exec_() 
        
    def _slotMenuMonitorModeToolClicked(self):
        """ Launches the CLI Tool for quickly changing wireless interface configurations.
        """
        # Run Monitor Mode Tool
        monitor_mode_tool_directory = os.path.dirname(os.path.abspath(__file__)) + "/Tools/Monitor_Mode_Tool/"
        proc=subprocess.Popen("gnome-terminal -- python2 monitor_mode_tool.py", cwd=monitor_mode_tool_directory, shell=True)
        
    def _slotIQ_CropClicked(self):
        """ Crops a data file to a smaller size.
        """
        # Get Crop Settings
        get_file_path_original = str(self.textEdit_iq_crop_original.toPlainText())
        get_file_path = str(self.textEdit_iq_crop_new.toPlainText())
        get_start = str(int(str(self.textEdit_iq_crop_start.toPlainText()))-1)
        get_end = str(self.textEdit_iq_crop_end.toPlainText())
        get_data_type = str(self.comboBox_iq_crop_data_type.currentText())        
        
        # Sample Size in Bytes        
        if get_data_type == "Complex Float 32":
            bs = "8"
        elif get_data_type == "Float/Float 32":
            bs = "4"
        elif get_data_type == "Short/Int 16":
            bs = "2"
        elif get_data_type == "Int/Int 32":
            bs = "4"
        elif get_data_type == "Byte/Int 8":
            bs = "1"
        elif get_data_type == "Complex Float 64":
            bs = "16"
        elif get_data_type == "Complex Int 64":
            bs = "16"
        elif get_data_type == "Complex Int 16":
            bs = "4"
        elif get_data_type == "Complex Int 8":
            bs = "2"
        else:
            self.errorMessage("Cannot crop " + get_data_type + ".")
            return

        # Calculate Number of Samples
        num_samples = str(int(get_end)-int(get_start))
                
        # Save File         
        os.system('dd if="'+ get_file_path_original + '" of="' + get_file_path + '" bs=' + bs + " skip=" + get_start + " count=" + num_samples)
        
        # Refresh Listbox
        self._slotIQ_RefreshClicked()
        
    def _slotIQ_StartChanged(self):
        """ Updates the Crop start sample.
        """
        get_start = str(self.textEdit_iq_start.toPlainText())
        self.textEdit_iq_crop_start.setText(get_start)
    
    def _slotIQ_EndChanged(self):
        """ Updates the Crop end sample.
        """
        get_end = str(self.textEdit_iq_end.toPlainText())
        self.textEdit_iq_crop_end.setText(get_end)
        
    def _slotIQ_PlotAllClicked(self):
        """ Plots all samples of an IQ file.
        """
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
        
        # File with Zero Bytes
        if number_of_bytes <= 0:
            print("File is empty")

        # Skip Bytes if File is Too Large        
        else:
            
            # Get the Number of Samples
            start_sample = 1
            num_samples = int(self.label_iq_samples.text().split(" ")[1])
        
            # Get the Size of Each Sample in Bytes   
            complex_multiple = 1   
            if get_type == "Complex Float 32":
                sample_size = 4
                complex_multiple = 2
                num_samples = complex_multiple * num_samples               
            elif get_type == "Float/Float 32":
                sample_size = 4
            elif get_type == "Short/Int 16":
                sample_size = 2
            elif get_type == "Int/Int 32":
                sample_size = 4
            elif get_type == "Byte/Int 8":
                sample_size = 1
            elif get_type == "Complex Int 16":
                sample_size = 2
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
            elif get_type == "Complex Int 8":
                sample_size = 1
                complex_multiple = 2
                num_samples = complex_multiple * num_samples   
            elif get_type == "Complex Float 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples 
            elif get_type == "Complex Int 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples 
                            
            # Read the Data 
            plot_data = b''
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            try:
                if "Complex" in get_type:
                    starting_byte = 2*(start_sample-1) * sample_size
                else:
                    starting_byte = (start_sample-1) * sample_size
                  
                # No Skip
                if number_of_bytes <= 400000:                   
                    skip = 1
                    file.seek(starting_byte)
                    plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
                    
                # Skip
                else:
                    # Every 10th Sample
                    if number_of_bytes > 400000 and number_of_bytes <= 4000000:
                        skip = 10
                        
                    # Every 100th Sample
                    elif number_of_bytes > 4000000 and number_of_bytes <= 40000000:
                        skip = 100
                        
                    # Skip 1000
                    else:
                        skip = 1000
                    
                    # Read
                    for n in range(starting_byte,number_of_bytes,(sample_size*skip*complex_multiple)):
                        file.seek(n)
                        plot_data = plot_data + file.read(sample_size)
                        if "Complex" in get_type:
                            plot_data = plot_data + file.read(sample_size)

            except:
                # Close the File
                file.close() 
            
            # Close the File
            file.close()         
                             
            # Format the Data
            if get_type == "Complex Float 32":
                #plot_data_formatted = struct.unpack(num_samples/skip*'f', plot_data)
                plot_data_formatted = struct.unpack(int(len(plot_data)/4)*'f', plot_data)
            elif get_type == "Float/Float 32":
                plot_data_formatted = struct.unpack(int(len(plot_data)/4)*'f', plot_data)
            elif get_type == "Short/Int 16":
                plot_data_formatted = struct.unpack(int(len(plot_data)/2)*'h', plot_data)
            elif get_type == "Int/Int 32":
                plot_data_formatted = struct.unpack(int(len(plot_data)/4)*'i', plot_data)
            elif get_type == "Byte/Int 8":
                plot_data_formatted = struct.unpack(int(len(plot_data)/1)*'b', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(int(len(plot_data)/2)*'h', plot_data)
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(int(len(plot_data)/1)*'b', plot_data)
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(int(len(plot_data)/8)*'d', plot_data)
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(int(len(plot_data)/8)*'l', plot_data)
            
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)
            if "Complex" in get_type:
                # Ignore hold() Deprecation Warnings
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore")
                    warnings.filterwarnings("ignore", module="matplotlib")
                    
                    # Plot
                    self.iq_matplotlib_widget.axes.plot(range(1,len(plot_data_formatted[::2])+1),plot_data_formatted[::2],'b',linewidth=1,zorder=2)
                    #self.iq_matplotlib_widget.axes.hold(True)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
                    self.iq_matplotlib_widget.axes.plot(range(1,len(plot_data_formatted[::2])+1),plot_data_formatted[1::2],'r',linewidth=1,zorder=2)
                    # self.iq_matplotlib_widget.axes.hold(False)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
            else:
                self.iq_matplotlib_widget.axes.plot(range(1,len(plot_data_formatted)+1),plot_data_formatted,'b',linewidth=1,zorder=2)
                
            # Axes Label
            if skip == 1:
                self.iq_matplotlib_widget.applyLabels("IQ Data",'Samples','Amplitude (LSB)',None,None) 
            elif skip == 10:
                self.iq_matplotlib_widget.applyLabels("IQ Data",'Samples/10','Amplitude (LSB)',None,None) 
            elif skip == 100:
                self.iq_matplotlib_widget.applyLabels("IQ Data",'Samples/100','Amplitude (LSB)',None,None)                         
            else:
                self.iq_matplotlib_widget.applyLabels("IQ Data",'Samples/1000','Amplitude (LSB)',None,None)                 
                
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  
            #self.iq_matplotlib_widget.draw()
            
            # Reset Range Cursor Memory
            self.iq_plot_range_start = 0
            self.iq_plot_range_end = 0

  
            
    def _slotIQ_PlotMagnitudeClicked(self):
        """ Plots magnitude of loaded IQ data.
        """
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0:
            
            # Get the Number of Samples
            try:
                start_sample = int(self.textEdit_iq_start.toPlainText())
                end_sample = int(self.textEdit_iq_end.toPlainText())
                num_samples = end_sample - start_sample + 1
            except:
                return
            
            # Do Nothing if Bad Range
            if num_samples < 0:
                return
        
            # Get the Size of Each Sample in Bytes   
            complex_multiple = 1  
            if get_type == "Complex Float 32":
                complex_multiple = 2
                sample_size = 4
                num_samples = complex_multiple * num_samples               
            elif get_type == "Float/Float 32":
                sample_size = 4
            elif get_type == "Short/Int 16":
                sample_size = 2
            elif get_type == "Int/Int 32":
                sample_size = 4
            elif get_type == "Byte/Int 8":
                sample_size = 1
            elif get_type == "Complex Int 16":
                complex_multiple = 2
                sample_size = 2
                num_samples = complex_multiple * num_samples    
            elif get_type == "Complex Int 8":
                sample_size = 1
                complex_multiple = 2
                num_samples = complex_multiple * num_samples     
            elif get_type == "Complex Float 64":
                complex_multiple = 2
                sample_size = 8
                num_samples = complex_multiple * num_samples                                
            elif get_type == "Complex Int 64":
                complex_multiple = 2
                sample_size = 8
                num_samples = complex_multiple * num_samples                                
                
            # Check the Range
            if (num_samples*sample_size > number_of_bytes) or (complex_multiple*end_sample*sample_size > number_of_bytes) or (start_sample < 1):
                print("Out of range.")
                return            
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            if "Complex" in get_type:
                file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            else:
                file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Float/Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Short/Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Int/Int 32":
                plot_data_formatted = struct.unpack(num_samples*'i', plot_data)
            elif get_type == "Byte/Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)   
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)                             
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)                             
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)                             
                
            # Get I/Q Data
            if "Complex" in get_type:
                
                I_squared = [float(i)**2 for i in plot_data_formatted[::2]]
                Q_squared = [float(q)**2 for q in plot_data_formatted[1::2]]

                # Calculate AM
                AM = [math.sqrt(I_squared[x] + Q_squared[x]) for x in range(len(I_squared))]
                
            else:
                AM = [math.sqrt(i**2) for i in plot_data_formatted]
                
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)  
            self.iq_matplotlib_widget.axes.plot(range(1,len(AM)+1),AM,'b',linewidth=1)   
            self.iq_matplotlib_widget.applyLabels("Magnitude",'Samples','Amplitude (LSB)',None,None) 
            
            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            #self.iq_matplotlib_widget.draw()
            
        else:
            pass         
        
    def _slotIQ_PlotIF_Clicked(self):
        """ Plots the instantaneous frequency of the loaded IQ data.
        """
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0:
            
            # Get the Number of Samples
            try:
                start_sample = int(self.textEdit_iq_start.toPlainText())
                end_sample = int(self.textEdit_iq_end.toPlainText())
                num_samples = end_sample - start_sample + 1
            except:
                return
            
            # Do Nothing if Bad Range
            if num_samples < 0:
                return
        
            # Get the Size of Each Sample in Bytes  
            complex_multiple = 1    
            if get_type == "Complex Float 32":
                complex_multiple = 2
                sample_size = 4
                num_samples = complex_multiple * num_samples               
            elif get_type == "Float/Float 32":
                sample_size = 4
            elif get_type == "Short/Int 16":
                sample_size = 2
            elif get_type == "Int/Int 32":
                sample_size = 4
            elif get_type == "Byte/Int 8":
                sample_size = 1
            elif get_type == "Complex Int 16":
                complex_multiple = 2
                sample_size = 2
                num_samples = complex_multiple * num_samples    
            elif get_type == "Complex Int 8":
                sample_size = 1
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                     
            elif get_type == "Complex Float 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                     
            elif get_type == "Complex Int 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                     
                
            # Check the Range
            if (num_samples*sample_size > number_of_bytes) or (complex_multiple*end_sample*sample_size > number_of_bytes) or (start_sample < 1):
                print("Out of range.")
                return                        
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            if "Complex" in get_type:
                file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            else:
                file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Float/Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Short/Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Int/Int 32":
                plot_data_formatted = struct.unpack(num_samples*'i', plot_data)
            elif get_type == "Byte/Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)  
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)  
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)  
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)  
                
            # Get I/Q Data
            if "Complex" in get_type:
                
                I = [float(i) for i in plot_data_formatted[::2]]
                Q = [float(q) for q in plot_data_formatted[1::2]]
                complex_data = [complex(I[x],Q[x]) for x in range(len(I))]

                # Calculate I.F. Method 1       
                instantaneous_frequency = np.diff(np.angle(complex_data))
                #instantaneous_frequency = [((math.atan2(Q[x]*(180/math.pi), I[x]*(180/math.pi)))+2*math.pi)%(2*math.pi) for x in range(len(I))]
                                
                ## Calculate I.F. Method 2
                #analytic_signal = hilbert(complex_data)
                #amplitude_envelope = np.abs(analytic_signal)
                #instantaneous_phase = np.unwrap(np.angle(analytic_signal))
                #instantaneous_frequency = np.diff(instantaneous_phase) / (2.0*np.pi) * 1 #fs
                                
            else:
                instantaneous_frequency = None
                
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)            
            self.iq_matplotlib_widget.axes.plot(range(1,len(instantaneous_frequency)+1),instantaneous_frequency,'b',linewidth=1)          
            self.iq_matplotlib_widget.applyLabels("Instantaneous Frequency",'Samples','Amplitude (LSB)',None,None) 
            
            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            #self.iq_matplotlib_widget.draw()
            
        else:
            pass   
            
    def _slotIQ_AppendNull1Clicked(self):
        """ Toggles between using a file or null samples for appending two files.
        """
        # Checked
        if self.checkBox_iq_append_null1.isChecked():
            self.textEdit_iq_append_file1.setEnabled(False)
            self.pushButton_iq_append_select1.setEnabled(False)
            self.pushButton_iq_append_load1.setEnabled(False)
            self.textEdit_iq_append_null1.setEnabled(True)
        
        # Unchecked
        else:
            self.textEdit_iq_append_file1.setEnabled(True)
            self.pushButton_iq_append_select1.setEnabled(True)
            self.pushButton_iq_append_load1.setEnabled(True)
            self.textEdit_iq_append_null1.setEnabled(False)
        
    def _slotIQ_AppendNull2Clicked(self):
        """ Toggles between using a file or null samples for appending two files.
        """
        # Checked
        if self.checkBox_iq_append_null2.isChecked():
            self.textEdit_iq_append_file2.setEnabled(False)
            self.pushButton_iq_append_select2.setEnabled(False)
            self.pushButton_iq_append_load2.setEnabled(False)
            self.textEdit_iq_append_null2.setEnabled(True)
        
        # Unchecked
        else:
            self.textEdit_iq_append_file2.setEnabled(True)
            self.pushButton_iq_append_select2.setEnabled(True)
            self.pushButton_iq_append_load2.setEnabled(True)  
            self.textEdit_iq_append_null2.setEnabled(False) 
            
    def _slotIQ_AppendSelect1Clicked(self):
        """ Copies the filepath of the selected IQ file for appending.
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_append_file1.setPlainText(get_folder + '/' + get_file)    
        except:
            pass

    def _slotIQ_AppendSelect2Clicked(self):
        """ Copies the filepath of the selected IQ file for appending.
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_append_file2.setPlainText(get_folder + '/' + get_file)  
        except:
            pass
        
    def _slotIQ_AppendSelect3Clicked(self):
        """ Copies the filepath of the selected IQ file for appending.
        """ 
        # Get Highlighted File from Listbox
        get_file = str(self.listWidget_iq_files.currentItem().text())
        get_folder = str(self.label_iq_folder.text())
        self.textEdit_iq_append_output.setPlainText(get_folder + '/' + get_file)             
        
    def _slotIQ_AppendLoad1Clicked(self):
        """ Opens a dialog to select an IQ file for appending.
        """
        # Select a Directory
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['IQ/Misc. (*.iq *.dat)','IQ Recordings (*.iq)','Misc. (*.dat)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_append_file1.setPlainText(folder)
        except:
            pass  
        
    def _slotIQ_AppendLoad2Clicked(self):
        """ Opens a dialog to select an IQ file for appending.
        """
        # Select a Directory
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['IQ/Misc. (*.iq *.dat)','IQ Recordings (*.iq)','Misc. (*.dat)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_append_file2.setPlainText(folder)                        
        except:
            pass          
        
    def _slotIQ_AppendLoad3Clicked(self):
        """ Opens a dialog to select an IQ file for appending.
        """
        # Select a Directory
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['IQ/Misc. (*.iq *.dat)','IQ Recordings (*.iq)','Misc. (*.dat)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:
            self.textEdit_iq_append_output.setPlainText(folder)
        except:
            pass        
            
    def _slotIQ_AppendAppendClicked(self):
        """ Concatenates two files together with cat. Prepends/Appends with 0's if null is checked.
        """
        # Get Files
        get_file1 = str(self.textEdit_iq_append_file1.toPlainText())
        get_file2 = str(self.textEdit_iq_append_file2.toPlainText())
        
        # Output File
        get_output_file = str(self.textEdit_iq_append_output.toPlainText())
            
        # Null Checked
        if self.checkBox_iq_append_null1.isChecked() or self.checkBox_iq_append_null2.isChecked():
            # Sample Type
            get_type = self.comboBox_iq_append_data_type.currentText()
            
            # File 1
            if self.checkBox_iq_append_null1.isChecked():
                get_samples1 = str(self.textEdit_iq_append_null1.toPlainText())
                
                # Convert Samples to Bytes
                if get_type == "Complex Float 32":
                    num_bytes1 = str(8 * int(get_samples1))      
                elif get_type == "Float/Float 32":
                    num_bytes1 = str(4 * int(get_samples1))
                elif get_type == "Short/Int 16":
                    num_bytes1 = str(2* int(get_samples1))
                elif get_type == "Int/Int 32":
                    num_bytes1 = str(4 * int(get_samples1))
                elif get_type == "Byte/Int 8":
                    num_bytes1 = str(1 * int(get_samples1))
                elif get_type == "Complex Int 16":
                    num_bytes1 = str(4 * int(get_samples1))                      
                elif get_type == "Complex Int 8":
                    num_bytes1 = str(2 * int(get_samples1))     
                elif get_type == "Complex Float 64":
                    num_bytes1 = str(16 * int(get_samples1))                                       
                elif get_type == "Complex Int 64":
                    num_bytes1 = str(16 * int(get_samples1))                                       
            
            # File 2
            if self.checkBox_iq_append_null2.isChecked():
                get_samples2 = str(self.textEdit_iq_append_null2.toPlainText())
                
                # Convert Samples to Bytes
                if get_type == "Complex Float 32":
                    num_bytes2 = str(8 * int(get_samples2))      
                elif get_type == "Float/Float 32":
                    num_bytes2 = str(4 * int(get_samples2))
                elif get_type == "Short/Int 16":
                    num_bytes2 = str(2* int(get_samples2))
                elif get_type == "Int/Int 32":
                    num_bytes2 = str(4 * int(get_samples2))
                elif get_type == "Byte/Int 8":
                    num_bytes2 = str(1 * int(get_samples2))
                elif get_type == "Complex Int 16":
                    num_bytes2 = str(4 * int(get_samples2))                     
                elif get_type == "Complex Int 8":
                    num_bytes2 = str(2 * int(get_samples2))                     
                elif get_type == "Complex Float 64":
                    num_bytes2 = str(16 * int(get_samples2))                     
                elif get_type == "Complex Int 64":
                    num_bytes2 = str(16 * int(get_samples2))                     
                    
            # Null and File
            if self.checkBox_iq_append_null1.isChecked() and not self.checkBox_iq_append_null2.isChecked():
                os.system('dd if=/dev/zero of="' + get_output_file + '.new" bs=1 count=' + num_bytes1)
                os.system('dd if="' + get_file2 + '" of="' + get_output_file + '.new" bs=' + num_bytes1 + ' seek=1')
                os.system('mv "' + get_output_file + '.new" "' + get_output_file + '"') 
            
            # File and Null
            elif not self.checkBox_iq_append_null1.isChecked() and self.checkBox_iq_append_null2.isChecked():
                os.system('cp "' + get_file1 + '" "' + get_output_file + '.new"')
                os.system('dd if=/dev/zero bs=1 count=' + num_bytes2 + ' >> "' + get_output_file + '.new"')
                os.system('mv "' + get_output_file + '.new" "' + get_output_file + '"') 
            
            # Null and Null
            elif self.checkBox_iq_append_null1.isChecked() and self.checkBox_iq_append_null2.isChecked():
                os.system('dd if=/dev/zero of="' + get_output_file + '" bs=1 count=' + str(int(num_bytes1)+int(num_bytes2)))            
                        
        # Two Files
        else:               
            # Cat Files
            os.system('cat "' + get_file1 + '" "' + get_file2 + '" > "' + get_output_file + '"')
            
        # Refresh
        self._slotIQ_RefreshClicked()
        
    def _slotIQ_DeleteClicked(self):
        """ Deletes an IQ file from the list.
        """
        # Get Highlighted File from Listbox
        if self.listWidget_iq_files.count() > 0:
            get_index = int(self.listWidget_iq_files.currentRow())
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            delete_filepath = get_folder + '/' + get_file
            
            # Delete
            os.system('rm "' + delete_filepath + '"')
            
            # Refresh
            self._slotIQ_RefreshClicked()     
            if get_index == self.listWidget_iq_files.count():
                get_index = get_index -1
            self.listWidget_iq_files.setCurrentRow(get_index)
        
    def _slotIQ_Cursor1Clicked(self):
        """ Add/Removes a cursor on the plot.
        """
        if self.pushButton_iq_cursor1.isChecked():
            self.iq_matplotlib_widget.cursor_enable = True
            self.pushButton_iq_get_range.setEnabled(True)
        else:
            self.pushButton_iq_get_range.setEnabled(False)
            if self.iq_matplotlib_widget.cursor1 != None:
                self.iq_matplotlib_widget.cursor1.remove()
                self.iq_matplotlib_widget.cursor1 = None
            if self.iq_matplotlib_widget.cursor2 != None:
                self.iq_matplotlib_widget.cursor2.remove()
                self.iq_matplotlib_widget.cursor2 = None  
            if self.iq_matplotlib_widget.fill_rect != None:
                self.iq_matplotlib_widget.fill_rect.remove()
                self.iq_matplotlib_widget.fill_rect = None
            if self.iq_matplotlib_widget.txt != None:
                self.iq_matplotlib_widget.txt.remove()
                self.iq_matplotlib_widget.txt = None
            self.iq_matplotlib_widget.click = 1
            self.iq_matplotlib_widget.axes.figure.canvas.draw()
            self.iq_matplotlib_widget.cursor_enable = False        
        
    def _slotIQ_GetRangeClicked(self):
        """ Copies the cursor locations to the start and end edit boxes.
        """
        # Cursors Exist
        if self.iq_matplotlib_widget.cursor1 != None and self.iq_matplotlib_widget.cursor2 != None:
        
            # Get Scale
            get_xlabel = str(self.iq_matplotlib_widget.axes.xaxis.get_label())
            if "Samples/1000" in get_xlabel:
                get_scale = 1000
            elif "Samples/100" in get_xlabel:
                get_scale = 100
            elif "Samples/10" in get_xlabel:
                get_scale = 10
            else:
                get_scale = 1            
            
            # Get Cursor Locations
            get_start = str(get_scale * int(math.floor(self.iq_matplotlib_widget.cursor1.get_xdata())))
            get_end = str(get_scale * int(math.floor(self.iq_matplotlib_widget.cursor2.get_xdata())))
            
            # Update Text Edit Boxes
            self.textEdit_iq_start.setPlainText(str(int(get_start) + self.iq_plot_range_start))
            self.textEdit_iq_end.setPlainText(str(int(get_end) + self.iq_plot_range_start))
            
    def _slotIQ_OverlapStore1Clicked(self):
        """ Saves the current plot data for overlapping.
        """
        # Save Plot Data into a Variable
        if len(self.iq_matplotlib_widget.axes.lines) > 0:
            self.overlap_data1 = self.iq_matplotlib_widget.axes.lines[0].get_ydata()     
            self.label_iq_overlap_store1.setText("Stored")
            get_samples = str(len(self.iq_matplotlib_widget.axes.lines[0].get_ydata()))
            self.label_iq_overlap_samples1.setText(get_samples)
            
        # Enable Plot if Two Sources are Stored    
        if str(self.label_iq_overlap_samples1.text()) == "Stored" and str(self.label_iq_overlap_samples2.text()) == "Stored":
            self.pushButton_iq_overlap_plot.setEnabled(True)
        
    def _slotIQ_OverlapStore2Clicked(self):
        """ Saves the current plot data for overlapping.
        """
        # Save Plot Data into a Variable
        if len(self.iq_matplotlib_widget.axes.lines) > 0:
            self.overlap_data2 = self.iq_matplotlib_widget.axes.lines[0].get_ydata()     
            self.label_iq_overlap_store2.setText("Stored")
            get_samples = str(len(self.iq_matplotlib_widget.axes.lines[0].get_ydata()))
            self.label_iq_overlap_samples2.setText(get_samples)
            
        # Enable Plot if Two Sources are Stored    
        if str(self.label_iq_overlap_store1.text()) == "Stored" and str(self.label_iq_overlap_store2.text()) == "Stored":
            self.pushButton_iq_overlap_plot.setEnabled(True)
        
    def _slotIQ_OverlapPlotClicked(self):
        """ Plots the stored data for data1 and data2 on the same figure.
        """
        # Work with Temp. Values
        overlap_data1_plot = self.overlap_data1
        overlap_data2_plot = self.overlap_data2
        
        # Make Same Length
        if len(self.overlap_data1) > len(self.overlap_data2):
            sample_diff = len(self.overlap_data1) - len(self.overlap_data2)
            overlap_data2_plot = np.pad(self.overlap_data2,(0,sample_diff),'constant')             
        elif len(self.overlap_data2) > len(self.overlap_data1):
            sample_diff = len(self.overlap_data2) - len(self.overlap_data1)
            overlap_data1_plot = np.pad(self.overlap_data1,(0,sample_diff),'constant')
                        
        # Circular Shift - Data 1
        get_shift1 = self.spinBox_iq_overlap_offset1.value()
        overlap_data1_plot = np.roll(overlap_data1_plot, get_shift1)
        
        # Circular Shift - Data 2
        get_shift2 = self.spinBox_iq_overlap_offset2.value()
        overlap_data2_plot = np.roll(overlap_data2_plot, get_shift2)
        
        # Plot        
        self.iq_matplotlib_widget.clearPlot()
        self.iq_matplotlib_widget.configureAxes(polar=False)
        
        # Ignore hold() Deprecation Warnings
        with warnings.catch_warnings():
            warnings.simplefilter("ignore")
            warnings.filterwarnings("ignore", module="matplotlib")
            
            # Plot
            self.iq_matplotlib_widget.axes.plot(overlap_data1_plot,'b',linewidth=1,zorder=2)
            #self.iq_matplotlib_widget.axes.hold(True)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
            self.iq_matplotlib_widget.axes.plot(overlap_data2_plot,'r',linewidth=1,zorder=2)
            #self.iq_matplotlib_widget.axes.hold(False)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
            self.iq_matplotlib_widget.applyLabels("Data Overlap",'Samples','Amplitude (LSB)',None,None) 

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            
    def _slotIQ_OFDM_PlotSymbolCP_Clicked(self):
        """ Plots highlighted cyclic prefixes for all symbols.
        """
        # Get Data
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0 and ("Complex" in get_type):
            
            # Get the Number of Samples
            start_sample = 1
            num_samples = int(self.label_iq_samples.text().split(" ")[1])
        
            # Get the Size of Each Sample in Bytes   
            if get_type == "Complex Float 32":   
                sample_size = 4
            elif get_type == "Complex Int 16":
                sample_size = 2
            elif get_type == "Complex Int 8":
                sample_size = 1
            elif get_type == "Complex Float 64":
                sample_size = 8
            elif get_type == "Complex Int 64":
                sample_size = 8
            num_samples = 2 * num_samples               
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            #if get_type == "Complex Float 32":
            file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            #else:
            #    file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":   
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)
        
            # Resample
            get_sample_rate = float(self.textEdit_iq_ofdm_sample_rate.toPlainText())
            get_resample_rate = float(self.textEdit_iq_ofdm_resample_rate.toPlainText())
            num_resampled_samples = int(math.floor((get_resample_rate/get_sample_rate)*len(plot_data_formatted)/2))
            i_resampled = signal2.resample(plot_data_formatted[::2],num_resampled_samples)
            q_resampled = signal2.resample(plot_data_formatted[1::2],num_resampled_samples)
            
            # Get Message                
            get_trigger_level = float(self.textEdit_iq_ofdm_trigger_level.toPlainText())
            I_squared = [float(i)**2 for i in i_resampled]
            Q_squared = [float(q)**2 for q in q_resampled]
            AM = [math.sqrt(I_squared[x] + Q_squared[x]) for x in range(len(I_squared))]
            first_point = 1 
            for idx in range(0, len(AM)) : 
                if AM[idx] > get_trigger_level: 
                    first_point = idx
                    break
                                    
            # Get Symbol Size
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            get_cp_length = int(self.textEdit_iq_ofdm_cp_length.toPlainText())
            interval = (get_fft_size+get_cp_length)
            
            # Detect Number of Symbols
            num_sym = 0
            for n in range(first_point,len(AM)-interval,interval):
                if all(x < get_trigger_level for x in AM[n+int(math.floor(interval/10)):n+interval]):
                    break
                    
                # No End Found
                num_sym = num_sym + 1
            
            # Plot
            symbols_remaining = num_sym
            subs_per_page = 10
            for x in range(0,int(num_sym/subs_per_page) + 1):
                if symbols_remaining/subs_per_page > 0:
                    fig, axs = plt.subplots(subs_per_page)
                else:
                    fig, axs = plt.subplots(symbols_remaining)
                fig.suptitle('OFDM Cyclic Prefix: ' + str(x))
                for n in range(0,subs_per_page):                               
                    axs[n].plot(AM[first_point+n*interval:first_point+(n+1)*interval],'b',linewidth=1)
                    axs[n].fill_between(range(0,get_cp_length),AM[first_point+n*interval:first_point+n*interval+get_cp_length])
                    axs[n].fill_between(range(interval-get_cp_length,interval),AM[first_point+n*interval+get_fft_size:first_point+(n+1)*interval])
                    
                    # Reached End
                    symbols_remaining = symbols_remaining - 1
                    if symbols_remaining == 0:
                        break
                plt.show()
        
        # Create a Dialog Error Window 
        else:
            msgBox = MyMessageBox(my_text = "File must be loaded and have complex data type.")
            msgBox.exec_()    
            
    def _slotIQ_OFDM_MagnitudeClicked(self):
        """ Plots the magnitude and phase for a symbol in a message without subcarrier removal.
        """
        # Get Data
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0 and ("Complex" in get_type):
            
            # Get the Number of Samples
            start_sample = 1
            num_samples = int(self.label_iq_samples.text().split(" ")[1])
        
            # Get the Size of Each Sample in Bytes      
            if get_type == "Complex Float 32":   
                sample_size = 4
            elif get_type == "Complex Int 16":
                sample_size = 2
            elif get_type == "Complex Int 8":
                sample_size = 1
            elif get_type == "Complex Float 64":
                sample_size = 8
            elif get_type == "Complex Int 64":
                sample_size = 8
            num_samples = 2 * num_samples               
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            #if get_type == "Complex Float 32":
            file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            #else:
            #    file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":   
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)
        
            # Resample
            get_sample_rate = float(self.textEdit_iq_ofdm_sample_rate.toPlainText())
            get_resample_rate = float(self.textEdit_iq_ofdm_resample_rate.toPlainText())
            num_resampled_samples = int(math.floor((get_resample_rate/get_sample_rate)*len(plot_data_formatted)/2))
            i_resampled = signal2.resample(plot_data_formatted[::2],num_resampled_samples)
            q_resampled = signal2.resample(plot_data_formatted[1::2],num_resampled_samples)
            
            # Get Message                
            get_trigger_level = float(self.textEdit_iq_ofdm_trigger_level.toPlainText())
            I_squared = [float(i)**2 for i in i_resampled]
            Q_squared = [float(q)**2 for q in q_resampled]
            AM = [math.sqrt(I_squared[x] + Q_squared[x]) for x in range(len(I_squared))]
            first_point = 1 
            for idx in range(0, len(AM)) : 
                if AM[idx] > get_trigger_level: 
                    first_point = idx
                    break
                                    
            # Get Symbol Size
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            get_cp_length = int(self.textEdit_iq_ofdm_cp_length.toPlainText())
            interval = (get_fft_size+get_cp_length)
            
            # Detect Number of Symbols
            num_sym = 0
            for n in range(first_point,len(AM)-interval,interval):
                if all(x < get_trigger_level for x in AM[n+int(math.floor(interval/10)):n+interval]):
                    break
                    
                # No End Found
                num_sym = num_sym + 1
            
            # Symbol Out of Range
            get_symbol = int(self.spinBox_iq_ofdm_symbol.value())
            if get_symbol > num_sym:
                msgBox = MyMessageBox(my_text = "Symbol exceeds the number of symbols in the message.")
                msgBox.exec_() 
                return
            
            # Remove Cyclic Prefix
            i_symbol = np.array(i_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            q_symbol = np.array(q_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            
            # Combine the Data
            time_data = i_symbol + 1j*q_symbol
                       
            # Do FFT
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            fft_data = np.fft.fftshift(np.fft.fft(time_data,get_fft_size,norm='ortho'))
            self.fft_data = fft_data
                        
            # Phase
            get_adj = int(str(self.textEdit_iq_ofdm_phase_adjustment1.toPlainText()))
            fft_data_adj = []
            for x in range(0,len(fft_data)):
                fft_data_adj.append(np.exp(-1j*2*math.pi*(float(get_adj)/100000*x))*fft_data[x])
            #phase_data = np.angle(fft_data_adj)
            
            # Magnitude
            mag_data = abs(np.array(fft_data_adj))/max(abs(np.array(fft_data_adj)))
                        
            # Enable Buttons
            self.pushButton_iq_ofdm_cycle_adjustment.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_start.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_end.setEnabled(True)
            
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)
            self.iq_matplotlib_widget.axes.plot(mag_data,'b',linewidth=1,zorder=2) 
            self.iq_matplotlib_widget.applyLabels("OFDM Subcarriers",'Subcarriers','Amplitude (LSB)',None,None)

            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            
        # Create a Dialog Error Window 
        else:
            msgBox = MyMessageBox(my_text = "File must be loaded and have complex data type.")
            msgBox.exec_() 
    
    def _slotIQ_OFDM_CycleAdjustmentClicked(self):
        """ Cycles through phase adjustment values and plots updated phase.
        """
        # Do Phase Adjustments
        if not isinstance(self.fft_data,type(None)):

            # Get FFT Data
            fft_data = self.fft_data
                        
            # Make Plot
            plt.ion()
            fig = plt.figure()
            ax = fig.add_subplot(111)
            line1, = ax.plot(np.angle(fft_data),'b',linewidth=1)            
            plt.show()
            
            # Get FFT Data
            fft_data = self.fft_data
            
            # Update Adjustment
            get_start = int(str(self.textEdit_iq_ofdm_phase_adjustment_cycle_start.toPlainText()))
            get_end = int(str(self.textEdit_iq_ofdm_phase_adjustment_cycle_end.toPlainText()))
            for adj in range(get_start,get_end,2):
                self.textEdit_iq_ofdm_phase_adjustment_cycle.setPlainText(str(adj))
                phase_data = []
                for x in range(0,len(fft_data)):
                    phase_data.append(np.exp(-1j*2*math.pi*(float(adj)/100000*x))*fft_data[x])
                phase_data = np.angle(phase_data)
                
                # Plot
                #ax.clear()
                #ax.plot(phase_data,'b',linewidth=1)
                line1.set_ydata(phase_data)
                fig.canvas.draw()
                fig.canvas.flush_events()                
                fig.show()
                time.sleep(.1)
        
    def _slotIQ_OFDM_PhaseClicked(self):
        """ Plots the phase for all the subcarriers.
        """
        # Get Data
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0 and ("Complex" in get_type):
            
            # Get the Number of Samples
            start_sample = 1
            num_samples = int(self.label_iq_samples.text().split(" ")[1])
        
            # Get the Size of Each Sample in Bytes   
            if get_type == "Complex Float 32":   
                sample_size = 4
            elif get_type == "Complex Int 16":
                sample_size = 2
            elif get_type == "Complex Int 8":
                sample_size = 1
            elif get_type == "Complex Float 64":
                sample_size = 8
            elif get_type == "Complex Int 64":
                sample_size = 8
            num_samples = 2 * num_samples               
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            #if get_type == "Complex Float 32":
            file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            #else:
            #    file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":   
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)
        
            # Resample
            get_sample_rate = float(self.textEdit_iq_ofdm_sample_rate.toPlainText())
            get_resample_rate = float(self.textEdit_iq_ofdm_resample_rate.toPlainText())
            num_resampled_samples = int(math.floor((get_resample_rate/get_sample_rate)*len(plot_data_formatted)/2))
            i_resampled = signal2.resample(plot_data_formatted[::2],num_resampled_samples)
            q_resampled = signal2.resample(plot_data_formatted[1::2],num_resampled_samples)
            
            # Get Message                
            get_trigger_level = float(self.textEdit_iq_ofdm_trigger_level.toPlainText())
            I_squared = [float(i)**2 for i in i_resampled]
            Q_squared = [float(q)**2 for q in q_resampled]
            AM = [math.sqrt(I_squared[x] + Q_squared[x]) for x in range(len(I_squared))]
            first_point = 1 
            for idx in range(0, len(AM)) : 
                if AM[idx] > get_trigger_level: 
                    first_point = idx
                    break
                                    
            # Get Symbol Size
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            get_cp_length = int(self.textEdit_iq_ofdm_cp_length.toPlainText())
            interval = (get_fft_size+get_cp_length)
            
            # Detect Number of Symbols
            num_sym = 0
            for n in range(first_point,len(AM)-interval,interval):
                if all(x < get_trigger_level for x in AM[n+int(math.floor(interval/10)):n+interval]):
                    break
                    
                # No End Found
                num_sym = num_sym + 1
            
            # Symbol Out of Range
            get_symbol = int(self.spinBox_iq_ofdm_symbol.value())
            if get_symbol > num_sym:
                msgBox = MyMessageBox(my_text = "Symbol exceeds the number of symbols in the message.")
                msgBox.exec_() 
                return
            
            # Remove Cyclic Prefix
            i_symbol = np.array(i_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            q_symbol = np.array(q_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            
            # Combine the Data
            time_data = i_symbol + 1j*q_symbol
                       
            # Do FFT
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            fft_data = np.fft.fftshift(np.fft.fft(time_data,get_fft_size,norm='ortho'))
            self.fft_data = fft_data
            
            ## Magnitude
            #mag_data = abs(fft_data)/max(abs(fft_data))
            
            # Phase
            get_adj = int(str(self.textEdit_iq_ofdm_phase_adjustment1.toPlainText()))
            phase_data = []
            for x in range(0,len(fft_data)):
                phase_data.append(np.exp(-1j*2*math.pi*(float(get_adj)/100000*x))*fft_data[x])
            phase_data = np.angle(phase_data)
                        
            # Enable Buttons
            self.pushButton_iq_ofdm_cycle_adjustment.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_start.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_end.setEnabled(True)
            
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)            
            self.iq_matplotlib_widget.axes.plot(phase_data,'b',linewidth=1,zorder=2) 
            self.iq_matplotlib_widget.applyLabels("OFDM Subcarriers",'Subcarriers','Amplitude (LSB)',None,None)

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            
        # Create a Dialog Error Window 
        else:
            msgBox = MyMessageBox(my_text = "File must be loaded and have complex data type.")
            msgBox.exec_()         
        
    def _slotIQ_OFDM_PolarClicked(self):
        """ Polar plot (magnitude and phase) for all of the subcarriers.
        """
        # Get Data
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0 and ("Complex" in get_type):
            
            # Get the Number of Samples
            start_sample = 1
            num_samples = int(self.label_iq_samples.text().split(" ")[1])
        
            # Get the Size of Each Sample in Bytes      
            if get_type == "Complex Float 32":
                sample_size = 4
            elif get_type == "Complex Int 16":
                sample_size = 2
            elif get_type == "Complex Int 8":
                sample_size = 1
            elif get_type == "Complex Float 64":
                sample_size = 8
            elif get_type == "Complex Int 64":
                sample_size = 8
            num_samples = 2 * num_samples               
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            #if get_type == "Complex Float 32":
            file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            #else:
            #    file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)
        
            # Resample
            get_sample_rate = float(self.textEdit_iq_ofdm_sample_rate.toPlainText())
            get_resample_rate = float(self.textEdit_iq_ofdm_resample_rate.toPlainText())
            num_resampled_samples = int(math.floor((get_resample_rate/get_sample_rate)*len(plot_data_formatted)/2))
            i_resampled = signal2.resample(plot_data_formatted[::2],num_resampled_samples)
            q_resampled = signal2.resample(plot_data_formatted[1::2],num_resampled_samples)
            
            # Get Message                
            get_trigger_level = float(self.textEdit_iq_ofdm_trigger_level.toPlainText())
            I_squared = [float(i)**2 for i in i_resampled]
            Q_squared = [float(q)**2 for q in q_resampled]
            AM = [math.sqrt(I_squared[x] + Q_squared[x]) for x in range(len(I_squared))]
            first_point = 1 
            for idx in range(0, len(AM)) : 
                if AM[idx] > get_trigger_level: 
                    first_point = idx
                    break
                                    
            # Get Symbol Size
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            get_cp_length = int(self.textEdit_iq_ofdm_cp_length.toPlainText())
            interval = (get_fft_size+get_cp_length)
            
            # Detect Number of Symbols
            num_sym = 0
            for n in range(first_point,len(AM)-interval,interval):
                if all(x < get_trigger_level for x in AM[n+int(math.floor(interval/10)):n+interval]):
                    break
                    
                # No End Found
                num_sym = num_sym + 1
            
            # Symbol Out of Range
            get_symbol = int(self.spinBox_iq_ofdm_symbol.value())
            if get_symbol > num_sym:
                msgBox = MyMessageBox(my_text = "Symbol exceeds the number of symbols in the message.")
                msgBox.exec_() 
                return
            
            # Remove Cyclic Prefix
            i_symbol = np.array(i_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            q_symbol = np.array(q_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            
            # Combine the Data
            time_data = i_symbol + 1j*q_symbol
                       
            # Do FFT
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            fft_data = np.fft.fftshift(np.fft.fft(time_data,get_fft_size,norm='ortho'))
            self.fft_data = fft_data
            
            # Phase
            get_adj = int(str(self.textEdit_iq_ofdm_phase_adjustment1.toPlainText()))
            fft_adj = []
            for x in range(0,len(fft_data)):
                fft_adj.append(np.exp(-1j*2*math.pi*(float(get_adj)/100000*x))*fft_data[x])
            phase_data = np.angle(fft_adj)
            
            # Magnitude
            mag_data = abs(np.array(fft_adj))/max(abs(np.array(fft_adj)))
                        
            # Enable Buttons
            self.pushButton_iq_ofdm_cycle_adjustment.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_start.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_end.setEnabled(True)
            
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=True)
            self.iq_matplotlib_widget.axes.plot(phase_data,mag_data,'bo',markersize=4)
            self.iq_matplotlib_widget.applyLabels("OFDM Subcarriers",'Subcarriers','Amplitude (LSB)',None,None)

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            
        # Create a Dialog Error Window 
        else:
            msgBox = MyMessageBox(my_text = "File must be loaded and have complex data type.")
            msgBox.exec_() 
                    
    def _slotIQ_OFDM_SubcarrierAddClicked(self):
        """ Adds a new row to enter subcarrier ranges.
        """
        # Add an Empty, Editable Row
        item = QtWidgets.QListWidgetItem()
        item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
        self.listWidget_iq_ofdm_subcarriers.addItem(item)        
            
    def _slotIQ_OFDM_SubcarrierRemoveClicked(self):
        """ Removes a row of subcarrier ranges.
        """
        # Remove Items
        for item in self.listWidget_iq_ofdm_subcarriers.selectedItems():
            self.listWidget_iq_ofdm_subcarriers.takeItem(self.listWidget_iq_ofdm_subcarriers.row(item))
        
    def _slotIQ_OFDM_Magnitude2Clicked(self):
        """ Plots the magnitude of the data subcarriers.
        """
        # Get Data
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0 and ("Complex" in get_type):
            
            # Get the Number of Samples
            start_sample = 1
            num_samples = int(self.label_iq_samples.text().split(" ")[1])
        
            # Get the Size of Each Sample in Bytes      
            if get_type == "Complex Float 32":
                sample_size = 4
            elif get_type == "Complex Int 16":
                sample_size = 2
            elif get_type == "Complex Int 8":
                sample_size = 1
            elif get_type == "Complex Float 64":
                sample_size = 8
            elif get_type == "Complex Int 64":
                sample_size = 8
            num_samples = 2 * num_samples               
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            #if get_type == "Complex Float 32":
            file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            #else:
            #    file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":                
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)
        
            # Resample
            get_sample_rate = float(self.textEdit_iq_ofdm_sample_rate.toPlainText())
            get_resample_rate = float(self.textEdit_iq_ofdm_resample_rate.toPlainText())
            num_resampled_samples = int(math.floor((get_resample_rate/get_sample_rate)*len(plot_data_formatted)/2))
            i_resampled = signal2.resample(plot_data_formatted[::2],num_resampled_samples)
            q_resampled = signal2.resample(plot_data_formatted[1::2],num_resampled_samples)
            
            # Get Message                
            get_trigger_level = float(self.textEdit_iq_ofdm_trigger_level.toPlainText())
            I_squared = [float(i)**2 for i in i_resampled]
            Q_squared = [float(q)**2 for q in q_resampled]
            AM = [math.sqrt(I_squared[x] + Q_squared[x]) for x in range(len(I_squared))]
            first_point = 1 
            for idx in range(0, len(AM)) : 
                if AM[idx] > get_trigger_level: 
                    first_point = idx
                    break
                                    
            # Get Symbol Size
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            get_cp_length = int(self.textEdit_iq_ofdm_cp_length.toPlainText())
            interval = (get_fft_size+get_cp_length)
            
            # Detect Number of Symbols
            num_sym = 0
            for n in range(first_point,len(AM)-interval,interval):
                if all(x < get_trigger_level for x in AM[n+int(math.floor(interval/10)):n+interval]):
                    break
                    
                # No End Found
                num_sym = num_sym + 1
            
            # Symbol Out of Range
            get_symbol = int(self.spinBox_iq_ofdm_symbol.value())
            if get_symbol > num_sym:
                msgBox = MyMessageBox(my_text = "Symbol exceeds the number of symbols in the message.")
                msgBox.exec_() 
                return
            
            # Remove Cyclic Prefix
            i_symbol = np.array(i_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            q_symbol = np.array(q_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            
            # Combine the Data
            time_data = i_symbol + 1j*q_symbol
                       
            # Do FFT
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            fft_data_pre = np.fft.fftshift(np.fft.fft(time_data,get_fft_size,norm='ortho'))
                        
            # Keep Data Subcarriers
            get_data_subs = [] #range(75,511,3)  # [75:3:511,516:3:951];
            for row in range(0,self.listWidget_iq_ofdm_subcarriers.count()):
                get_data_subs.append(int(str(self.listWidget_iq_ofdm_subcarriers.item(row).text())))
            
            fft_data = np.array([fft_data_pre[i] for i in get_data_subs])
            self.fft_data = fft_data
                        
            # Phase
            get_adj = int(str(self.textEdit_iq_ofdm_phase_adjustment2.toPlainText()))
            fft_data_adj = []
            for x in range(0,len(fft_data)):
                fft_data_adj.append(np.exp(-1j*2*math.pi*(float(get_adj)/100000*x))*fft_data[x])
            #phase_data = np.angle(fft_data_adj)
            
            # Magnitude
            mag_data = abs(np.array(fft_data_adj))/max(abs(np.array(fft_data_adj)))
                        
            # Enable Buttons
            self.pushButton_iq_ofdm_cycle_adjustment2.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_start2.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_end2.setEnabled(True)
            
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)
            self.iq_matplotlib_widget.axes.plot(mag_data,'b',linewidth=1,zorder=2) 
            self.iq_matplotlib_widget.applyLabels("OFDM Subcarriers",'Subcarriers','Amplitude (LSB)',None,None)

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            
        # Create a Dialog Error Window 
        else:
            msgBox = MyMessageBox(my_text = "File must be loaded and have complex data type.")
            msgBox.exec_() 
        
    def _slotIQ_OFDM_Phase2Clicked(self):
        """ Plots the phase of the data subcarriers.
        """
        # Get Data
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0 and ("Complex" in get_type):
            
            # Get the Number of Samples
            start_sample = 1
            num_samples = int(self.label_iq_samples.text().split(" ")[1])
        
            # Get the Size of Each Sample in Bytes      
            if get_type == "Complex Float 32":
                sample_size = 4
            elif get_type == "Complex Int 16":
                sample_size = 2
            elif get_type == "Complex Int 8":
                sample_size = 1
            elif get_type == "Complex Float 64":
                sample_size = 8
            elif get_type == "Complex Int 64":
                sample_size = 8
            num_samples = 2 * num_samples               
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            #if get_type == "Complex Float 32":
            file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            #else:
            #    file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)
        
            # Resample
            get_sample_rate = float(self.textEdit_iq_ofdm_sample_rate.toPlainText())
            get_resample_rate = float(self.textEdit_iq_ofdm_resample_rate.toPlainText())
            num_resampled_samples = int(math.floor((get_resample_rate/get_sample_rate)*len(plot_data_formatted)/2))
            i_resampled = signal2.resample(plot_data_formatted[::2],num_resampled_samples)
            q_resampled = signal2.resample(plot_data_formatted[1::2],num_resampled_samples)
            
            # Get Message                
            get_trigger_level = float(self.textEdit_iq_ofdm_trigger_level.toPlainText())
            I_squared = [float(i)**2 for i in i_resampled]
            Q_squared = [float(q)**2 for q in q_resampled]
            AM = [math.sqrt(I_squared[x] + Q_squared[x]) for x in range(len(I_squared))]
            first_point = 1 
            for idx in range(0, len(AM)) : 
                if AM[idx] > get_trigger_level: 
                    first_point = idx
                    break
                                    
            # Get Symbol Size
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            get_cp_length = int(self.textEdit_iq_ofdm_cp_length.toPlainText())
            interval = (get_fft_size+get_cp_length)
            
            # Detect Number of Symbols
            num_sym = 0
            for n in range(first_point,len(AM)-interval,interval):
                if all(x < get_trigger_level for x in AM[n+int(math.floor(interval/10)):n+interval]):
                    break
                    
                # No End Found
                num_sym = num_sym + 1
            
            # Symbol Out of Range
            get_symbol = int(self.spinBox_iq_ofdm_symbol.value())
            if get_symbol > num_sym:
                msgBox = MyMessageBox(my_text = "Symbol exceeds the number of symbols in the message.")
                msgBox.exec_() 
                return
            
            # Remove Cyclic Prefix
            i_symbol = np.array(i_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            q_symbol = np.array(q_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            
            # Combine the Data
            time_data = i_symbol + 1j*q_symbol
                       
            # Do FFT
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            fft_data_pre = np.fft.fftshift(np.fft.fft(time_data,get_fft_size,norm='ortho'))
                        
            # Keep Data Subcarriers
            get_data_subs = [] #range(75,511,3)  # [75:3:511,516:3:951];
            for row in range(0,self.listWidget_iq_ofdm_subcarriers.count()):
                get_data_subs.append(int(str(self.listWidget_iq_ofdm_subcarriers.item(row).text())))
            
            fft_data = np.array([fft_data_pre[i] for i in get_data_subs])
            self.fft_data = fft_data
                        
            # Phase
            get_adj = int(str(self.textEdit_iq_ofdm_phase_adjustment2.toPlainText()))
            fft_data_adj = []
            for x in range(0,len(fft_data)):
                fft_data_adj.append(np.exp(-1j*2*math.pi*(float(get_adj)/100000*x))*fft_data[x])
            phase_data = np.angle(fft_data_adj)
            
            ## Magnitude
            #mag_data = abs(np.array(fft_data_adj))/max(abs(np.array(fft_data_adj)))
                        
            # Enable Buttons
            self.pushButton_iq_ofdm_cycle_adjustment2.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_start2.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_end2.setEnabled(True)
            
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)
            self.iq_matplotlib_widget.axes.plot(phase_data,'b',linewidth=1,zorder=2) 
            self.iq_matplotlib_widget.applyLabels("OFDM Subcarriers",'Subcarriers','Amplitude (LSB)',None,None)

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            
        # Create a Dialog Error Window 
        else:
            msgBox = MyMessageBox(my_text = "File must be loaded and have complex data type.")
            msgBox.exec_() 
        
    def _slotIQ_OFDM_Polar2Clicked(self):
        """ Polar plots the data subcarriers.
        """
        # Get Data
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0 and ("Complex" in get_type):
            
            # Get the Number of Samples
            start_sample = 1
            num_samples = int(self.label_iq_samples.text().split(" ")[1])
        
            # Get the Size of Each Sample in Bytes      
            if get_type == "Complex Float 32":
                sample_size = 4
            elif get_type == "Complex Int 16":
                sample_size = 2
            elif get_type == "Complex Int 8":
                sample_size = 1
            elif get_type == "Complex Float 64":
                sample_size = 8
            elif get_type == "Complex Int 64":
                sample_size = 8
            num_samples = 2 * num_samples               
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            #if get_type == "Complex Float 32":
            file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            #else:
            #    file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)
        
            # Resample
            get_sample_rate = float(self.textEdit_iq_ofdm_sample_rate.toPlainText())
            get_resample_rate = float(self.textEdit_iq_ofdm_resample_rate.toPlainText())
            num_resampled_samples = int(math.floor((get_resample_rate/get_sample_rate)*len(plot_data_formatted)/2))
            i_resampled = signal2.resample(plot_data_formatted[::2],num_resampled_samples)
            q_resampled = signal2.resample(plot_data_formatted[1::2],num_resampled_samples)
            
            # Get Message                
            get_trigger_level = float(self.textEdit_iq_ofdm_trigger_level.toPlainText())
            I_squared = [float(i)**2 for i in i_resampled]
            Q_squared = [float(q)**2 for q in q_resampled]
            AM = [math.sqrt(I_squared[x] + Q_squared[x]) for x in range(len(I_squared))]
            first_point = 1 
            for idx in range(0, len(AM)) : 
                if AM[idx] > get_trigger_level: 
                    first_point = idx
                    break
                                    
            # Get Symbol Size
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            get_cp_length = int(self.textEdit_iq_ofdm_cp_length.toPlainText())
            interval = (get_fft_size+get_cp_length)
            
            # Detect Number of Symbols
            num_sym = 0
            for n in range(first_point,len(AM)-interval,interval):
                if all(x < get_trigger_level for x in AM[n+int(math.floor(interval/10)):n+interval]):
                    break
                    
                # No End Found
                num_sym = num_sym + 1
            
            # Symbol Out of Range
            get_symbol = int(self.spinBox_iq_ofdm_symbol.value())
            if get_symbol > num_sym:
                msgBox = MyMessageBox(my_text = "Symbol exceeds the number of symbols in the message.")
                msgBox.exec_() 
                return
            
            # Remove Cyclic Prefix
            i_symbol = np.array(i_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            q_symbol = np.array(q_resampled[first_point+(get_symbol-1)*interval+get_cp_length:first_point+(get_symbol)*interval])
            
            # Combine the Data
            time_data = i_symbol + 1j*q_symbol
                       
            # Do FFT
            get_fft_size = int(self.textEdit_iq_ofdm_fft_size.toPlainText())
            fft_data_pre = np.fft.fftshift(np.fft.fft(time_data,get_fft_size,norm='ortho'))
                        
            # Keep Data Subcarriers
            get_data_subs = [] #range(75,511,3)  # [75:3:511,516:3:951];
            for row in range(0,self.listWidget_iq_ofdm_subcarriers.count()):
                get_data_subs.append(int(str(self.listWidget_iq_ofdm_subcarriers.item(row).text())))
            
            fft_data = np.array([fft_data_pre[i] for i in get_data_subs])
            self.fft_data = fft_data
                        
            # Phase
            get_adj = int(str(self.textEdit_iq_ofdm_phase_adjustment2.toPlainText()))
            fft_data_adj = []
            for x in range(0,len(fft_data)):
                fft_data_adj.append(np.exp(-1j*2*math.pi*(float(get_adj)/100000*x))*fft_data[x])
            phase_data = np.angle(fft_data_adj)
            
            # Magnitude
            mag_data = abs(np.array(fft_data_adj))/max(abs(np.array(fft_data_adj)))
                        
            # Enable Buttons
            self.pushButton_iq_ofdm_cycle_adjustment2.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_start2.setEnabled(True)
            self.textEdit_iq_ofdm_phase_adjustment_cycle_end2.setEnabled(True)
            
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=True)
            self.iq_matplotlib_widget.axes.plot(phase_data,mag_data,'bo',markersize=4)
            self.iq_matplotlib_widget.applyLabels("OFDM Subcarriers",'Subcarriers','Amplitude (LSB)',None,None)

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            
        # Create a Dialog Error Window 
        else:
            msgBox = MyMessageBox(my_text = "File must be loaded and have complex data type.")
            msgBox.exec_() 
        
    def _slotIQ_OFDM_SubcarrierClearClicked(self):
        """ Clears the list of data subcarriers.
        """
        self.listWidget_iq_ofdm_subcarriers.clear()
        
    def _slotIQ_OFDM_SubcarrierAddRangeClicked(self):
        """ Adds a range of subcarriers to the list.
        """
        # Get Range
        get_start = int(str(self.textEdit_iq_ofdm_subcarrier_start.toPlainText()))
        get_skip = int(str(self.textEdit_iq_ofdm_subcarrier_skip.toPlainText()))
        get_end = int(str(self.textEdit_iq_ofdm_subcarrier_end.toPlainText()))
        
        # Make List
        sub_list = range(get_start,get_end,get_skip)
        
        # Add to the List
        for i in sub_list:
            item = QtWidgets.QListWidgetItem(str(i))
            item.setFlags(item.flags() | QtCore.Qt.ItemIsEditable)
            self.listWidget_iq_ofdm_subcarriers.addItem(item) 
        
    def _slotIQ_OFDM_CycleAdjustment2Clicked(self):
        """ Cycles through phase adjustment values and plots updated phase for data subcarriers.
        """
        # Do Phase Adjustments
        if not isinstance(self.fft_data,type(None)):

            # Get FFT Data
            fft_data = self.fft_data
                        
            # Make Plot
            plt.ion()
            fig = plt.figure()
            ax = fig.add_subplot(111)
            line1, = ax.plot(np.angle(fft_data),'b',linewidth=1)            
            plt.show()
            
            # Get FFT Data
            fft_data = self.fft_data
            
            # Update Adjustment
            get_start = int(str(self.textEdit_iq_ofdm_phase_adjustment_cycle_start2.toPlainText()))
            get_end = int(str(self.textEdit_iq_ofdm_phase_adjustment_cycle_end2.toPlainText()))
            for adj in range(get_start,get_end,2):
                self.textEdit_iq_ofdm_phase_adjustment_cycle2.setPlainText(str(adj))
                phase_data = []
                for x in range(0,len(fft_data)):
                    phase_data.append(np.exp(-1j*2*math.pi*(float(adj)/100000*x))*fft_data[x])
                phase_data = np.angle(phase_data)
                
                # Plot
                #ax.clear()
                #ax.plot(phase_data,'b',linewidth=1)
                line1.set_ydata(phase_data)
                fig.canvas.draw()
                fig.canvas.flush_events()                
                fig.show()
                time.sleep(.1)   
                
    def _slotIQ_SpectrogramClicked(self):
        """ Plots a spectrogram of the loaded data.
        """
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0:
            
            # Get the Number of Samples
            try:
                start_sample = int(self.textEdit_iq_start.toPlainText())
                end_sample = int(self.textEdit_iq_end.toPlainText())
                num_samples = end_sample - start_sample + 1
            except:
                return
                            
            # Do Nothing if Bad Range
            if num_samples < 0:
                return
        
            # Get the Size of Each Sample in Bytes    
            complex_multiple = 1  
            if get_type == "Complex Float 32":
                complex_multiple = 2
                sample_size = 4
                num_samples = complex_multiple * num_samples               
            elif get_type == "Float/Float 32":
                sample_size = 4
            elif get_type == "Short/Int 16":
                sample_size = 2
            elif get_type == "Int/Int 32":
                sample_size = 4
            elif get_type == "Byte/Int 8":
                sample_size = 1
            elif get_type == "Complex Int 16":
                complex_multiple = 2
                sample_size = 2
                num_samples = complex_multiple * num_samples 
            elif get_type == "Complex Int 8":
                sample_size = 1
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
            elif get_type == "Complex Float 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
            elif get_type == "Complex Int 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
                
            # Check the Range
            if (num_samples*sample_size > number_of_bytes) or (complex_multiple*end_sample*sample_size > number_of_bytes) or (start_sample < 1):
                print("Out of range.")
                return
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            if "Complex" in get_type:
                file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            else:
                file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Float/Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Short/Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Int/Int 32":
                plot_data_formatted = struct.unpack(num_samples*'i', plot_data)
            elif get_type == "Byte/Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)                
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)                
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)                
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)                
                
            # Get I/Q Data
            if "Complex" in get_type:                
                I = [float(i) for i in plot_data_formatted[::2]]
                Q = [float(q) for q in plot_data_formatted[1::2]]
                complex_data = [complex(I[x],Q[x]) for x in range(len(I))]                                                
            else:
                complex_data = plot_data_formatted
                
            # Plot Spectrogram
            NFFT = 1024
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)            
            self.iq_matplotlib_widget.axes.specgram(complex_data, NFFT=NFFT, Fs=1, noverlap=900,zorder=2)
            self.iq_matplotlib_widget.applyLabels("Spectrogram",'Samples','Amplitude (LSB)',None,None) 

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            #self.iq_matplotlib_widget.draw()
            
        else:
            pass   
        
    def _slotIQ_FFT_Clicked(self):
        """ Plots an FFt of the loaded data.
        """
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0:
            
            # Get the Number of Samples
            try:
                start_sample = int(self.textEdit_iq_start.toPlainText())
                end_sample = int(self.textEdit_iq_end.toPlainText())
                num_samples = end_sample - start_sample + 1
            except: 
                return
                        
            # Do Nothing if Bad Range
            if num_samples < 0:
                return
        
            # Get the Size of Each Sample in Bytes     
            complex_multiple = 1 
            if get_type == "Complex Float 32":
                complex_multiple = 2
                sample_size = 4
                num_samples = complex_multiple * num_samples               
            elif get_type == "Float/Float 32":
                sample_size = 4
            elif get_type == "Short/Int 16":
                sample_size = 2
            elif get_type == "Int/Int 32":
                sample_size = 4
            elif get_type == "Byte/Int 8":
                sample_size = 1
            elif get_type == "Complex Int 16":
                complex_multiple = 2
                sample_size = 2
                num_samples = complex_multiple * num_samples   
            elif get_type == "Complex Float 64":
                complex_multiple = 2
                sample_size = 8
                num_samples = complex_multiple * num_samples   
            elif get_type == "Complex Int 64":
                complex_multiple = 2
                sample_size = 8
                num_samples = complex_multiple * num_samples   
                
            # Check the Range
            if (num_samples*sample_size > number_of_bytes) or (complex_multiple*end_sample*sample_size > number_of_bytes) or (start_sample < 1):
                print("Out of range.")
                return            
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            if "Complex" in get_type:
                file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            else:
                file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Float/Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Short/Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Int/Int 32":
                plot_data_formatted = struct.unpack(num_samples*'i', plot_data)
            elif get_type == "Byte/Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)                
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)                
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)                
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)                
                
            # Get I/Q Data
            if "Complex" in get_type:                
                I = [float(i) for i in plot_data_formatted[::2]]
                Q = [float(q) for q in plot_data_formatted[1::2]]
                complex_data = [complex(I[x],Q[x]) for x in range(len(I))]                                                
            else:
                complex_data = plot_data_formatted
                
            # Do FFT
            get_sample_rate = float(self.dashboard_settings_dictionary['fft_sample_rate'])
            get_fft_size = int(self.dashboard_settings_dictionary['fft_size'])
            fft_data = np.log10(np.abs(np.fft.fftshift(np.fft.fft(complex_data,get_fft_size,norm='ortho'))))
            #fft_data = fft_data/max(fft_data)
            freq = np.fft.fftshift(np.fft.fftfreq(len(fft_data),1/get_sample_rate))
            #freq = np.fft.fftfreq(len(fft_data),1/get_sample_rate)
            
            # Plot FFT
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)            
            self.iq_matplotlib_widget.axes.plot(freq,fft_data,'b',linewidth=1,zorder=2)
            self.iq_matplotlib_widget.applyLabels("4096-point FFT",'Frequency (Hz)','Amplitude (LSB)',None,None) 

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            #self.iq_matplotlib_widget.draw()
            
        else:
            pass   
            
    def _slotPacketScapyShowClicked(self):
        """ Calls the Scapy function '.show()' on a loaded packet.
        """
        # Show Loaded Data
        if self.scapy_data != None:            
            capture = StringIO()
            save_stdout = sys.stdout
            sys.stdout = capture
            self.scapy_data[0].show()
            sys.stdout = save_stdout
                        
            msgBox = MyMessageBox(my_text = capture.getvalue())
            msgBox.exec_() 

    def _slotPacketScapyLsClicked(self):
        """ Calls the Scapy function 'ls' on a loaded packet.
        """
        # Show Loaded Data
        if self.scapy_data != None:            
            capture = StringIO()
            save_stdout = sys.stdout
            sys.stdout = capture
            ls(self.scapy_data[0])
            sys.stdout = save_stdout
                        
            msgBox = MyMessageBox(my_text = capture.getvalue(), width=800, height=600)
            msgBox.exec_()
                    
    def _slotPacketScapyRefreshClicked(self):
        """ Refreshes the list of wireless interfaces available for Scapy injection.
        """
        # Update Interface Comboboxes
        get_interfaces = os.listdir("/sys/class/net/")
        self.comboBox_packet_scapy_interface.clear()
        for n in get_interfaces:
            self.comboBox_packet_scapy_interface.addItem(n)
       
        # Select the Last Interface by Default
        self.comboBox_packet_scapy_interface.setCurrentIndex(self.comboBox_packet_scapy_interface.count()-1)
        
    def _slotPacketScapyStartClicked(self):
        """ Runs the Scapy .sendp() command.
        """
        # Get Parameters
        get_iface = str(self.comboBox_packet_scapy_interface.currentText())
        get_interval = str(self.textEdit_packet_scapy_interval.toPlainText())
        if self.checkBox_packet_scapy_loop.isChecked():
            get_loop = "1"
        else:
            get_loop = "0"
        
        # Start Transmitting
        if len(get_iface) > 0:
            scapy_send_directory = os.path.dirname(os.path.abspath(__file__)) + "/Tools/"
            proc=subprocess.Popen("gnome-terminal -- sudo python2 scapy_send.py " + get_iface + " " + get_interval + " " + get_loop, cwd=scapy_send_directory, shell=True)
        else:
            msgBox = MyMessageBox(my_text = " Specify wireless interface.", width=200, height=100)
            msgBox.exec_()
        
    def _slotPacketScapyLoadClicked(self):
        """ Loads the information from the top half of the packet crafter and assembles a Scapy packet.
        """
        # Get Frame Type
        get_type = str(self.comboBox_packet_subcategory.currentText())
        
        # Convert Rows to Binary
        get_bin = []
        for n in range(0,self.tableWidget_attack_packet_editor.rowCount()):
            # Binary or Hex
            bin_str = ""
            current_selection = self.tableWidget_attack_packet_editor.cellWidget(n,0).currentText()
        
            # Contains Item
            if self.tableWidget_attack_packet_editor.item(n,1) != None:
                # Not Empty
                if str(self.tableWidget_attack_packet_editor.item(n,1).text()) != "":
                    # Get the Data      
                    get_data = str(self.tableWidget_attack_packet_editor.item(n,1).text())
                
                    if current_selection == "Binary":
                        bin_str = get_data.replace(' ', '')
                        
                    # Hex to Binary 
                    elif current_selection == "Hex":
                        hex_len = len(get_data)
                        bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                        
                    # Store Rows in List, Ignores Strings
                    if len(bin_str) > 0:
                        get_bin.append(bin_str) 
                        
        # Assemble
        if "Action" == get_type:
            get_dest_mac = '%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))
            get_dest_mac = get_dest_mac[0:2] + ":" + get_dest_mac[2:4] + ":" + get_dest_mac[4:6] + ":" + get_dest_mac[6:8] + ":" + get_dest_mac[8:10] + ":" + get_dest_mac[10:12]
            get_source_mac = '%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))
            get_source_mac = get_source_mac[0:2] + ":" + get_source_mac[2:4] + ":" + get_source_mac[4:6] + ":" + get_source_mac[6:8] + ":" + get_source_mac[8:10] + ":" + get_source_mac[10:12]
            get_bssid_mac = '%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))
            get_bssid_mac = get_bssid_mac[0:2] + ":" + get_bssid_mac[2:4] + ":" + get_bssid_mac[4:6] + ":" + get_bssid_mac[6:8] + ":" + get_bssid_mac[8:10] + ":" + get_bssid_mac[10:12]
            get_category = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[3]) + 3) // 4, int(get_bin[3], 2))))
            get_action = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[4]) + 3) // 4, int(get_bin[4], 2))))
            get_element = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[5]) + 3) // 4, int(get_bin[5], 2))))
            self.scapy_data = RadioTap()/Dot11(type=0, subtype=13, addr1=get_dest_mac, addr2=get_source_mac, addr3=get_bssid_mac)/get_category/get_action/get_element
            
        elif "CTS" == get_type:
            get_recv_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))))
            get_type_subtype = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))))
            get_duration = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))))
            self.scapy_data = RadioTap()/get_type_subtype/get_duration/get_recv_mac
            
        elif "Deauthentication" == get_type:
            get_target_mac = '%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))
            get_target_mac = get_target_mac[0:2] + ":" + get_target_mac[2:4] + ":" + get_target_mac[4:6] + ":" + get_target_mac[6:8] + ":" + get_target_mac[8:10] + ":" + get_target_mac[10:12]
            get_ap_mac = '%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))
            get_ap_mac = get_ap_mac[0:2] + ":" + get_ap_mac[2:4] + ":" + get_ap_mac[4:6] + ":" + get_ap_mac[6:8] + ":" + get_ap_mac[8:10] + ":" + get_ap_mac[10:12]
            self.scapy_data = RadioTap()/Dot11(type=0, subtype=12, addr1=get_target_mac, addr2=get_ap_mac, addr3=get_ap_mac)/Dot11Deauth(reason=7)

        elif "Null" == get_type:
            get_dest_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))))
            get_source_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))))
            get_bssid_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))))
            get_type_subtype = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[3]) + 3) // 4, int(get_bin[3], 2))))
            get_flags = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[4]) + 3) // 4, int(get_bin[4], 2))))
            get_duration = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[5]) + 3) // 4, int(get_bin[5], 2))))
            get_fragment_sequence = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[6]) + 3) // 4, int(get_bin[6], 2))))
            self.scapy_data = RadioTap()/get_type_subtype/get_flags/get_duration/get_dest_mac/get_source_mac/get_bssid_mac/get_fragment_sequence
            
        elif "Probe Request" == get_type:
            get_source_mac = '%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))
            get_source_mac = get_source_mac[0:2] + ":" + get_source_mac[2:4] + ":" + get_source_mac[4:6] + ":" + get_source_mac[6:8] + ":" + get_source_mac[8:10] + ":" + get_source_mac[10:12]
            get_target_mac = '%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))
            get_target_mac = get_target_mac[0:2] + ":" + get_target_mac[2:4] + ":" + get_target_mac[4:6] + ":" + get_target_mac[6:8] + ":" + get_target_mac[8:10] + ":" + get_target_mac[10:12]
            self.scapy_data = RadioTap()/Dot11(type=0, subtype=4, addr1=get_target_mac, addr2=get_source_mac)/Dot11ProbeReq("00" * 1)
            #self.scapy_data = RadioTap()/Dot11(type=0, subtype=0100, addr2=get_target_mac)/Dot11ProbeReq("00" * 1)  # "subtype" doesn't register in this format
            
        elif "RTS" == get_type:
            get_recv_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))))
            get_tx_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))))
            get_type_subtype = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))))
            get_duration = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[3]) + 3) // 4, int(get_bin[3], 2))))
            self.scapy_data = RadioTap()/get_type_subtype/get_duration/get_recv_mac/get_tx_mac
            
        elif "UDP from AP" == get_type:
            get_addr1_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))))
            get_addr2_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))))
            #get_addr3_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))))
            get_type_subtype = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))))
            get_flags = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[3]) + 3) // 4, int(get_bin[3], 2))))
            get_duration = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[4]) + 3) // 4, int(get_bin[4], 2))))
            get_fragment_sequence = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[5]) + 3) // 4, int(get_bin[5], 2))))
            get_udp_source_ip = str(self.tableWidget_attack_packet_editor.item(6,1).text())
            get_udp_dest_ip = str(self.tableWidget_attack_packet_editor.item(7,1).text())
            get_udp_source_port = str(self.tableWidget_attack_packet_editor.item(8,1).text())
            get_udp_dest_port = str(self.tableWidget_attack_packet_editor.item(9,1).text())
            get_udp_data = str(self.tableWidget_attack_packet_editor.item(10,1).text())
            
            # Convert Hex to Hexstring Format ('00FF' --> '\x00\xFF')
            get_udp_data = bytes(get_udp_data, encoding='utf-8')
            
            llc_bytes = LLC()/SNAP()
            
            udp_bytes = IP()/UDP()
            udp_bytes[IP].src = get_udp_source_ip
            udp_bytes[IP].dst = get_udp_dest_ip
            udp_bytes[UDP].sport = int(get_udp_source_port)
            udp_bytes[UDP].dport = int(get_udp_dest_port)
            
            # Flag DS bits: 01 (From Ap), Addr1=Destination STA, Addr2=BSSID, Addr3=Source STA
            self.scapy_data = RadioTap()/get_type_subtype/get_flags/get_duration/get_addr2_mac/get_addr1_mac/get_addr1_mac/get_fragment_sequence/llc_bytes/udp_bytes/get_udp_data

        elif "UDP to AP" == get_type:
            get_addr1_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))))
            get_addr2_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))))
            get_addr3_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))))
            get_type_subtype = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[3]) + 3) // 4, int(get_bin[3], 2))))
            get_flags = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[4]) + 3) // 4, int(get_bin[4], 2))))
            get_duration = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[5]) + 3) // 4, int(get_bin[5], 2))))
            get_fragment_sequence = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[6]) + 3) // 4, int(get_bin[6], 2))))
            get_udp_source_ip = str(self.tableWidget_attack_packet_editor.item(7,1).text())
            get_udp_dest_ip = str(self.tableWidget_attack_packet_editor.item(8,1).text())
            get_udp_source_port = str(self.tableWidget_attack_packet_editor.item(9,1).text())
            get_udp_dest_port = str(self.tableWidget_attack_packet_editor.item(10,1).text())
            get_udp_data = str(self.tableWidget_attack_packet_editor.item(11,1).text())
            
            # Convert Hex to Hexstring Format ('00FF' --> '\x00\xFF')
            get_udp_data = bytes(get_udp_data, encoding='utf-8')
            
            llc_bytes = LLC()/SNAP()
            
            udp_bytes = IP()/UDP()
            udp_bytes[IP].src = get_udp_source_ip
            udp_bytes[IP].dst = get_udp_dest_ip
            udp_bytes[UDP].sport = int(get_udp_source_port)
            udp_bytes[UDP].dport = int(get_udp_dest_port)
            
            # Flag DS bits: 01 (From Ap), Addr1=Destination STA, Addr2=BSSID, Addr3=Source STA
            self.scapy_data = RadioTap()/get_type_subtype/get_flags/get_duration/get_addr1_mac/get_addr2_mac/get_addr3_mac/get_fragment_sequence/llc_bytes/udp_bytes/get_udp_data            
            #print(self.scapy_data[0].show())
            
        elif "ARP Response - Wifi" == get_type:
            get_addr1_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))))
            get_addr2_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))))
            get_addr3_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))))
            get_type_subtype = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[3]) + 3) // 4, int(get_bin[3], 2))))
            get_flags = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[4]) + 3) // 4, int(get_bin[4], 2))))
            get_duration = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[5]) + 3) // 4, int(get_bin[5], 2))))
            get_fragment_sequence = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[6]) + 3) // 4, int(get_bin[6], 2))))
            
            get_hwtype = str(self.tableWidget_attack_packet_editor.item(7,1).text())
            get_ptype = str(self.tableWidget_attack_packet_editor.item(8,1).text())
            get_hwlen = str(self.tableWidget_attack_packet_editor.item(9,1).text())
            get_plen = str(self.tableWidget_attack_packet_editor.item(10,1).text())
            get_op = str(self.tableWidget_attack_packet_editor.item(11,1).text())
            get_hwsrc = str(self.tableWidget_attack_packet_editor.item(12,1).text())
            get_psrc = str(self.tableWidget_attack_packet_editor.item(13,1).text())
            get_hwdst = str(self.tableWidget_attack_packet_editor.item(14,1).text())
            get_pdst = str(self.tableWidget_attack_packet_editor.item(15,1).text())
                        
            arp_bytes = ARP()
            arp_bytes[ARP].hwtype = int(get_hwtype) & 0xFF
            arp_bytes[ARP].ptype = int(get_ptype) & 0xFFF
            arp_bytes[ARP].hwlen = int(get_hwlen)
            arp_bytes[ARP].plen = int(get_plen)
            arp_bytes[ARP].op = int(get_op)
            arp_bytes[ARP].hwsrc = get_hwsrc
            arp_bytes[ARP].psrc = get_psrc
            arp_bytes[ARP].hwdst = get_hwdst
            arp_bytes[ARP].pdst = get_pdst
            
            self.scapy_data = RadioTap()/get_type_subtype/get_flags/get_duration/get_addr3_mac/get_addr1_mac/get_addr2_mac/get_fragment_sequence/LLC()/SNAP()/arp_bytes
            
        elif "ARP Response - Ethernet" == get_type:
            get_hwtype = str(self.tableWidget_attack_packet_editor.item(0,1).text())
            get_ptype = str(self.tableWidget_attack_packet_editor.item(1,1).text())
            get_hwlen = str(self.tableWidget_attack_packet_editor.item(2,1).text())
            get_plen = str(self.tableWidget_attack_packet_editor.item(3,1).text())
            get_op = str(self.tableWidget_attack_packet_editor.item(4,1).text())
            get_hwsrc = str(self.tableWidget_attack_packet_editor.item(5,1).text())
            get_psrc = str(self.tableWidget_attack_packet_editor.item(6,1).text())
            get_hwdst = str(self.tableWidget_attack_packet_editor.item(7,1).text())
            get_pdst = str(self.tableWidget_attack_packet_editor.item(8,1).text())
            
            arp_bytes = ARP()
            arp_bytes[ARP].hwtype = int(get_hwtype) & 0xFF
            arp_bytes[ARP].ptype = int(get_ptype) & 0xFFF
            arp_bytes[ARP].hwlen = int(get_hwlen)
            arp_bytes[ARP].plen = int(get_plen)
            arp_bytes[ARP].op = int(get_op)
            arp_bytes[ARP].hwsrc = get_hwsrc
            arp_bytes[ARP].psrc = get_psrc
            arp_bytes[ARP].hwdst = get_hwdst
            arp_bytes[ARP].pdst = get_pdst
            
            self.scapy_data = Ether()/arp_bytes      
            
        elif "ICMP" == get_type:
            get_source_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))))
            get_dest_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))))
            get_bssid_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))))
            get_source_ip = str(self.tableWidget_attack_packet_editor.item(3,1).text())
            get_dest_ip = str(self.tableWidget_attack_packet_editor.item(4,1).text())
            get_icmp_type = int(get_bin[3], 2)
            get_icmp_code = int(get_bin[4], 2)
            get_icmp_id = int(get_bin[5], 2)
            get_icmp_seq = int(get_bin[6], 2)
            
            scapy_bytes = RadioTap()/Dot11()/LLC()/SNAP()/IP()/ICMP()
            scapy_bytes[Dot11].addr1 = get_dest_mac
            scapy_bytes[Dot11].addr2 = get_source_mac
            scapy_bytes[Dot11].addr3 = get_bssid_mac
            scapy_bytes[Dot11].type = 2
            scapy_bytes[Dot11].subtype = 0
            scapy_bytes[IP].src = get_source_ip
            scapy_bytes[IP].dst = get_dest_ip
            scapy_bytes[ICMP].type = get_icmp_type
            scapy_bytes[ICMP].code = get_icmp_code
            scapy_bytes[ICMP].id = get_icmp_id
            scapy_bytes[ICMP].seq = get_icmp_seq
           
            self.scapy_data = scapy_bytes
            
        elif "UDP to AP QoS" == get_type:
            get_addr1_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[0]) + 3) // 4, int(get_bin[0], 2))))
            get_addr2_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[1]) + 3) // 4, int(get_bin[1], 2))))
            get_addr3_mac = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[2]) + 3) // 4, int(get_bin[2], 2))))
            get_type_subtype = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[3]) + 3) // 4, int(get_bin[3], 2))))
            get_flags = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[4]) + 3) // 4, int(get_bin[4], 2))))
            get_duration = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[5]) + 3) // 4, int(get_bin[5], 2))))
            get_fragment_sequence = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[6]) + 3) // 4, int(get_bin[6], 2))))
            get_qos_control = binascii.unhexlify(''.join('%0*X' % ((len(get_bin[7]) + 3) // 4, int(get_bin[7], 2))))
            get_udp_source_ip = str(self.tableWidget_attack_packet_editor.item(8,1).text())
            get_udp_dest_ip = str(self.tableWidget_attack_packet_editor.item(9,1).text())
            get_udp_source_port = str(self.tableWidget_attack_packet_editor.item(10,1).text())
            get_udp_dest_port = str(self.tableWidget_attack_packet_editor.item(11,1).text())
            get_udp_data = str(self.tableWidget_attack_packet_editor.item(12,1).text())
            
            # Convert Hex to Hexstring Format ('00FF' --> '\x00\xFF')
            get_udp_data = bytes(get_udp_data, encoding='utf-8')
            
            llc_bytes = LLC()/SNAP()
            
            udp_bytes = IP()/UDP()
            udp_bytes[IP].src = get_udp_source_ip
            udp_bytes[IP].dst = get_udp_dest_ip
            udp_bytes[UDP].sport = int(get_udp_source_port)
            udp_bytes[UDP].dport = int(get_udp_dest_port)
            
            # Flag DS bits: 01 (From Ap), Addr1=Destination STA, Addr2=BSSID, Addr3=Source STA
            self.scapy_data = RadioTap()/get_type_subtype/get_flags/get_duration/get_addr1_mac/get_addr2_mac/get_addr3_mac/get_fragment_sequence/get_qos_control/llc_bytes/udp_bytes/get_udp_data            
            #print(self.scapy_data[0].show())
                  
            

        # Set Loaded Text
        self.label_packet_scapy_loaded.setText(get_type)
        
        # Enable Controls
        self.label_packet_scapy_view.setEnabled(True)
        self.pushButton_packet_scapy_show.setEnabled(True)
        self.pushButton_packet_scapy_ls.setEnabled(True)
        self.label_packet_scapy_interval.setEnabled(True)
        self.textEdit_packet_scapy_interval.setEnabled(True)
        self.label_packet_scapy_interface.setEnabled(True)
        self.comboBox_packet_scapy_interface.setEnabled(True)
        self.pushButton_packet_scapy_refresh.setEnabled(True)
        self.checkBox_packet_scapy_loop.setEnabled(True)
        self.pushButton_packet_scapy_start.setEnabled(True)
        
        # Write to PCAP
        wrpcap(os.path.dirname(os.path.abspath(__file__)) + "/Crafted Packets/Scapy/temp.cap", self.scapy_data)

    def _slotIQ_PlaybackClicked(self):
        """ Starts/Stops a flow graph with a file source. Replays loaded file data.
        """
        # Play
        if self.pushButton_iq_playback.text() == "Play":
            try:
                # Get the Values from the Table
                get_frequency = str(self.tableWidget_iq_playback.item(0,0).text())
                get_channel = str(self.tableWidget_iq_playback.cellWidget(0,1).currentText())
                get_antenna = str(self.tableWidget_iq_playback.cellWidget(0,2).currentText())
                get_gain = str(self.tableWidget_iq_playback.item(0,3).text())
                get_sample_rate = str(self.tableWidget_iq_playback.item(0,4).text()) 
                get_data_type = str(self.tableWidget_iq_playback.cellWidget(0,5).currentText())   
                get_repeat = str(self.tableWidget_iq_playback.cellWidget(0,6).currentText()) 
                get_filepath = str(self.textEdit_iq_playback_filepath.toPlainText())
                
                # Validate Inputs
                float(get_frequency)
                float(get_gain)
                float(get_sample_rate)                
                valid_freq = self.checkFrequencyBounds(float(get_frequency), self.dashboard_settings_dictionary['hardware_iq'], self.dashboard_settings_dictionary['hardware_daughterboard_iq'])
                if valid_freq == False:
                    print("Frequency outside of hardware bounds.")
                    return   
            except:
                print("Invalid input parameter")
                return
            
            # Get Flow Graph from Hardware
            if self.dashboard_settings_dictionary['hardware_iq'] == "Computer":
                fname = "iq_playback"  # Do not allow            
            elif self.dashboard_settings_dictionary['hardware_iq'] == "USRP X310":                
                if get_repeat == "No":
                    fname = "iq_playback_single_x310"
                else:
                    fname = "iq_playback_x310"                 
            elif self.dashboard_settings_dictionary['hardware_iq'] == "USRP B210":
                if get_repeat == "No":
                    fname = "iq_playback_single_b210"
                else:
                    fname = "iq_playback_b210"
            elif self.dashboard_settings_dictionary['hardware_iq'] == "HackRF":
                if get_repeat == "No":
                    fname = "iq_playback_single_hackrf"
                else:
                    fname = "iq_playback_hackrf"                
            elif self.dashboard_settings_dictionary['hardware_iq'] == "RTL2832U":
                fname = "iq_playback"  # Do not allow
            elif self.dashboard_settings_dictionary['hardware_iq'] == "802.11x Adapter":
                fname = "iq_playback"  # Do not allow
            elif self.dashboard_settings_dictionary['hardware_iq'] == "USRP B205mini":
                if get_repeat == "No":
                    fname = "iq_playback_single_b210"
                else:
                    fname = "iq_playback_b210"    
            elif self.dashboard_settings_dictionary['hardware_iq'] == "LimeSDR":
                if get_repeat == "No":
                    fname = "iq_playback_single_limesdr"
                else:
                    fname = "iq_playback_limesdr"                
            elif self.dashboard_settings_dictionary['hardware_iq'] == "bladeRF":
                if get_repeat == "No":
                    fname = "iq_playback_single_bladerf"
                else:
                    fname = "iq_playback_bladerf"
            elif self.dashboard_settings_dictionary['hardware_iq'] == "Open Sniffer":
                fname = "iq_playback"  # Do not allow                    
            
            # LimeSDR Channel
            if self.dashboard_settings_dictionary['hardware_iq'] == "LimeSDR":
                if get_channel == "A":
                    get_channel = "0"
                elif get_channel == "B":
                    get_channel = "1"
                            
            # Hardware Serial
            if len(self.dashboard_settings_dictionary['hardware_serial_iq']) > 0:
                if self.dashboard_settings_dictionary['hardware_iq'] == "HackRF":
                    get_serial = self.dashboard_settings_dictionary['hardware_serial_iq']
                else:
                    get_serial = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_iq']                               
            else:
                if self.dashboard_settings_dictionary['hardware_iq'] == "HackRF":
                    get_serial = ""
                else:
                    get_serial = "False"  
            
            # Put them in a List
            variable_names = ['filepath','ip_address','tx_channel','tx_frequency','sample_rate','tx_gain','tx_antenna','serial']
            variable_values = [get_filepath,self.dashboard_settings_dictionary['hardware_ip_iq'],get_channel,get_frequency,get_sample_rate,get_gain,get_antenna,get_serial]           
                
            # Send the Parameters to TSI
                #If no errors entering parameters...
            get_file_type = "Flow Graph"
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Run IQ Flow Graph', Parameters = [str(fname), variable_names, variable_values, get_file_type])
            
            # Change Status Label and Record Button Text
            self.label_iq_playback_status.setText("Starting...")
            self.pushButton_iq_playback.setText("Stop")
            self.pushButton_iq_playback.setEnabled(False)
            self.status_dialog.tableWidget_status_results.item(4,0).setText('Starting...')
            
        # Stop Playing
        elif self.pushButton_iq_playback.text() == "Stop":            
            # Send Message to TSI/HIPRFISR
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop IQ Flow Graph', Parameters = ['']) 
            
    def _slotIQ_ResampleClicked(self):
        """ Resamples a data file to a new rate.
        """
        # Get Values
        get_original_file = str(self.textEdit_iq_resample_original_file.toPlainText())
        get_new_file = str(self.textEdit_iq_resample_new_file.toPlainText())
        get_original_rate = float(self.textEdit_iq_resample_original_rate.toPlainText())
        get_new_rate = float(self.textEdit_iq_resample_new_rate.toPlainText())
        get_data_type = str(self.comboBox_iq_crop_data_type.currentText())

        # Files Selected
        if (len(get_original_file) > 0) and (len(get_new_file) > 0) and (get_original_rate > 0) and (get_new_rate > 0):
            # Read the Data 
            file = open(get_original_file,"rb")                    
            plot_data = file.read() 
            file.close()                
                    
            # Complex Float 32
            if get_data_type == "Complex Float 32":
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'f', plot_data)     
            
                # Resample
                num_resampled_samples = int(math.floor((get_new_rate/get_original_rate)*len(plot_data_formatted)/2))
                print(num_resampled_samples)
                i_resampled = np.array(signal2.resample(plot_data_formatted[::2],num_resampled_samples), dtype=np.float32)
                q_resampled = np.array(signal2.resample(plot_data_formatted[1::2],num_resampled_samples), dtype=np.float32)
                new_data = np.empty((i_resampled.size + q_resampled.size,), dtype=np.float32)
                new_data[0::2] = i_resampled
                new_data[1::2] = q_resampled     
                new_data.tofile(get_new_file)         

            # Complex Int 16                    
            elif get_data_type == "Complex Int 16":     
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/2)*'h', plot_data)     
            
                # Resample
                num_resampled_samples = int(math.floor((get_new_rate/get_original_rate)*len(plot_data_formatted)/2))
                print(num_resampled_samples)
                i_resampled = np.array(signal2.resample(plot_data_formatted[::2],num_resampled_samples), dtype=np.int16)
                q_resampled = np.array(signal2.resample(plot_data_formatted[1::2],num_resampled_samples), dtype=np.int16)
                new_data = np.empty((i_resampled.size + q_resampled.size,), dtype=np.int16)
                new_data[0::2] = i_resampled
                new_data[1::2] = q_resampled     
                #new_data = i_resampled + 1j*q_resampled  # Converts np.int16 to complex64            
                new_data.tofile(get_new_file)                      

            # Complex Float 64                   
            elif get_data_type == "Complex Float 64":     
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'d', plot_data)     
            
                # Resample
                num_resampled_samples = int(math.floor((get_new_rate/get_original_rate)*len(plot_data_formatted)/2))
                print(num_resampled_samples)
                i_resampled = np.array(signal2.resample(plot_data_formatted[::2],num_resampled_samples), dtype=np.float64)
                q_resampled = np.array(signal2.resample(plot_data_formatted[1::2],num_resampled_samples), dtype=np.float64)
                new_data = np.empty((i_resampled.size + q_resampled.size,), dtype=np.float64)
                new_data[0::2] = i_resampled
                new_data[1::2] = q_resampled     
                new_data.tofile(get_new_file)                      

            # Complex Int 64                   
            elif get_data_type == "Complex Int 64":     
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'l', plot_data)     
            
                # Resample
                num_resampled_samples = int(math.floor((get_new_rate/get_original_rate)*len(plot_data_formatted)/2))
                print(num_resampled_samples)
                i_resampled = np.array(signal2.resample(plot_data_formatted[::2],num_resampled_samples), dtype=np.float64)
                q_resampled = np.array(signal2.resample(plot_data_formatted[1::2],num_resampled_samples), dtype=np.float64)
                new_data = np.empty((i_resampled.size + q_resampled.size,), dtype=np.int64)
                new_data[0::2] = i_resampled
                new_data[1::2] = q_resampled     
                new_data.tofile(get_new_file)                      

            # Unknown
            else:
                self.errorMessage("Cannot resample " + get_data_type + ".")
                return

            print(len(new_data))
                    
            # Refresh Listbox
            self._slotIQ_RefreshClicked()
            


    def _slotMenuLoadBladeRF_FPGA_Clicked(self):
        """ Loads the FPGA image for bladeRF. Sometimes required after plugging in.
        """
        # Select FPGA Image File (.rbf)
        dialog = QtWidgets.QFileDialog(self)
        directory = '/usr/share/Nuand/bladeRF'  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['FPGA Image (*.rbf)'])
        get_file = None
        if dialog.exec_():
            for d in dialog.selectedFiles():
                get_file = d

        # Issue Load Command
        if get_file != None:
            try:
                command_text = 'gnome-terminal -- bladeRF-cli -l ' + str(get_file) + ' &'
                proc = subprocess.Popen(command_text, shell=True)            
            except:
                print("Error Loading FPGA Image")
            
    def _slotMenuGSM_UplinkDownlinkClicked(self):
        """ Opens GRC with standalone flow graph.
        """           
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/gsm_uplink_downlink.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")    
        
    def _slotMenuJ2497_DemodMethod1Clicked(self):
        """ Opens GRC with standalone flow graph.
        """           
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/j2497_demod_method1.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")          
        
    def _slotMenuWifiRxClicked(self):
        """ Opens GRC with standalone flow graph.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/wifi_rx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")     
        
    def _slotMenuWifiTxClicked(self):
        """ Opens GRC with standalone flow graph.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/wifi_tx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")    
        
    def _slotMenuRdsRxClicked(self):
        """ Opens GRC with standalone flow graph.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/rds_rx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")            
        
    def _slotMenuRdsTxClicked(self):
        """ Opens GRC with standalone flow graph.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/rds_tx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")           
        
    def _slotMenuRdsRx2Clicked(self):
        """ Open gr-rds rds_rx.grc GUI for RTL2832U.
        """
        # Opens the rdx_rx without Opening GRC
        osCommandString = "grcc " + os.path.dirname(os.path.realpath(__file__)) + "/Custom_Blocks/maint-3.8/gr-rds-maint-3.8/examples/rds_rx.grc -o " + os.path.dirname(os.path.realpath(__file__)) + "/Custom_Blocks/maint-3.8/gr-rds-maint-3.8/examples/ -r"
        os.system(osCommandString+ " &")     
                              
    def _slotMenuSrsLTE_Clicked(self):
        """ Opens the terminals with locations for manually running srsLTE programs.
        """
        # srsepc, srsenb
        srsLTE_dir = os.path.expanduser("~/Installed_by_FISSURE/srsRAN/srsepc")
                
        # Two Terminals
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script"      
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo srsepc ~/.config/srsran/epc.conf"', cwd=srsLTE_dir, shell=True)                
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo srsenb ~/.config/srsran/enb.conf"', cwd=srsLTE_dir, shell=True)
                
        # # Two Tabs
        # proc=subprocess.Popen('gnome-terminal --window --working-directory="' + srsLTE_dir + '" ' + \
            # '--tab --working-directory="' + srsLTE_dir + '" ', \
            # cwd=srsLTE_dir, shell=True)     
            
    def _slotIQ_FolderClicked(self):
        """ Chooses a new folder containing IQ recordings to view in the listbox.
        """
        # Choose Folder
        get_pwd = str(self.comboBox_iq_folders.currentText())
        get_dir = str(QtWidgets.QFileDialog.getExistingDirectory(self, "Select Directory",get_pwd))
        
        # Add Directory to the Combobox       
        if len(get_dir) > 0:   
                
            # Load Directory and File
            folder_index = self.comboBox_iq_folders.findText(get_dir)
            if folder_index < 0:
                # New Directory
                self.comboBox_iq_folders.addItem(get_dir)      
                self.comboBox_iq_folders.setCurrentIndex(self.comboBox_iq_folders.count()-1)
            else:
                # Directory Exists
                self.comboBox_iq_folders.setCurrentIndex(folder_index)
            
    def _slotIQ_FoldersChanged(self):
        """ Changes the IQ Files in the listbox.
        """
        # Load the Files in the Listbox
        get_dir = str(self.comboBox_iq_folders.currentText())
        if get_dir != "":
            # if get_dir == "./IQ Recordings":
                # get_dir = os.path.dirname(os.path.realpath(__file__)) + get_dir[1:]
            self.label_iq_folder.setText(get_dir)
            self.listWidget_iq_files.clear()
            file_names = []
            for fname in os.listdir(get_dir):
                if os.path.isfile(get_dir+"/"+fname):
                    file_names.append(fname)
            file_names = sorted(file_names)
            for n in file_names:
                self.listWidget_iq_files.addItem(n)
                        
    def _slotMenuPaintTxClicked(self):
        """ Opens GRC with standalone flow graph.
        """           
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/paint_tx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")     

    def _slotLibraryGalleryProtocolChanged(self):
        """ Updates the gallery listbox with images files for the selected protocol.
        """
        # Update the Listbox
        folder = os.path.dirname(os.path.realpath(__file__)) + "/Gallery/"               
        self.listWidget_library_gallery.clear()
        get_protocol = str(self.comboBox_library_gallery_protocol.currentText())
        get_protocol = get_protocol.replace(" ","_")
        protocol_len = len(get_protocol)
        for fname in sorted(os.listdir(folder)):
            if get_protocol in fname[0:protocol_len]:
                self.listWidget_library_gallery.addItem(fname)
                
    def findGalleryImages(self, protocol):
        """ Returns the names of Gallery images for a protocol.
        """
        # Check for Images
        folder = os.path.dirname(os.path.realpath(__file__)) + "/Gallery/"               
        protocol = protocol.replace(" ","_")
        protocol_len = len(protocol)
        get_file_names = []
        for fname in sorted(os.listdir(folder)):
            if protocol in fname[0:protocol_len]:
                get_file_names.append(fname)
                
        return get_file_names
            
    def _slotLibraryGalleryImageChanged(self):
        """ Displays the selected image in the gallery.
        """
        try:
            # Display Image
            get_image_name = str(self.listWidget_library_gallery.currentItem().text())
            get_image = QtGui.QPixmap(os.path.dirname(os.path.realpath(__file__)) + "/Gallery/" + get_image_name)
            get_width = get_image.width()
            get_height = get_image.height()
            label_width = 860
            label_height = 630
            
            # Resize Image, Keep Aspect Ratio
            w_ratio = float(get_width)/float(label_width)
            h_ratio = float(get_height)/float(label_height)
            if w_ratio > h_ratio:
                get_image = get_image.scaled(int(get_width/w_ratio),int(get_height/w_ratio))
            else:
                get_image = get_image.scaled(int(get_width/h_ratio),int(get_height/h_ratio))
            
            self.label_library_gallery.setFixedSize(get_image.width(),get_image.height())
            self.label_library_gallery.setPixmap(get_image)
            
        except:
            pass
        
    def _slotLibraryGalleryNextClicked(self):
        """ Selects the next picture in the gallery listbox.
        """
        # Increment the Row
        get_index = self.listWidget_library_gallery.currentRow() + 1
        if get_index >= self.listWidget_library_gallery.count():
            self.listWidget_library_gallery.setCurrentRow(0)
        else:
            self.listWidget_library_gallery.setCurrentRow(get_index)
        
    def _slotLibraryGalleryPreviousClicked(self):
        """ Selects the previous picture in the gallery listbox.
        """
        # Decrement the Row
        get_index = self.listWidget_library_gallery.currentRow() - 1
        if get_index < 0:
            self.listWidget_library_gallery.setCurrentRow(self.listWidget_library_gallery.count()-1)
        else:
            self.listWidget_library_gallery.setCurrentRow(get_index)
        
    def _slotLibraryGalleryOpenClicked(self):
        """ Opens the selected gallery image in an image viewer.
        """
        # Get the File
        get_image_name = str(self.listWidget_library_gallery.currentItem().text())
        image_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Gallery/" + get_image_name
            
        # Opens the File with EOG
        osCommandString = "eog " + image_filepath
        os.system(osCommandString+ " &") 
        
    def _slotMenuX10_TxRxClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/x10_tx_rx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuWifiRelayClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/wifi_relay.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuWiresharkClicked(self):
        """ Opens Wireshark.
        """
        # Open Wireshark in the Background
        proc=subprocess.Popen(['gnome-terminal -- wireshark'], shell=True)  
        
    def _slotPD_BitViewerHexClicked(self):
        """ Converts list of bits into hex.
        """
        # Get List of Bits
        get_bits_str = str(self.plainTextEdit_pd_bit_viewer_bits.toPlainText())
        if len(get_bits_str) > 0:
            # Remove Spaces
            get_bits_str = get_bits_str.replace(" ","")
            
            # Split by Line
            get_bits = get_bits_str.splitlines()
                    
            # Convert Each to Hex
            get_hex = []
            for b in get_bits:
                
                # Get Rid of Bits on End
                bit_modulo = len(b) % 4
                if bit_modulo != 0:
                    b = b[:-bit_modulo]
                    
                get_hex.append( str(('%0*X' % (2,int(b,2))).zfill(int(len(b)/4))) )
                
            # Clear the Hex Edit Box
            if self.checkBox_pd_bit_viewer_replace.isChecked():
                self.plainTextEdit_pd_bit_viewer_hex.setPlainText("") 
            
            # Put Hex Strings in Table    
            for i in get_hex:
                self.plainTextEdit_pd_bit_viewer_hex.appendPlainText(i)

            
    def _slotPD_BitViewerSortClicked(self):
        """ Sorts the Hex Output Alphabetically
        """
        # Sort Hex Text Edit Box
        get_hex_str = str(self.plainTextEdit_pd_bit_viewer_hex.toPlainText())
        if len(get_hex_str) > 0:
            get_hex = sorted(get_hex_str.splitlines())            
            self.plainTextEdit_pd_bit_viewer_hex.setPlainText("")              
            for i in get_hex:
                self.plainTextEdit_pd_bit_viewer_hex.appendPlainText(i)
                
            
    def _slotPD_BitViewerSendToBufferClicked(self):
        """ Sends Hex Edit Box Data to Circular Buffer 
        """
        # Get Hex Data from Edit Box
        get_hex_str = str(self.plainTextEdit_pd_bit_viewer_hex.toPlainText())
        get_hex_str = get_hex_str.replace("\n","")
       
        if len(get_hex_str) > 0:     
                       
            # Even Number of Nibbles
            nibble_modulo = len(get_hex_str) % 2
            if nibble_modulo != 0:
                get_hex_str = get_hex_str[:-nibble_modulo]
            
            # Convert Strings to Bytes  
            hex_bytes = bytearray.fromhex(get_hex_str)
                        
            # Make a PUB Socket
            pd_bits_port = self.dashboard_settings_dictionary['pd_bits_port']
            ctx = zmq.Context()
            sock = ctx.socket(zmq.PUB)
            sock.bind("tcp://127.0.0.1:" + str(pd_bits_port))
            #sock.bind("tcp://127.0.0.1:5066")
            time.sleep(1)
            sock.send(hex_bytes)
            print("Sent string: %s ..." % get_hex_str)
            time.sleep(1)
            sock.close()
            ctx.term()

    def _slotIQ_TransferFileSelectClicked(self):
        """ Returns the filepath of a source IQ file.
        """
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['IQ/Misc. (*.iq *.dat)','IQ Recordings (*.iq)','Misc. (*.dat)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_transfer_file.setPlainText(folder)
        except:
            pass  
            
        # Hide Success Label
        self.label_iq_transfer_file_success.setVisible(False)            
        
    def _slotIQ_TransferFileSaveAsClicked(self):
        """ Returns the destination filepath for an IQ file.
        """
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['IQ/Misc. (*.iq *.dat)','IQ Recordings (*.iq)','Misc. (*.dat)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_transfer_save_as.setPlainText(folder)
        except:
            pass  
            
        # Hide Success Label
        self.label_iq_transfer_file_success.setVisible(False)
        
    def _slotIQ_TranferFileClicked(self):
        """ Copies the file from the source location to the destination location
        """
        # Get Files
        get_file1 = str(self.textEdit_iq_transfer_file.toPlainText())
        get_file2 = str(self.textEdit_iq_transfer_save_as.toPlainText())
        
        # Copy Files
        if len(get_file1) > 0 and len(get_file2) > 0:
            shutil.copy(get_file1, get_file2)
            
            # Show Success Label
            self.label_iq_transfer_file_success.setVisible(True)

    def _slotIQ_CropSaveAsClicked(self):
        """ Returns the destination filepath for the new IQ file.
        """
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['IQ/Misc. (*.iq *.dat)','IQ Recordings (*.iq)','Misc. (*.dat)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_crop_new.setPlainText(folder)
        except:
            pass  

    def _slotIQ_PlotNextClicked(self):
        """ Increments the number of samples in the plot range.
        """
        # Get the Range
        get_start = int(self.textEdit_iq_start.toPlainText())
        get_end = int(self.textEdit_iq_end.toPlainText())
        get_max = int(self.label_iq_samples.text().split(" ")[1])
        
        # Increment the Range
        if get_end < get_max:
            get_start = get_start + 1000000
            get_end = get_end + 1000000
            
            # Do Not Surpass Max
            if get_end > get_max:
                get_end = get_max
                get_start = get_max - 1000000 + 1
        
            # Set the Range
            self.textEdit_iq_start.setPlainText(str(get_start))
            self.textEdit_iq_end.setPlainText(str(get_end))
        
    def _slotIQ_PlotPrevClicked(self):
        """ Decrements the number of samples in the plot range.
        """
        # Get the Range
        get_start = int(self.textEdit_iq_start.toPlainText())
        get_end = int(self.textEdit_iq_end.toPlainText())
        get_max = int(self.label_iq_samples.text().split(" ")[1])
        
        # Decrement the Range
        if get_end > 1000000:
            get_start = get_start - 1000000
            get_end = get_end - 1000000
            
            # Do Not Surpass Min
            if get_start < 1:
                get_start = 1
                get_end = 1000000
        
            # Set the Range
            self.textEdit_iq_start.setPlainText(str(get_start))
            self.textEdit_iq_end.setPlainText(str(get_end))
            
    def _slotPD_BitViewerTableSortClicked(self):
        """ Sorts the Hex Output Alphabetically
        """
        # Sort Hex Text Edit Box and Table Widget
        get_hex_str = str(self.plainTextEdit_pd_bit_viewer_hex.toPlainText())
        if len(get_hex_str) > 0:
            get_hex = sorted(get_hex_str.splitlines())            
            self.tableWidget_pd_bit_viewer_hex.setRowCount(0)  
            for i in get_hex:                
                # Insert a Row
                self.tableWidget_pd_bit_viewer_hex.setRowCount(self.tableWidget_pd_bit_viewer_hex.rowCount()+1)
                
                # Set the Text
                table_item = QtWidgets.QTableWidgetItem(str(i))
                self.tableWidget_pd_bit_viewer_hex.setItem(self.tableWidget_pd_bit_viewer_hex.rowCount()-1,0,table_item) 
            
            # Resize Table
            self.tableWidget_pd_bit_viewer_hex.resizeColumnsToContents()
            self.tableWidget_pd_bit_viewer_hex.resizeRowsToContents()
            self.tableWidget_pd_bit_viewer_hex.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_pd_bit_viewer_hex.horizontalHeader().setStretchLastSection(True)
            
    def _slotPD_BitViewerFillTableClicked(self):
        """ Fills the protocol matching table with hex data.
        """
        # Get Hex
        get_hex = str(self.plainTextEdit_pd_bit_viewer_hex.toPlainText())
        
        if len(get_hex) > 0:
            
            # Remove Spaces
            get_hex = get_hex.replace(" ","")
            
            # Clear the Hex Table
            if self.checkBox_pd_bit_viewer_table_replace.isChecked():
                self.tableWidget_pd_bit_viewer_hex.setRowCount(0)
                self.tableWidget_pd_bit_viewer_hex.setColumnCount(1)     
                header_item = QtWidgets.QTableWidgetItem("Data")
                header_item.setTextAlignment(QtCore.Qt.AlignCenter)
                self.tableWidget_pd_bit_viewer_hex.setHorizontalHeaderItem(0,header_item)
            
            # Put Hex Strings in Table    
            for i in get_hex.split():                
                # Insert a Row
                self.tableWidget_pd_bit_viewer_hex.setRowCount(self.tableWidget_pd_bit_viewer_hex.rowCount()+1)
                
                # Set the Text
                table_item = QtWidgets.QTableWidgetItem(str(i))
                self.tableWidget_pd_bit_viewer_hex.setItem(self.tableWidget_pd_bit_viewer_hex.rowCount()-1,0,table_item) 
            
            # Resize Table
            self.tableWidget_pd_bit_viewer_hex.resizeColumnsToContents()
            self.tableWidget_pd_bit_viewer_hex.resizeRowsToContents()
            self.tableWidget_pd_bit_viewer_hex.horizontalHeader().setStretchLastSection(False)
            self.tableWidget_pd_bit_viewer_hex.horizontalHeader().setStretchLastSection(True)
            
            # Enable Buttons
            self.pushButton_pd_bit_viewer_table_sort.setEnabled(True)    
            
    def _slotPD_BitViewerProtocolsChanged(self):
        """ Updates the list of protocol message types in subcategories combo box.
        """
        # Get the Protocol                
        current_protocol_key = str(self.comboBox_pd_bit_viewer_protocols.currentText())
        if current_protocol_key:  #will be false if no current protocol selected
            try:
                #return sorted list based on sort order subkey
                packet_types = getPacketTypes(self.pd_library, current_protocol_key)
                self.comboBox_pd_bit_viewer_subcategory.clear()
                self.comboBox_pd_bit_viewer_subcategory.addItems(packet_types)             
                    
            except KeyError:
                #No packet types!
                packet_types = []
                self.comboBox_pd_bit_viewer_subcategory.clear()
        
    def _slotPD_BitViewerSubcategoryChanged(self):
        """ Doesn't do anything yet. Delete?
        """
        pass
        
    def _slotPD_BitViewerApplyClicked(self):
        """ Applies message fields to the data in the protocol matching table.
        """
        if self.tableWidget_pd_bit_viewer_hex.rowCount() > 0:
            # Get Protocol and Subcategory
            get_protocol = str(self.comboBox_pd_bit_viewer_protocols.currentText())  
            get_subcategory = str(self.comboBox_pd_bit_viewer_subcategory.currentText())
            
            try:
                # Fields          
                fields = getFields(self.pd_library, get_protocol, get_subcategory)
                self.tableWidget_pd_bit_viewer_hex.setColumnCount(len(fields)+1)            
                
                # Lengths
                get_lengths = []
                for n in range(0,len(fields)):
                    get_lengths.append(self.pd_library["Protocols"][get_protocol]['Packet Types'][get_subcategory]['Fields'][fields[n]]['Length'])
            
            except KeyError:
                #No Fields Defined!
                print("No Fields Defined!")
                
            if len(get_lengths) > 0:
                                
                # Break up Packets By Field Lengths   
                self.bit_viewer_column_type = [] 
                for col in range(0,len(fields)):
                    # Add Column
                    new_color = self.suitable_colors[0]              
                    header_item = QtWidgets.QTableWidgetItem(fields[col])
                    header_item.setTextAlignment(QtCore.Qt.AlignCenter)
                    header_item.setForeground(QtGui.QColor(255,0,0))
                    self.tableWidget_pd_bit_viewer_hex.setHorizontalHeaderItem(col,header_item)
                    self.bit_viewer_column_type.append("Binary")
                self.bit_viewer_column_type.append("Binary")  # "Extra"
                    
                # Create "Extra" Column
                new_color = self.suitable_colors[0]              
                header_item = QtWidgets.QTableWidgetItem("Extra")
                header_item.setTextAlignment(QtCore.Qt.AlignCenter)
                header_item.setForeground(QtGui.QColor(255,0,0))
                self.tableWidget_pd_bit_viewer_hex.setHorizontalHeaderItem(len(fields),header_item)                    
                    
                for row in range(0,self.tableWidget_pd_bit_viewer_hex.rowCount()):
                                        
                    # Get the Table Data
                    get_data = str(self.tableWidget_pd_bit_viewer_hex.item(row,0).text())
                    hex_len = len(get_data)
                    bin_str = bin(int(get_data, 16))[2:].zfill(int(hex_len*4))
                    bit_index = 0
                    
                    # Populate the Row
                    for col in range(0,len(fields)+1):
                        if col == len(fields):
                            data_item = QtWidgets.QTableWidgetItem(bin_str[bit_index::])   
                        else:
                            data_item = QtWidgets.QTableWidgetItem(bin_str[bit_index:bit_index+get_lengths[col]])
                            bit_index = bit_index + get_lengths[col]
                        data_item.setTextAlignment(QtCore.Qt.AlignCenter)   
                        self.tableWidget_pd_bit_viewer_hex.setItem(row,col,data_item)            
            
                # Resize the Table
                self.tableWidget_pd_bit_viewer_hex.resizeColumnsToContents()
                self.tableWidget_pd_bit_viewer_hex.resizeRowsToContents()  
                self.tableWidget_pd_bit_viewer_hex.horizontalHeader().setStretchLastSection(False)
                self.tableWidget_pd_bit_viewer_hex.horizontalHeader().setStretchLastSection(True)
            
    def _slotPD_BitViewerColumnClicked(self,col):
        """ Toggles the contents of the bit viewer table between binary and hex.
        """          
        # Toggle the Text
        stay_binary = False
        for row in range(0,self.tableWidget_pd_bit_viewer_hex.rowCount()):
            # Get the Data 
            get_data = str(self.tableWidget_pd_bit_viewer_hex.item(row,col).text())
             
            # Hex to Binary
            if self.bit_viewer_column_type[col] == "Hex":
                bin_str = bin(int(get_data, 16))[2:].zfill(int(len(get_data)*4))
                #~ bin_str_spaces = ' '.join([bin_str[i:i+4] for i in range(0, len(bin_str), 4)])
                self.tableWidget_pd_bit_viewer_hex.item(row,col).setText(bin_str)
                
            # Binary to Hex    
            elif self.bit_viewer_column_type[col] == "Binary":
                get_data = get_data.replace(' ', '')
                if len(get_data) % 4 == 0:
                    hex_str = '%0*X' % ((len(get_data) + 3) // 4, int(get_data, 2))
                    self.tableWidget_pd_bit_viewer_hex.item(row,col).setText(hex_str)  
                else:
                    stay_binary = True
        
        # Save the Field Type
        if self.bit_viewer_column_type[col] == "Hex":
            self.bit_viewer_column_type[col] = "Binary"
            
            # Change the Header Font Color to Red
            get_header_text = str(self.tableWidget_pd_bit_viewer_hex.horizontalHeaderItem(col).text())
            header_item = QtWidgets.QTableWidgetItem(get_header_text)
            header_item.setTextAlignment(QtCore.Qt.AlignCenter)
            header_item.setForeground(QtGui.QColor(255,0,0))
            self.tableWidget_pd_bit_viewer_hex.setHorizontalHeaderItem(col,header_item)             
            
        else:
            if stay_binary == False:
                self.bit_viewer_column_type[col] = "Hex"
                
                # Change the Header Font Color to Black
                get_header_text = str(self.tableWidget_pd_bit_viewer_hex.horizontalHeaderItem(col).text())
                header_item = QtWidgets.QTableWidgetItem(get_header_text)
                header_item.setTextAlignment(QtCore.Qt.AlignCenter)
                header_item.setForeground(QtGui.QColor(0,0,0))
                self.tableWidget_pd_bit_viewer_hex.setHorizontalHeaderItem(col,header_item)      
                            
        # Resize the Table
        self.tableWidget_pd_bit_viewer_hex.resizeColumnsToContents() 
        self.tableWidget_pd_bit_viewer_hex.horizontalHeader().setStretchLastSection(False)            
        self.tableWidget_pd_bit_viewer_hex.horizontalHeader().setStretchLastSection(True)            
            
    def _slotIQ_TimeslotSelect1Clicked(self):
        """ Loads the current file selected in the list widget as the input file.
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_timeslot_input.setPlainText(get_folder + '/' + get_file) 
            
        except:
            pass
        
    def _slotIQ_TimeslotSelect2Clicked(self):
        """ Loads the current file selected in the list widget as the output file. 
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_timeslot_output.setPlainText(get_folder + '/' + get_file) 
            
        except:
            pass
    
    def _slotIQ_TimeslotLoad1Clicked(self):
        """ Opens a file dialog to select input file for padding data.        
        """
        # Select a Directory
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['IQ/Misc. (*.iq *.dat)','IQ Recordings (*.iq)','Misc. (*.dat)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_timeslot_input.setPlainText(folder)
        except:
            pass

    def _slotIQ_TimeslotLoad2Clicked(self):
        """ Opens a file dialog to select output file.
        """
        # Select a Directory
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['IQ/Misc. (*.iq *.dat)','IQ Recordings (*.iq)','Misc. (*.dat)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_timeslot_output.setPlainText(folder)
        except:
            pass
            
    def _slotIQ_TimeslotPadClicked(self):
        """ Pads the input file with zeros to make evenly spaced timeslots.
        """
        if len(str(self.textEdit_iq_timeslot_input.toPlainText())) > 0 and len(str(self.textEdit_iq_timeslot_output.toPlainText())) > 0:
            print("Padding to make timeslots...")
            print("Identifying burst locations...")
            new_filepath = str(self.textEdit_iq_timeslot_output.toPlainText())
            filepath = str(self.textEdit_iq_timeslot_input.toPlainText())
            fs = int(float(str(self.textEdit_iq_timeslot_sample_rate.toPlainText()))*1e6)
            timeslot = float(str(self.textEdit_iq_timeslot_period.toPlainText()))
            sample_size = 8
            num_copies = int(str(self.textEdit_iq_timeslot_copies.toPlainText()))

            start_loc = [0]
            end_loc = []
            find_start = False
            find_end = True

            old_file = fromfile(open(filepath), dtype=complex64)  # scipy.fromfile, scipy.complex64

            # Find Start and End of Each Message
            for n in range(2,len(old_file)):
                
                # Find End
                if find_end is True:
                    if old_file[n] == 0j and old_file[n-1] == 0j and old_file[n-2]== 0j:
                        end_loc.append(n-3)
                        find_end = False
                        find_start = True
                        
                # Find Start
                if find_start is True:
                    if old_file[n] != 0j and old_file[n-1] and old_file[n-2]== 0j:
                        start_loc.append(n-1)
                        find_end = True
                        find_start = False
                        
            #print(start_loc)
            #print(end_loc)

            print("Burst rising edges detected: " + str(len(start_loc)))
            print("Burst falling edges detected: " + str(len(end_loc)))

            old_file = open(filepath,"rb") 
            new_file = open(new_filepath,"a")
            
            print("Writing to file...")
            for n in range(0,len(end_loc)):
            #for n in range(0,500):
                old_file.seek(start_loc[n]*sample_size)
                packet_len = end_loc[n]-start_loc[n]
                get_packet = old_file.read(packet_len*sample_size)    
                for m in range(0,num_copies):
                        pad_bytes = (fs*timeslot-packet_len) * sample_size
                        new_file.write(get_packet)
                        new_file.write(b'\x00' * int(pad_bytes))
            old_file.close()    
            new_file.close()
            print("Done")
        
        else:
            msgBox = MyMessageBox(my_text = "Provide input and output IQ file.", width=300, height=100)
            msgBox.exec_() 
            
    def _slotPacketCommaSeparatedClicked(self):
        """ Converts hex data (0000) to \x00,\x00 in assembled text edit box.
        """
        # Get the Hex String
        get_hex = str(self.textEdit_packet_assembled.toPlainText())
        
        # Add the '\x,'
        if len(get_hex) > 0:
            output_string = '\\x'
            for n in range(0,len(get_hex),2):
                output_string = output_string + get_hex[n:n+2] + ',\\x'
                
            self.textEdit_packet_assembled.setPlainText(output_string[:-3])
            
    def _slotPacketCommaSeparatedClicked2(self):
        """ Converts hex data (0000) to 0x00,0x00 in assembled text edit box.
        """
        # Get the Hex String
        get_hex = str(self.textEdit_packet_assembled.toPlainText())
        
        # Add the '0x,'
        if len(get_hex) > 0:
            output_string = '0x'
            for n in range(0,len(get_hex),2):
                output_string = output_string + get_hex[n:n+2] + ',0x'
                
            self.textEdit_packet_assembled.setPlainText(output_string[:-3])    
            
    def _slotMenuBluetoothctlClicked(self):
        """ Opens a terminal with bluetoothctl running.
        """
        # Run bluetoothctl
        command_text = 'gnome-terminal -- bluetoothctl'
        proc = subprocess.Popen(command_text, shell=True)        

    def _slotPacketPattern1Clicked(self):
        """ Converts hex data (0000) to \x00\x00 in assembled text edit box.
        """
        # Get the Hex String
        get_hex = str(self.textEdit_packet_assembled.toPlainText())
        
        # Add the '\x'
        if len(get_hex) > 0:
            output_string = '\\x'
            for n in range(0,len(get_hex),2):
                output_string = output_string + get_hex[n:n+2] + '\\x'
                
            self.textEdit_packet_assembled.setPlainText(output_string[:-2])   
            
    def _slotMenuNoiseSourceClicked(self):
        """ Opens GRC with standalone flow graph.
        """           
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/noise_source.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")    
        
    def _slotPD_BitViewerInvertClicked(self):
        """ Inverts the bits in the Data Viewer tab.
        """
        # Get List of Bits
        get_bits_str = str(self.plainTextEdit_pd_bit_viewer_bits.toPlainText())
        
        # Invert the Bits
        inverted_bits = []
        if len(get_bits_str) > 0:
            get_bits = get_bits_str.splitlines()
            for x in get_bits:
                inverted_bits.append(x.replace("1", "2").replace("0", "1").replace("2", "0"))
            
            # Clear the Bits Edit Box
            self.plainTextEdit_pd_bit_viewer_bits.setPlainText("") 
            
            # Put Bit Strings in Table    
            for i in inverted_bits:
                self.plainTextEdit_pd_bit_viewer_bits.appendPlainText(i)
        
    def _slotPD_BitViewerDifferentialClicked(self):
        """ Applies differential encoding to the bits in the Data Viewer tab.
        """
        # Get List of Bits
        get_bits_str = str(self.plainTextEdit_pd_bit_viewer_bits.toPlainText())
        
        # Differentiate the Bits
        diff_bits = []
        if len(get_bits_str) > 0:
            get_bits = get_bits_str.splitlines()
            
            # Each Row
            for x in get_bits:
                get_diff = ''
                if len(x) > 1:                    
                    # Differentiate
                    for b in range(1,len(x)):
                        if x[b-1] == x[b]:
                            get_diff = get_diff + '0'
                        else:
                            get_diff = get_diff + '1'                    
                    diff_bits.append(get_diff)
                elif len(x) == 1:
                    diff_bits.append(x[0])
                
            # Clear the Bits Edit Box
            self.plainTextEdit_pd_bit_viewer_bits.setPlainText("") 
            
            # Put Bit Strings in Table    
            for i in diff_bits:
                self.plainTextEdit_pd_bit_viewer_bits.appendPlainText(i)                
        
    def _slotPD_BitViewerManEncClicked(self):
        """ Applies Manchester encoding to the bits in the Data Viewer tab.
        """
        # Get List of Bits
        get_bits_str = str(self.plainTextEdit_pd_bit_viewer_bits.toPlainText())
        
        # Manchester Encode the Bits
        man_bits = []
        if len(get_bits_str) > 0:
            get_bits = get_bits_str.splitlines()
            
            # Each Row
            for x in get_bits:
                get_man = ''
                   
                # Manchester Encode
                for m in x:
                    if m == '0':
                        get_man = get_man + '01'
                    else:
                        get_man = get_man + '10'
                man_bits.append(get_man)
                
            # Clear the Bits Edit Box
            self.plainTextEdit_pd_bit_viewer_bits.setPlainText("") 
            
            # Put Bit Strings in Table    
            for i in man_bits:
                self.plainTextEdit_pd_bit_viewer_bits.appendPlainText(i)               
            
    def _slotPD_BitViewerManDecClicked(self):
        """ Applies Manchester decoding to the bits in the Data Viewer tab.
        """
        # Get List of Bits
        get_bits_str = str(self.plainTextEdit_pd_bit_viewer_bits.toPlainText())
        
        # Manchester Decode the Bits
        dec_man_bits = []
        if len(get_bits_str) > 0:
            get_bits = get_bits_str.splitlines()
            
            # Each Row
            for x in get_bits:
                get_dec_man = ''
                   
                # Manchester Decode
                for m in range(0,len(x),2):
                    if x[m:m+2] == '01':
                        get_dec_man = get_dec_man + '0'
                    elif x[m:m+2] == '10':
                        get_dec_man = get_dec_man + '1'
                    else:
                        get_dec_man = get_dec_man + '?'
                dec_man_bits.append(get_dec_man)
                
            # Clear the Bits Edit Box
            self.plainTextEdit_pd_bit_viewer_bits.setPlainText("") 
            
            # Put Bit Strings in Table    
            for i in dec_man_bits:
                self.plainTextEdit_pd_bit_viewer_bits.appendPlainText(i)
        
    def _slotMenuHelpUploadingFlowGraphsClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/UploadingFlowGraphs.html &")
        
    def _slotMenuHelpUploadingPythonScriptesClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/UploadingPythonScripts.html &")
        
    def _slotMenuHelpNewUSRPX310_Clicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/NewUSRP_X310.html &")
        
    def _slotMenuHelpUpdatingHackRFClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/UpdatingHackRF_Firmware.html &")
        
    def _slotMenuHelpLimeSDR_Clicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/LimeSDR_Notes.html &")
        
    def _slotMenuHelpSupportedProtocolsClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/SupportedProtocols.html &")                                                        
        
    def _slotMenuHelpSoftwareAndConflictsClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/SoftwareAndConflicts.html &")        
        
    def _slotMenuHelpBuiltWithClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/BuiltWith.html &")   
        
    def _slotMenuHelpAboutClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/About.html &")             
        
    def _slotMenuLessonOpenBTS_Clicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson1_OpenBTS.html &")    
                
    def _slotIQ_PlaybackRecordFreqClicked(self):
        """ Copies the frequency value from the Record tab table to the Playback tab table.
        """
        # Get Record Table Value
        get_frequency = str(self.tableWidget_iq_record.item(0,1).text())
        
        # Make New Item
        frequency_item = QtWidgets.QTableWidgetItem(get_frequency)
        frequency_item.setTextAlignment(QtCore.Qt.AlignCenter)   
        
        # Copy to Playback Table
        self.tableWidget_iq_playback.setItem(0,0,frequency_item)

    def _slotIQ_PlaybackRecordGainClicked(self):
        """ Copies the gain value from the Record tab table to the Playback tab table.
        """
        # Get Record Table Value
        get_gain = str(self.tableWidget_iq_record.item(0,4).text())
        
        # Make New Item
        gain_item = QtWidgets.QTableWidgetItem(get_gain)
        gain_item.setTextAlignment(QtCore.Qt.AlignCenter)   
        
        # Copy to Playback Table
        self.tableWidget_iq_playback.setItem(0,3,gain_item)

    def _slotIQ_PlaybackRecordRateClicked(self):
        """ Copies the sampling rate value from the Record tab table to the Playback tab table.
        """
        # Get Record Table Value
        get_sample_rate = str(self.tableWidget_iq_record.item(0,7).text())
        
        # Make New Item
        sample_rate_item = QtWidgets.QTableWidgetItem(get_sample_rate)
        sample_rate_item.setTextAlignment(QtCore.Qt.AlignCenter)   
        
        # Copy to Playback Table
        self.tableWidget_iq_playback.setItem(0,4,sample_rate_item)
        
    def _slotMenuV2VerifierClicked(self):
        """ Opens the V2Verifier GUI for DSRC testing.
        """
        # Run V2Verfier main.py
        command_text = 'sudo python3 main.py local dsrc -g'
        proc = subprocess.Popen('gnome-terminal -- ' + command_text + " &", shell=True, cwd=os.path.dirname(os.path.realpath(__file__)) + '/Tools/v2verifier-master')
        
    def _slotMenuV2VerifierWifiTxClicked(self):
        """ Opens the V2Verifier wifi_tx flow graph.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/v2verifier_wifi_tx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")            
        
    def _slotMenuV2VerifierWifiRxClicked(self):
        """ Opens the V2Verifier wifi_rx flow graph.
        """       
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/v2verifier_wifi_rx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")    
        
    def defaultAttackFilepathDirectory(self, attack_name, variable_name):
        """ Returns the default directory for when the filepath button is pressed for an attack.
        """
        # Get the Desired Filepath
        get_directory = ""
        if attack_name == "DSRC_wifi_tx_generator.py":
            if variable_name == "coordinate_filepath":
                get_directory = os.path.dirname(os.path.realpath(__file__)) + "/Tools/v2verifier-master/coords/"
            elif variable_name == "key_filepath":
                get_directory = os.path.dirname(os.path.realpath(__file__)) + "/Tools/v2verifier-master/keys/"
        elif attack_name == "DSRC_Default_From_File.py":
            get_directory = os.path.dirname(os.path.realpath(__file__)) + "/Crafted Packets/"
        elif attack_name == "FM_Radio_FM_From_File.py":
            get_directory = os.path.dirname(os.path.realpath(__file__)) + "/Crafted Packets/Attack Recordings"

        return get_directory
            
    def _slotMenuFALCON_Clicked(self):
        """ Opens FALCON for LTE monitoring.
        """
        # Run FALCON
        proc=subprocess.Popen("FalconGUI &", shell=True) 
        
    def _slotMenuCyberChefClicked(self):
        """ Opens CyberChef in a browser
        """
        os.system("sensible-browser https://gchq.github.io/CyberChef/ &")
        
    def _slotMenuESP8266BeaconSpammerClicked(self):
        """ Opens ESP8266 Beacon Spammer for Wifi in Arduino IDE.
        """  
        # Open Arduino IDE
        ibf_directory = os.path.expanduser("~/Installed_by_FISSURE/Esp8266_listen_trigger/")
        proc=subprocess.Popen("sudo arduino " + ibf_directory + "Esp8266_listen_trigger.ino &", shell=True) 
        
    def _slotMenuESP32BLE_BeaconSpamClicked(self):
        """ Opens ESP32 Beacon Spammer for BLE in Arduino IDE.
        """  
        # Open Arduino IDE
        ibf_directory = os.path.expanduser("~/Installed_by_FISSURE/Esp8266_listen_trigger/ESP32-BLEBeaconSpam/")
        proc=subprocess.Popen("sudo arduino " + ibf_directory + "ESP32-BLEBeaconSpam.ino &", shell=True) 
        
    def _slotMenuMinicomClicked(self):
        """ Opens a minicom in a terminal.
        """  
        # Run Minicom
        command_text = "sudo minicom" 
        proc = subprocess.Popen('gnome-terminal -- ' + command_text + " &", shell=True)
        
    def _slotMenuPuttyClicked(self):
        """ Opens a PuTTY in a terminal.
        """  
        # Run PuTTY
        command_text = "sudo putty" 
        proc = subprocess.Popen('gnome-terminal -- ' + command_text + " &", shell=True)
        
    def _slotMenuOpenHAB_Clicked(self):
        """ Opens a PuTTY in a terminal.
        """  
        # Open a browser to openHAB
        os.system("sensible-browser http://127.0.0.1:8080 &")
        
    def _slotMenuStart_openHAB_ServiceClicked(self):
        """ Opens a PuTTY in a terminal.
        """  
        # Start openHAB Service
        command_text = "sudo /bin/systemctl start openhab.service" 
        proc = subprocess.Popen('gnome-terminal -- ' + command_text + " &", shell=True)
        
    def _slotMenuStop_openHAB_ServiceClicked(self):
        """ Opens a PuTTY in a terminal.
        """  
        # Stop openHAB Service
        command_text = "sudo /bin/systemctl stop openhab.service" 
        proc = subprocess.Popen('gnome-terminal -- ' + command_text + " &", shell=True)
        
    def _slotPD_BitViewerUnDiff0Clicked(self):
        """ Undoes a bit diff operation starting with a 0.
        """
        # Get List of Bits
        get_bits_str = str(self.plainTextEdit_pd_bit_viewer_bits.toPlainText())
        
        # UnDiff the Bits
        undiff_bits = []
        if len(get_bits_str) > 0:
            get_bits = get_bits_str.splitlines()
            
            # Each Row
            for x in get_bits:
                get_undiff = '0'
                if len(x) > 1:                    
                    # UnDiff
                    for b in range(0,len(x)):
                        # Change
                        if x[b] == '1':
                            if get_undiff[-1] == '0':
                                get_undiff = get_undiff + '1'
                            else:
                                get_undiff = get_undiff + '0'
                        # Same
                        else:
                            if get_undiff[-1] == '0':
                                get_undiff = get_undiff + '0'
                            else:
                                get_undiff = get_undiff + '1'
                    undiff_bits.append(get_undiff)
                
            # Clear the Bits Edit Box
            self.plainTextEdit_pd_bit_viewer_bits.setPlainText("") 
            
            # Put Bit Strings in Table    
            for i in undiff_bits:
                self.plainTextEdit_pd_bit_viewer_bits.appendPlainText(i)            
        
    def _slotPD_BitViewerUnDiff1Clicked(self):
        """ Undoes a bit diff operation starting with a 1.
        """
        # Get List of Bits
        get_bits_str = str(self.plainTextEdit_pd_bit_viewer_bits.toPlainText())
        
        # UnDiff the Bits
        undiff_bits = []
        if len(get_bits_str) > 0:
            get_bits = get_bits_str.splitlines()
            
            # Each Row
            for x in get_bits:
                get_undiff = '1'
                if len(x) > 1:                    
                    # UnDiff
                    for b in range(0,len(x)):
                        # Change
                        if x[b] == '1':
                            if get_undiff[-1] == '0':
                                get_undiff = get_undiff + '1'
                            else:
                                get_undiff = get_undiff + '0'
                        # Same
                        else:
                            if get_undiff[-1] == '0':
                                get_undiff = get_undiff + '0'
                            else:
                                get_undiff = get_undiff + '1'
                    undiff_bits.append(get_undiff)
                
            # Clear the Bits Edit Box
            self.plainTextEdit_pd_bit_viewer_bits.setPlainText("") 
            
            # Put Bit Strings in Table    
            for i in undiff_bits:
                self.plainTextEdit_pd_bit_viewer_bits.appendPlainText(i)  
                
    def _slotMenuIEEE_802_15_4_transceiver_OQPSK_Clicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/ieee_802_15_4_transceiver_OQPSK.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuRtlZwave908_Clicked(self):
        """ Runs rtl_sdr and rtl_zwave at 908.42 MHz.
        """
        # Run rtl_sdr and rtl_zwave
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script"
        rtl_zwave_directory = os.path.expanduser("~/Installed_by_FISSURE/rtl-zwave-master/")        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "rtl_sdr -f 908.42e6 -s 2048000 -g 25 - | ./rtl_zwave"', cwd=rtl_zwave_directory, shell=True)
        
    def _slotMenuRtlZwave916_Clicked(self):
        """ Runs rtl_sdr and rtl_zwave at 916 MHz.
        """
        # Run rtl_sdr and rtl_zwave
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script"
        rtl_zwave_directory = os.path.expanduser("~/Installed_by_FISSURE/rtl-zwave-master/")        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "rtl_sdr -f 916e6 -s 2048000 -g 25 - | ./rtl_zwave"', cwd=rtl_zwave_directory, shell=True)        
        
    def _slotMenuWavingZ_908_Clicked(self):
        """ Runs rtl_sdr and wave-in at 908.42 MHz.
        """
        # Run rtl_sdr and waving-z
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script"
        rtl_zwave_directory = os.path.expanduser("~/Installed_by_FISSURE/waving-z/build/")        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "rtl_sdr -f 908420000 -s 2000000 -g 25  - | ./wave-in -u"', cwd=rtl_zwave_directory, shell=True)        
        
    def _slotMenuWavingZ_916_Clicked(self):
        """ Runs rtl_sdr and wave-in at 916 MHz.
        """
        # Run rtl_sdr and waving-z
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script"
        rtl_zwave_directory = os.path.expanduser("~/Installed_by_FISSURE/waving-z/build/")        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "rtl_sdr -f 916000000 -s 2000000 -g 25  - | ./wave-in -u"', cwd=rtl_zwave_directory, shell=True)          

    def _slotMenuStandaloneTpmsRxClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/tpms_rx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")          
        
    def _slotMenuStandaloneTpmsTxClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/tpms_tx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")       
        
    def _slotPD_BitViewerBinClicked(self):
        """ Converts list of hex into bits.
        """
        # Get List of Hex
        get_hex_str = str(self.plainTextEdit_pd_bit_viewer_hex.toPlainText())
        if len(get_hex_str) > 0:
            # Remove Spaces
            get_hex_str = get_hex_str.replace(" ","")
            
            # Split by Line
            get_hex = get_hex_str.splitlines()
                    
            # Convert Each to Binary
            get_bin = []
            for b in get_hex:                
                get_bin.append(bin(int(b, 16))[2:].zfill(int(len(b)*4)))
                
            # Clear the Binary Edit Box
            if self.checkBox_pd_bit_viewer_replace.isChecked():
                self.plainTextEdit_pd_bit_viewer_bits.setPlainText("") 
            
            # Put Binary Strings in Table    
            for i in get_bin:
                self.plainTextEdit_pd_bit_viewer_bits.appendPlainText(i)
                
    def _slotIQ_IF2_Clicked(self):
        """ Removes a lot of the peaks found in IF1.
        """
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0:
            
            # Get the Number of Samples
            try:
                start_sample = int(self.textEdit_iq_start.toPlainText())
                end_sample = int(self.textEdit_iq_end.toPlainText())
                num_samples = end_sample - start_sample + 1
            except: 
                return
            
            # Do Nothing if Bad Range
            if num_samples < 0:
                return
        
            # Get the Size of Each Sample in Bytes     
            complex_multiple = 1 
            if get_type == "Complex Float 32":
                complex_multiple = 2
                sample_size = 4
                num_samples = complex_multiple * num_samples               
            elif get_type == "Float/Float 32":
                sample_size = 4
            elif get_type == "Short/Int 16":
                sample_size = 2
            elif get_type == "Int/Int 32":
                sample_size = 4
            elif get_type == "Byte/Int 8":
                sample_size = 1
            elif get_type == "Complex Int 16":
                complex_multiple = 2
                sample_size = 2
                num_samples = complex_multiple * num_samples   
            elif get_type == "Complex Int 8":
                sample_size = 1
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                        
            elif get_type == "Complex Float 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                        
            elif get_type == "Complex Int 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                        
                
            # Check the Range
            if (num_samples*sample_size > number_of_bytes) or (complex_multiple*end_sample*sample_size > number_of_bytes) or (start_sample < 1):
                print("Out of range.")
                return            
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            if "Complex" in get_type:
                file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            else:
                file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Float/Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Short/Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Int/Int 32":
                plot_data_formatted = struct.unpack(num_samples*'i', plot_data)
            elif get_type == "Byte/Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)                                
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)                                
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)                                
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)                                
                
            # Get I/Q Data
            if "Complex" in get_type:                
                I = [float(i) for i in plot_data_formatted[::2]]
                Q = [float(q) for q in plot_data_formatted[1::2]]
                complex_data = [complex(I[x],Q[x]) for x in range(len(I))]

                # # Butterworth Filter
                # nyq = 0.5 * 5000000
                # order = 10
                # cutoff = 100000
                # normal_cutoff = cutoff/nyq
                # b, a = butter(order, normal_cutoff, btype='low', analog=False)
                # y1 = filtfilt(b, a, complex_data)
                
                # Calculate I.F. Method 1       
                y = np.diff(np.angle(complex_data))
                #instantaneous_frequency = [((math.atan2(Q[x]*(180/math.pi), I[x]*(180/math.pi)))+2*math.pi)%(2*math.pi) for x in range(len(I))]
               
                for n in range(1,len(y)-1):
                    if abs(y[n]-y[n-1]) > 0.1:
                        if y[n-1] > y[n+1]:
                            y[n] = y[n-1] - (y[n-1] - y[n+1])/2
                        else:
                            y[n] = y[n-1] + (y[n+1] - y[n-1])/2
            else:
                y = None
                
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)            
            self.iq_matplotlib_widget.axes.plot(range(1,len(y)+1),y,'b',linewidth=1)          
            self.iq_matplotlib_widget.applyLabels("Filtered Signal",'Samples','Amplitude (LSB)',None,None) 

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            #self.iq_matplotlib_widget.draw()
      
                
    def _slotIQ_CustomClicked(self):
        """ Whatever you want. Experiment and see if it is worth it.
        """
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0:
            
            # Get the Number of Samples
            try:
                start_sample = int(self.textEdit_iq_start.toPlainText())
                end_sample = int(self.textEdit_iq_end.toPlainText())
                num_samples = end_sample - start_sample + 1
            except: 
                return
            
            # Do Nothing if Bad Range
            if num_samples < 0:
                return
        
            # Get the Size of Each Sample in Bytes     
            complex_multiple = 1 
            if get_type == "Complex Float 32":
                complex_multiple = 2
                sample_size = 4
                num_samples = complex_multiple * num_samples               
            elif get_type == "Float/Float 32":
                sample_size = 4
            elif get_type == "Short/Int 16":
                sample_size = 2
            elif get_type == "Int/Int 32":
                sample_size = 4
            elif get_type == "Byte/Int 8":
                sample_size = 1
            elif get_type == "Complex Int 16":
                complex_multiple = 2
                sample_size = 2
                num_samples = complex_multiple * num_samples         
            elif get_type == "Complex Int 8":
                sample_size = 1
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
            elif get_type == "Complex Float 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
            elif get_type == "Complex Int 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
                
            # Check the Range
            if (num_samples*sample_size > number_of_bytes) or (complex_multiple*end_sample*sample_size > number_of_bytes) or (start_sample < 1):
                print("Out of range.")
                return            
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            if "Complex" in get_type:
                file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            else:
                file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Float/Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Short/Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Int/Int 32":
                plot_data_formatted = struct.unpack(num_samples*'i', plot_data)
            elif get_type == "Byte/Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)                                
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)                                
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)                                
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)                                
                
            # Get I/Q Data
            if "Complex" in get_type:
                
                I = [float(i) for i in plot_data_formatted[::2]]
                Q = [float(q) for q in plot_data_formatted[1::2]]
                complex_data = [complex(I[x],Q[x]) for x in range(len(I))]

                # # Butterworth Filter
                # nyq = 0.5 * 5000000
                # order = 10
                # cutoff = 100000
                # normal_cutoff = cutoff/nyq
                # b, a = butter(order, normal_cutoff, btype='low', analog=False)
                # y1 = filtfilt(b, a, complex_data)
                
                # Calculate I.F. Method 1       
                y = np.diff(np.angle(complex_data))
                #instantaneous_frequency = [((math.atan2(Q[x]*(180/math.pi), I[x]*(180/math.pi)))+2*math.pi)%(2*math.pi) for x in range(len(I))]
               
                for n in range(1,len(y)-1):
                    if abs(y[n]-y[n-1]) > 0.1:
                        if y[n-1] > y[n+1]:
                            y[n] = y[n-1] - (y[n-1] - y[n+1])/2
                        else:
                            y[n] = y[n-1] + (y[n+1] - y[n-1])/2
            else:
                y = None
                
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)            
            self.iq_matplotlib_widget.axes.plot(range(1,len(y)+1),y,'b',linewidth=1)          
            self.iq_matplotlib_widget.applyLabels("Filtered Signal",'Samples','Amplitude (LSB)',None,None) 

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            #self.iq_matplotlib_widget.draw() 
            
            
            # # Plot
            # self.iq_matplotlib_widget.clearPlot()
            # self.iq_matplotlib_widget.configureAxes(polar=False)
            # if "Complex" in get_type:
                # # Ignore hold() Deprecation Warnings
                # with warnings.catch_warnings():
                    # warnings.simplefilter("ignore")
                    # warnings.filterwarnings("ignore", module="matplotlib")
                    
                    # # Plot
                    # self.iq_matplotlib_widget.axes.plot(y[::2],'b',linewidth=1)
                    # self.iq_matplotlib_widget.axes.hold(True)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
                    # self.iq_matplotlib_widget.axes.plot(y[1::2],'r',linewidth=1)
                    # self.iq_matplotlib_widget.axes.hold(False)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
            # else:
                # self.iq_matplotlib_widget.axes.plot(plot_data_formatted,'b',linewidth=1)
            
            # self.iq_matplotlib_widget.applyLabels("IQ Data",'Samples','Amplitude (LSB)',None,None) 
            # self.pushButton_iq_cursor1.setChecked(False)
            # self._slotIQ_Cursor1Clicked() 
            # #self.iq_matplotlib_widget.draw()    
            
    def _slotMenuStandaloneZwaveTxClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/zwave_tx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")  
        
    def _slotMenuStandaloneZwaveRxClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/zwave_rx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")  
        
    def _slotIQ_RenameClicked(self):
        """ Renames the selected IQ file.
        """
        # Get the Selected File
        try:
            get_file = self.listWidget_iq_files.currentItem().text()
        except:
            print("No File Selected.")
            return        
        get_file_path = str(self.label_iq_folder.text() + "/" + get_file)
        
        # Open the GUI
        text, ok = QtWidgets.QInputDialog.getText(self, 'Rename', 'Enter new name:',QtWidgets.QLineEdit.Normal,get_file)
        
        # Ok Clicked
        if ok:
            os.rename(get_file_path,str(self.label_iq_folder.text() + "/"+text))
            self._slotIQ_RefreshClicked()
            
    def _slotPD_CRC_CommonWidthChanged(self):
        """ Changes the list of common CRC algorithms based on width.
        """
        # Get the CRC Width
        get_width = str(self.comboBox_pd_crc_common_width.currentText())
        
        # Switch the Algorithms
        self.comboBox_pd_crc_algorithm.clear()
        if get_width == "8":
            self.comboBox_pd_crc_algorithm.addItems(self.crc_algorithms8)
        elif get_width == "16":
            self.comboBox_pd_crc_algorithm.addItems(self.crc_algorithms16)
        elif get_width == "32":
            self.comboBox_pd_crc_algorithm.addItems(self.crc_algorithms32)
            
    def _slotLibraryRemoveProtocolClicked(self):
        """ Removes all protocol data from the library.yaml.
        """
        # Get the Protocol
        get_protocol = str(self.comboBox_library_browse_protocol.currentText())
        
        # Get Attacks
        get_attacks = [str(self.listWidget_library_browse_attacks.item(i).text()) for i in range(0,self.listWidget_library_browse_attacks.count())]

        # Get Modulation Types
        get_modulation_types = getModulations(self.pd_library,get_protocol)
        
        # Get Hardware Types
        get_hardware = []
        for n in get_attacks:
            for m in get_modulation_types:
                if m in self.pd_library["Protocols"][get_protocol]["Attacks"][n]:
                    for x in self.pd_library["Protocols"][get_protocol]["Attacks"][n][m]["Hardware"].keys():
                        if x not in get_hardware:
                            get_hardware.append(x)
        
        # Yes/No Dialog
        qm = QtWidgets.QMessageBox
        ret = qm.question(self,'', "Remove protocol and all its data from library?", qm.Yes | qm.No)
        if ret == qm.Yes:
            # Send Message to HIPRFISR/Protocol Discovery    
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Remove Attack from Library', Parameters = [get_protocol, get_attacks, get_modulation_types, get_hardware, True, True])   
        else:
            pass
        
    def _slotArchiveDownloadFolderClicked(self):
        """ Selects a folder for viewing and downloading archive files.
        """
        # Choose Folder
        get_dir = str(QtWidgets.QFileDialog.getExistingDirectory(self, "Select Directory"))
        
        # Add Directory to the Combobox       
        if len(get_dir) > 0:            
            self.comboBox_archive_download_folder.addItem(get_dir)      
            self.comboBox_archive_download_folder.setCurrentIndex(self.comboBox_archive_download_folder.count()-1)
            
    def _slotArchiveDownloadFoldersChanged(self):
        """ Changes the IQ Files in the Archive downloaded listbox.
        """
        # Load the Files in the Listbox
        get_dir = str(self.comboBox_archive_download_folder.currentText())
        if get_dir != "":
            self.listWidget_archive_download_files.clear()
            file_names = []
            for fname in os.listdir(get_dir):
                if os.path.isfile(get_dir+"/"+fname):
                    file_names.append(fname)
            file_names = sorted(file_names)
            for n in file_names:
                self.listWidget_archive_download_files.addItem(n)
                
    def _slotArchiveDownloadRefreshClicked(self):
        """ Reloads the files in the current Archive folder
        """
        try:
            # Get the Folder Location
            get_folder = str(self.comboBox_archive_download_folder.currentText())
                
            # Get the Files for the Listbox
            self.listWidget_archive_download_files.clear()
            temp_names = []
            for fname in os.listdir(get_folder):
                if os.path.isfile(get_folder+"/"+fname):
                    temp_names.append(fname)
                  
            # Sort and Add to the Listbox
            temp_names = sorted(temp_names)
            for n in temp_names:
                self.listWidget_archive_download_files.addItem(n)
                    
            # Set the Listbox Selection
            self.listWidget_archive_download_files.setCurrentRow(0)
        except:
            pass
            
    def _slotArchiveDownloadDeleteClicked(self):
        """ Deletes an IQ file from the Archive downloaded list.
        """
        # Get Highlighted File from Listbox
        get_file = str(self.listWidget_archive_download_files.currentItem().text())
        get_folder = str(self.comboBox_archive_download_folder.currentText())
        delete_filepath = get_folder + '/' + get_file
        
        # Delete
        os.system('rm "' + delete_filepath + '"')
        
        # Refresh
        self._slotArchiveDownloadRefreshClicked()   
        
    def _slotArchiveDownloadPlotClicked(self):
        """ Plots the Archive file in the IQ Viewer.
        """
        # Get the Folder and File
        get_file = str(self.listWidget_archive_download_files.currentItem().text())
        get_folder = str(self.comboBox_archive_download_folder.currentText())
        
        # Set the Files and Directories in the IQ Tab
        if get_folder == str(os.path.dirname(os.path.realpath(__file__)) + '/Archive'): 
                self.comboBox_iq_folders.setCurrentIndex(1)
        else:
            # Determine if the Directory is Present Already
            match_found = False
            for n in range(0,self.comboBox_iq_folders.count()):
                if get_folder == self.comboBox_iq_folders.itemText(n):
                    self.comboBox_iq_folders.setCurrentIndex(n)
                    match_found = True
                    break
            if match_found == False:
                self.comboBox_iq_folders.addItem(get_folder)      
                self.comboBox_iq_folders.setCurrentIndex(self.comboBox_iq_folders.count()-1)

        for n in range(0,self.listWidget_iq_files.count()):
            if get_file == self.listWidget_iq_files.item(n).text():
                self.listWidget_iq_files.setCurrentRow(n)
                break
        
        # Load the File
        self._slotIQ_LoadIQ_Data()
        
        # Plot the File
        self._slotIQ_PlotAllClicked()
        
        # Change to IQ Tab
        self.tabWidget.setCurrentIndex(4)
        
    def populateArchive(self):
        """ Populates the Archive table from library.yaml.
        """
        # Populate the Table
        get_archives = [archive for archive in sorted(self.pd_library['Archive'])]
        notes_width = 150
        new_font = QtGui.QFont("Times",10)
        
        for n in range(0,len(get_archives)):
            # Get File Info
            get_file = str(get_archives[n])
            get_protocol = str(self.pd_library['Archive'][get_archives[n]]['Protocol'])
            get_date = str(self.pd_library['Archive'][get_archives[n]]['Date'])
            get_format = str(self.pd_library['Archive'][get_archives[n]]['Format'])
            get_sample_rate = str(self.pd_library['Archive'][get_archives[n]]['Sample Rate'])
            get_tuned_frequency = str(self.pd_library['Archive'][get_archives[n]]['Tuned Frequency'])
            get_samples = str(self.pd_library['Archive'][get_archives[n]]['Samples'])
            get_size = str(self.pd_library['Archive'][get_archives[n]]['Size'])
            get_modulation = str(self.pd_library['Archive'][get_archives[n]]['Modulation'])
            get_notes = str(self.pd_library['Archive'][get_archives[n]]['Notes'])
            
            # Find Maximum Note Width
            if len(get_notes)*10 > notes_width:
                notes_width = len(get_notes)*10
                        
            # Insert a Row
            self.tableWidget_archive_download.setRowCount(self.tableWidget_archive_download.rowCount()+1)
            
            # Populate the Table
            file_item = QtWidgets.QTableWidgetItem(get_file)
            file_item.setFont(new_font)
            self.tableWidget_archive_download.setVerticalHeaderItem(self.tableWidget_archive_download.rowCount()-1,file_item)            
            protocol_item = QtWidgets.QTableWidgetItem(get_protocol)
            protocol_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            protocol_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_archive_download.setItem(self.tableWidget_archive_download.rowCount()-1,0,protocol_item) 
            date_item = QtWidgets.QTableWidgetItem(get_date)
            date_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            date_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_archive_download.setItem(self.tableWidget_archive_download.rowCount()-1,1,date_item) 
            format_item = QtWidgets.QTableWidgetItem(get_format)
            format_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            format_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_archive_download.setItem(self.tableWidget_archive_download.rowCount()-1,2,format_item) 
            sample_rate_item = QtWidgets.QTableWidgetItem(get_sample_rate)
            sample_rate_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            sample_rate_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_archive_download.setItem(self.tableWidget_archive_download.rowCount()-1,3,sample_rate_item) 
            tuned_frequency_item = QtWidgets.QTableWidgetItem(get_tuned_frequency)
            tuned_frequency_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            tuned_frequency_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_archive_download.setItem(self.tableWidget_archive_download.rowCount()-1,4,tuned_frequency_item) 
            samples_item = QtWidgets.QTableWidgetItem(get_samples)
            samples_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            samples_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_archive_download.setItem(self.tableWidget_archive_download.rowCount()-1,5,samples_item) 
            size_item = QtWidgets.QTableWidgetItem(get_size)
            size_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            size_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_archive_download.setItem(self.tableWidget_archive_download.rowCount()-1,6,size_item) 
            modulation_item = QtWidgets.QTableWidgetItem(get_modulation)
            modulation_item.setTextAlignment(QtCore.Qt.AlignCenter) 
            modulation_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_archive_download.setItem(self.tableWidget_archive_download.rowCount()-1,7,modulation_item)                                                                         
            notes_item = QtWidgets.QTableWidgetItem(get_notes)
            notes_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
            self.tableWidget_archive_download.setItem(self.tableWidget_archive_download.rowCount()-1,8,notes_item) 
            
        # Resize the Table
        #self.statTable.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)
        self.tableWidget_archive_download.resizeColumnsToContents() 
        self.tableWidget_archive_download.setColumnWidth(8, notes_width)
        self.tableWidget_archive_download.resizeRowsToContents() 
        #self.tableWidget_archive_download.horizontalHeader().setSectionResizeMode(8,QtWidgets.QHeaderView.Stretch) 
        #self.tableWidget_archive_download.horizontalHeader().setStretchLastSection(False) 
        #self.tableWidget_archive_download.horizontalHeader().setStretchLastSection(True) 
        
    def _slotArchiveDownloadClicked(self):
        """ Downloads the selected file from the internet.
        """
        # Find Selected Row
        get_row = self.tableWidget_archive_download.currentRow()
        if get_row >= 0:
            # Get File
            get_file = str(self.tableWidget_archive_download.verticalHeaderItem(get_row).text())
            
            # Get Folder 
            get_folder = str(self.comboBox_archive_download_folder.currentText())
            
            # Download        
            os.system('wget -P ' + get_folder + '/' + ' https://fissure.ainfosec.com/' + get_file)
            self._slotArchiveDownloadRefreshClicked()
            
    def _slotArchiveReplayAddClicked(self):
        """ Adds a selected archive file to the playlist table.
        """
        # Get File
        get_archive_file = str(self.listWidget_archive_download_files.currentItem().text())
        get_archive_folder = str(self.comboBox_archive_download_folder.currentText()) + '/'
        
        get_archives = [archive for archive in self.pd_library['Archive']]
        
        for n in range(0,len(get_archives)):
            # Get File Info
            get_file = str(get_archives[n])
            if get_archive_file == get_file:
                # Archive Lookup
                get_protocol = str(self.pd_library['Archive'][get_archives[n]]['Protocol'])
                #get_date = str(self.pd_library['Archive'][get_archives[n]]['Date'])
                get_format = str(self.pd_library['Archive'][get_archives[n]]['Format'])
                get_sample_rate = str(self.pd_library['Archive'][get_archives[n]]['Sample Rate'])
                get_tuned_frequency = str(self.pd_library['Archive'][get_archives[n]]['Tuned Frequency'])
                #get_samples = str(self.pd_library['Archive'][get_archives[n]]['Samples'])
                #get_size = str(self.pd_library['Archive'][get_archives[n]]['Size'])
                get_modulation = str(self.pd_library['Archive'][get_archives[n]]['Modulation'])
                #get_notes = str(self.pd_library['Archive'][get_archives[n]]['Notes'])
                
                # Set the Value in the Table
                self.tableWidget_archive_replay.setRowCount(self.tableWidget_archive_replay.rowCount()+1)
                file_item = QtWidgets.QTableWidgetItem(get_file)
                file_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                file_item.setFlags(file_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,0,file_item)     
                protocol_item = QtWidgets.QTableWidgetItem(get_protocol)
                protocol_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                protocol_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,1,protocol_item)  
                modulation_item = QtWidgets.QTableWidgetItem(get_modulation)
                modulation_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                modulation_item.setFlags(modulation_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,2,modulation_item)  
                tuned_frequency_item = QtWidgets.QTableWidgetItem(get_tuned_frequency)
                tuned_frequency_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                #tuned_frequency_item.setFlags(tuned_frequency_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,3,tuned_frequency_item)  
                sample_rate_item = QtWidgets.QTableWidgetItem(get_sample_rate)
                sample_rate_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                #sample_rate_item.setFlags(sample_rate_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,4,sample_rate_item)  
                format_item = QtWidgets.QTableWidgetItem(get_format)
                format_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                #format_item.setFlags(format_item.flags() & ~QtCore.Qt.ItemIsEditable)
                self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,5,format_item) 
                
                # Channel
                new_combobox1 = QtWidgets.QComboBox(self)
                self.tableWidget_archive_replay.setCellWidget(self.tableWidget_archive_replay.rowCount()-1,6,new_combobox1)
                if self.dashboard_settings_dictionary['hardware_archive'] == "Computer":
                    new_combobox1.addItem("")                
                elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP X310":
                    new_combobox1.addItem("A:0")
                    new_combobox1.addItem("B:0")                    
                elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B210":
                    new_combobox1.addItem("A:A")
                    new_combobox1.addItem("A:B")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
                    new_combobox1.addItem("")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "RTL2832U":
                    new_combobox1.addItem("")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "802.11x Adapter":
                    new_combobox1.addItem("")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B205mini":
                    new_combobox1.addItem("A:A")
                    new_combobox1.addItem("A:B")                    
                elif self.dashboard_settings_dictionary['hardware_archive'] == "LimeSDR":
                    new_combobox1.addItem("A")
                    new_combobox1.addItem("B")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "bladeRF":      
                    new_combobox1.addItem("")     
                elif self.dashboard_settings_dictionary['hardware_archive'] == "Open Sniffer":
                    new_combobox1.addItem("")                        
                else:
                    new_combobox1.addItem("")
                new_combobox1.setFixedSize(67,24) 
                new_combobox1.setSizeAdjustPolicy(0)
                new_combobox1.setCurrentIndex(0)
                
                # Gain    
                if self.dashboard_settings_dictionary['hardware_archive'] == "Computer":
                    gain_item = QtWidgets.QTableWidgetItem("")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP X310":
                    gain_item = QtWidgets.QTableWidgetItem("30")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B210":
                    gain_item = QtWidgets.QTableWidgetItem("60")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
                    gain_item = QtWidgets.QTableWidgetItem("20")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "RTL2832U":
                    gain_item = QtWidgets.QTableWidgetItem("")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "802.11x Adapter":
                    gain_item = QtWidgets.QTableWidgetItem("")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B205mini":     
                    gain_item = QtWidgets.QTableWidgetItem("60")       
                elif self.dashboard_settings_dictionary['hardware_archive'] == "LimeSDR":
                    gain_item = QtWidgets.QTableWidgetItem("55")
                elif self.dashboard_settings_dictionary['hardware_archive'] == "bladeRF":         
                    gain_item = QtWidgets.QTableWidgetItem("20")     
                elif self.dashboard_settings_dictionary['hardware_archive'] == "Open Sniffer":
                    gain_item = QtWidgets.QTableWidgetItem("")                                   
                else:
                    gain_item = QtWidgets.QTableWidgetItem("") 
                gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,7,gain_item) 
                 
                # Duration
                duration_item = QtWidgets.QTableWidgetItem('5')
                duration_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,8,duration_item)
                
                # Folder
                folder_item = QtWidgets.QTableWidgetItem(get_archive_folder)
                folder_item.setTextAlignment(QtCore.Qt.AlignCenter) 
                self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,9,folder_item)                
                
                # Resize the Table
                self.tableWidget_archive_replay.resizeColumnsToContents() 
                self.tableWidget_archive_replay.resizeRowsToContents()  
                self.tableWidget_archive_replay.horizontalHeader().setStretchLastSection(False) 
                self.tableWidget_archive_replay.horizontalHeader().setStretchLastSection(True) 
                
                # Enable PushButton
                self.pushButton_archive_replay_start.setEnabled(True) 
                
                return
                
        # Add File not Found in Archive
        self.tableWidget_archive_replay.setRowCount(self.tableWidget_archive_replay.rowCount()+1)
        file_item = QtWidgets.QTableWidgetItem(get_archive_file)
        file_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        file_item.setFlags(file_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,0,file_item)     
        protocol_item = QtWidgets.QTableWidgetItem("?")
        protocol_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        protocol_item.setFlags(protocol_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,1,protocol_item)  
        modulation_item = QtWidgets.QTableWidgetItem("?")
        modulation_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        modulation_item.setFlags(modulation_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,2,modulation_item)  
        tuned_frequency_item = QtWidgets.QTableWidgetItem("2400e6")
        tuned_frequency_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        #tuned_frequency_item.setFlags(tuned_frequency_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,3,tuned_frequency_item)  
        sample_rate_item = QtWidgets.QTableWidgetItem("1e6")
        sample_rate_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        #sample_rate_item.setFlags(sample_rate_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,4,sample_rate_item)  
        format_item = QtWidgets.QTableWidgetItem("Complex Float 32")
        format_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        #format_item.setFlags(format_item.flags() & ~QtCore.Qt.ItemIsEditable)
        self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,5,format_item)   
        
        # Channel
        new_combobox1 = QtWidgets.QComboBox(self)
        self.tableWidget_archive_replay.setCellWidget(self.tableWidget_archive_replay.rowCount()-1,6,new_combobox1)
        if self.dashboard_settings_dictionary['hardware_archive'] == "Computer":
            new_combobox1.addItem("")                
        elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP X310":
            new_combobox1.addItem("A:0")
            new_combobox1.addItem("B:0")                    
        elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B210":
            new_combobox1.addItem("A:A")
            new_combobox1.addItem("A:B")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
            new_combobox1.addItem("")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "RTL2832U":
            new_combobox1.addItem("")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "802.11x Adapter":
            new_combobox1.addItem("")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B205mini":
            new_combobox1.addItem("A:A")
            new_combobox1.addItem("A:B")                    
        elif self.dashboard_settings_dictionary['hardware_archive'] == "LimeSDR":
            new_combobox1.addItem("A")
            new_combobox1.addItem("B")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "bladeRF":      
            new_combobox1.addItem("")     
        elif self.dashboard_settings_dictionary['hardware_archive'] == "Open Sniffer":
            new_combobox1.addItem("")                        
        else:
            new_combobox1.addItem("")
        new_combobox1.setFixedSize(67,24) 
        new_combobox1.setSizeAdjustPolicy(0)
        new_combobox1.setCurrentIndex(0)             
        
        # Gain    
        if self.dashboard_settings_dictionary['hardware_archive'] == "Computer":
            gain_item = QtWidgets.QTableWidgetItem("")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP X310":
            gain_item = QtWidgets.QTableWidgetItem("30")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B210":
            gain_item = QtWidgets.QTableWidgetItem("60")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
            gain_item = QtWidgets.QTableWidgetItem("20")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "RTL2832U":
            gain_item = QtWidgets.QTableWidgetItem("")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "802.11x Adapter":
            gain_item = QtWidgets.QTableWidgetItem("")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B205mini":     
            gain_item = QtWidgets.QTableWidgetItem("60")       
        elif self.dashboard_settings_dictionary['hardware_archive'] == "LimeSDR":
            gain_item = QtWidgets.QTableWidgetItem("55")
        elif self.dashboard_settings_dictionary['hardware_archive'] == "bladeRF":         
            gain_item = QtWidgets.QTableWidgetItem("20")     
        elif self.dashboard_settings_dictionary['hardware_archive'] == "Open Sniffer":
            gain_item = QtWidgets.QTableWidgetItem("")                                   
        else:
            gain_item = QtWidgets.QTableWidgetItem("") 
        gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        gain_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,7,gain_item)         
        
        # Duration
        duration_item = QtWidgets.QTableWidgetItem('5')
        duration_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,8,duration_item)
        
        # Folder
        folder_item = QtWidgets.QTableWidgetItem(get_archive_folder)
        folder_item.setTextAlignment(QtCore.Qt.AlignCenter) 
        self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.rowCount()-1,9,folder_item)   
                        
        # Resize the Table
        self.tableWidget_archive_replay.resizeColumnsToContents() 
        self.tableWidget_archive_replay.resizeRowsToContents()  
        self.tableWidget_archive_replay.horizontalHeader().setStretchLastSection(False) 
        self.tableWidget_archive_replay.horizontalHeader().setStretchLastSection(True) 
        
        # Enable PushButton
        self.pushButton_archive_replay_start.setEnabled(True)                 
                
    def _slotArchiveReplayRemoveClicked(self):
        """ Removes a row from the Archive playlist table.
        """                                                                      
        # Remove from the TableWidget
        self.tableWidget_archive_replay.removeRow(self.tableWidget_archive_replay.currentRow())
        self.tableWidget_archive_replay.setCurrentCell(self.tableWidget_archive_replay.rowCount()-1,0)
                
        # Disable PushButtons
        if self.tableWidget_archive_replay.rowCount() < 1:
            self.pushButton_archive_replay_start.setEnabled(False) 
            
    def _slotArchiveReplayUpClicked(self):
        """ Moves the selected row up in the Archive playlist table.
        """
        if self.tableWidget_archive_replay.currentRow() != 0:  # Ignore top row
            # Take the Row Above
            above_item0 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()-1,0)
            above_item1 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()-1,1)
            above_item2 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()-1,2)
            above_item3 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()-1,3)
            above_item4 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()-1,4)
            above_item5 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()-1,5)
            above_item6 = self.tableWidget_archive_replay.cellWidget(self.tableWidget_archive_replay.currentRow()-1,6).currentIndex()
            above_item7 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()-1,7)
            above_item8 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()-1,8)
            
            # Take the Current Row
            current_item0 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),0)
            current_item1 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),1)
            current_item2 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),2)
            current_item3 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),3)
            current_item4 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),4)
            current_item5 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),5)
            current_item6 = self.tableWidget_archive_replay.cellWidget(self.tableWidget_archive_replay.currentRow(),6).currentIndex()
            current_item7 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),7)
            current_item8 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),8)
            
            # Set the Current Row
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),0,above_item0)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),1,above_item1)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),2,above_item2)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),3,above_item3)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),4,above_item4)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),5,above_item5)
            self.tableWidget_archive_replay.cellWidget(self.tableWidget_archive_replay.currentRow(),6).setCurrentIndex(above_item6)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),7,above_item7)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),8,above_item8)
            
            # Set the Row Above
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()-1,0,current_item0)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()-1,1,current_item1)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()-1,2,current_item2)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()-1,3,current_item3)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()-1,4,current_item4)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()-1,5,current_item5)
            self.tableWidget_archive_replay.cellWidget(self.tableWidget_archive_replay.currentRow()-1,6).setCurrentIndex(current_item6)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()-1,7,current_item7)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()-1,8,current_item8)
            
            # Change the Selected Row               
            self.tableWidget_archive_replay.setCurrentCell(self.tableWidget_archive_replay.currentRow()-1,0)
            
            # Resize
            self.tableWidget_archive_replay.resizeRowsToContents()    
            
    def _slotArchiveReplayDownClicked(self):
        """ Moves the selected row down in the Archive playlist table.
        """
        # Get Bottom Row
        bottom_row = self.tableWidget_archive_replay.rowCount()
        
        # Move it Down
        if self.tableWidget_archive_replay.currentRow() != bottom_row-1:  # Ignore bottom row
            # Take the Row Below
            below_item0 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()+1,0)
            below_item1 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()+1,1)
            below_item2 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()+1,2)
            below_item3 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()+1,3)
            below_item4 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()+1,4)
            below_item5 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()+1,5)
            below_item6 = self.tableWidget_archive_replay.cellWidget(self.tableWidget_archive_replay.currentRow()+1,6).currentIndex()
            below_item7 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()+1,7)
            below_item8 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow()+1,8)
            
            # Take the Current Row
            current_item0 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),0)
            current_item1 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),1)
            current_item2 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),2)
            current_item3 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),3)
            current_item4 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),4)
            current_item5 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),5)
            current_item6 = self.tableWidget_archive_replay.cellWidget(self.tableWidget_archive_replay.currentRow(),6).currentIndex()
            current_item7 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),7)
            current_item8 = self.tableWidget_archive_replay.takeItem(self.tableWidget_archive_replay.currentRow(),8)
            
            # Set the Current Row
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),0,below_item0)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),1,below_item1)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),2,below_item2)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),3,below_item3)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),4,below_item4)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),5,below_item5)
            self.tableWidget_archive_replay.cellWidget(self.tableWidget_archive_replay.currentRow(),6).setCurrentIndex(below_item6)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),7,below_item7)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow(),8,below_item8)
            
            # Set the Row Above
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()+1,0,current_item0)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()+1,1,current_item1)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()+1,2,current_item2)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()+1,3,current_item3)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()+1,4,current_item4)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()+1,5,current_item5)
            self.tableWidget_archive_replay.cellWidget(self.tableWidget_archive_replay.currentRow()+1,6).setCurrentIndex(current_item6)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()+1,7,current_item7)
            self.tableWidget_archive_replay.setItem(self.tableWidget_archive_replay.currentRow()+1,8,current_item8)
            
            # Change the Selected Row               
            self.tableWidget_archive_replay.setCurrentCell(self.tableWidget_archive_replay.currentRow()+1,0)
            
            # Resize
            self.tableWidget_archive_replay.resizeRowsToContents()    
            
    def _slotArchiveReplayStartClicked(self):
        """ Sends message to HIPRFISR to start replaying the archive playlist.
        """     
        # Send Stop Message to the HIPRFISR (Flow Graph Currently Running: Stopping)
        if self.pushButton_archive_replay_start.text() == "Stop":
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Stop Archive Playlist', Parameters = '')
            
            # Toggle the Text
            self.pushButton_archive_replay_start.setText("Start")      
            
            # Update the Status Label
            self.label_archive_replay_status.setVisible(False)
            
            # Update the Status Dialog
            # ~ self.status_dialog.tableWidget_status_results.item(3,0).setText("Not Running")
            
        # Reset to Last Known Flow Graph Configuration (Flow Graph Currently Stopped: Starting)
        elif self.pushButton_archive_replay_start.text() == "Start":       
                    
            # Cycle Through Each Tab and Collect the Values
            all_file_list = []
            all_frequency_list = []
            all_sample_rate_list = []
            all_format_list = []
            all_channel_list = []
            all_gain_list = []
            all_duration_list = []
            for n in range(0,self.tableWidget_archive_replay.rowCount()): 
                # Get File Details
                get_folder = str(self.tableWidget_archive_replay.item(n,9).text()) + '/'
                all_file_list.append(get_folder + str(self.tableWidget_archive_replay.item(n,0).text()))
                all_frequency_list.append(str(self.tableWidget_archive_replay.item(n,3).text()))
                all_sample_rate_list.append(str(self.tableWidget_archive_replay.item(n,4).text()))
                all_format_list.append(str(self.tableWidget_archive_replay.item(n,5).text()))
                all_channel_list.append(str(self.tableWidget_archive_replay.cellWidget(n,6).currentText()))
                all_gain_list.append(str(self.tableWidget_archive_replay.item(n,7).text()))
                all_duration_list.append(str(self.tableWidget_archive_replay.item(n,8).text()))
                
            # Only Replay Complex Float 32 Files
            for n in all_format_list:
                if n != "Complex Float 32":
                    self.errorMessage("Error: Only Complex Float 32 files are supported.") 
                    return
            
            # Get Repeat Checkbox Value
            get_repeat = self.checkBox_archive_replay_repeat.isChecked()
            
            # Choose Replay Flow Graph from Hardware Type
            flow_graph = ""
            if self.dashboard_settings_dictionary['hardware_archive'] == "Computer":
                flow_graph = ""  # Error            
            elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP X310":
                flow_graph = "archive_replay_x310"
            elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B210":
                flow_graph = "archive_replay_b210"
            elif self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
                flow_graph = "archive_replay_hackrf"       
            elif self.dashboard_settings_dictionary['hardware_archive'] == "RTL2832U":
                flow_graph = ""  # Error
            elif self.dashboard_settings_dictionary['hardware_archive'] == "802.11x Adapter":
                flow_graph = ""  # Error
            elif self.dashboard_settings_dictionary['hardware_archive'] == "USRP B205mini":
                flow_graph = "archive_replay_b210"
            elif self.dashboard_settings_dictionary['hardware_archive'] == "LimeSDR":
                flow_graph = "archive_replay_limesdr"
            elif self.dashboard_settings_dictionary['hardware_archive'] == "bladeRF":
                flow_graph = "archive_replay_bladerf"
            elif self.dashboard_settings_dictionary['hardware_archive'] == "Open Sniffer":
                flow_graph = ""  # Error                
                            
            # Send "Start Archive Playlist" Message to the HIPRFISR    
            if len(flow_graph) > 0:
                
                # Hardware IP Address
                get_ip_address = self.dashboard_settings_dictionary['hardware_ip_archive']
                
                # Hardware Serial                
                if len(self.dashboard_settings_dictionary['hardware_serial_archive']) > 0:
                    if self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
                        get_serial = self.dashboard_settings_dictionary['hardware_serial_archive']
                    else:
                        get_serial = 'serial=' + self.dashboard_settings_dictionary['hardware_serial_archive']                               
                else:
                    if self.dashboard_settings_dictionary['hardware_archive'] == "HackRF":
                        get_serial = ""
                    else:
                        get_serial = "False"  
                
                self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Start Archive Playlist', Parameters = [flow_graph, all_file_list, all_frequency_list, all_sample_rate_list, all_format_list, all_channel_list, all_gain_list, all_duration_list, get_repeat, get_ip_address, get_serial])  
                    
                # Toggle the Text       
                self.pushButton_archive_replay_start.setText("Stop") 
                
                # Update the Status Label
                self.label_archive_replay_status.setVisible(True)
                
                # Update the Status Dialog
                # ~ self.status_dialog.tableWidget_status_results.item(3,0).setText("Running Multi-Stage Attack...")
            
            # Error
            else:
                msgBox = MyMessageBox(my_text = "  Choose a valid hardware type.", width=240, height=40)
                msgBox.exec_() 
                
    def _slotArchivePlaylistFinished(self):
        """ Changes the pushbuttons and labels upon receiving a message from the other component.
        """     
        # Change the Pushbuttons and Labels
        self.pushButton_archive_replay_start.setText("Start")  
        self.label_archive_replay_status.setVisible(False)
        
        # Update the Status Dialog
        self.status_dialog.tableWidget_status_results.item(3,0).setText("Not Running")
        
    def _slotArchiveListWidgetDoubleClicked(self):
        """ Adds the IQ file to the replay table when double clicked in the list widget.
        """
        # Add Only on Replay
        if self.tabWidget_archive.currentIndex() == 1:
            self._slotArchiveReplayAddClicked()
            
    def _slotMenuFileExitClicked(self):
        """ Exits FISSURE
        """
        # Same as hitting the 'X'
        self.closeEvent(QtGui.QCloseEvent)
        
    def _slotMenuLimeUtilUpdateClicked(self):
        """ Runs 'LimeUtil --update' to fix Gateware version mismatch issues.
        """
        # Issue the Command
        proc = subprocess.Popen('gnome-terminal -- LimeUtil --update &', shell=True)
        
    def _slotMenuBaudlineClicked(self):
        """ Opens baudline - the time-frequency browser designed for scientific visualization of the spectral domain.
        """
        # Run the Executable
        baudline_command = os.path.expanduser("~/Installed_by_FISSURE/baudline_1.08_linux_x86_64/baudline")          
        command_text = 'gnome-terminal -- ' + baudline_command + ' &'
        proc = subprocess.Popen(command_text, shell=True)
        
    def _slotMenuURH_Clicked(self):
        """ Opens Universal Radio Hacker.
        """
        # Issue the Command
        command_text = 'gnome-terminal -- urh &'
        proc = subprocess.Popen(command_text, shell=True)
        
    def _slotMenu4G_IMSI_CatcherClicked(self):
        """ Runs 'start_sniffing.py' to sniff for towers, mimic a tower, and print IMSIs for phones joining the network.
        """
        # Open the Band Chooser Dialog
        new_label_text = "Choose 4G Band"
        new_items = ['2', '3', '4', '5', '7', '12', '13', '14', '17', '20', '25', '26', '29', '30', '40', '41', '46', '48', '66', '71']
        chooser_dlg = MiscChooser(parent=self, label_text=new_label_text, chooser_items=new_items)
        chooser_dlg.show()
        chooser_dlg.exec_() 
        
        # Run the Script
        get_value = chooser_dlg.return_value
        if len(get_value) > 0:             
            script_location = os.path.dirname(os.path.realpath(__file__)) + "/Tools/IMSI-Catcher_4G/"   
            cell_search_binary_location = os.path.expanduser("~/Installed_by_FISSURE/srsRAN/build/lib/examples/cell_search")    
            command_text = 'gnome-terminal -- python3 ' + script_location + 'start_sniffing.py -b ' + get_value + ' ' + cell_search_binary_location + ' &'
            proc = subprocess.Popen(command_text, cwd=script_location, shell=True)
        
    def _slotPD_SnifferNetcatClicked(self):
        """ Start a netcat listener in a new terminal.
        """
        # Get the Values
        get_tcp_udp = str(self.comboBox_pd_sniffer_netcat.currentText())
        get_ip = str(self.textEdit_pd_sniffer_netcat_ip.toPlainText())
        get_port = str(self.textEdit_pd_sniffer_netcat_port.toPlainText())
        
        # Issue the Command
        if get_tcp_udp == "TCP":
            command_text = 'gnome-terminal -- nc -l ' + get_ip + ' ' + get_port + ' &'
        else:
            command_text = 'gnome-terminal -- nc -lu ' + get_ip + ' ' + get_port + ' &'
        proc = subprocess.Popen(command_text, shell=True)
        
    def _slotMenuInspectrumClicked(self):
        """ Opens Inspectrum.
        """
        # Issue the Command
        command_text = 'gnome-terminal -- inspectrum &'
        proc = subprocess.Popen(command_text, shell=True)
        
    def _slotPD_DissectorsUpdateAllClicked(self):
        """ Copies the contents of the /FISSURE/Dissectors folder to the ~/.config/wireshark/plugins folder.
        """
        # Directories
        dissector_source = os.path.dirname(os.path.realpath(__file__)) + "/Dissectors/"
        dissector_dest = os.path.expanduser("~/.config/wireshark/plugins")
        
        # Issue the Command
        os.system('cp -R ' + dissector_source + ' ' + dissector_dest)
        self.errorMessage("Dissectors copied from \"/FISSURE/Dissectors\" to \"~/.config/wireshark/plugins\"") 
        
    def _slotPD_DissectorRemoveClicked(self):
        """ Removes the dissector lua file and entry from the library for the packet type.
        """
        # Get Values
        get_protocol = str(self.comboBox_pd_dissectors_protocol.currentText())
        get_packet_type = str(self.comboBox_pd_dissectors_packet_type.currentText())
        get_dissector = str(self.comboBox_pd_dissectors_existing_dissectors.currentText())
        
        # Remove 
        if len(get_protocol) > 0 and len(get_packet_type) > 0 and len(get_dissector) > 0:
            if get_dissector != "None":
                dissector_source = os.path.dirname(os.path.realpath(__file__)) + "/Dissectors/"
                os.system('rm ' + dissector_source + get_dissector)
            new_dissector = [None, None]
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Add To Library', Parameters = [get_protocol, get_packet_type, [], [], [], [], [], [], new_dissector])   
    
    def _slotMenuOpenCPN_Clicked(self):
        """ Launches OpenCPN.
        """
        # Issue the Command
        command_text = 'gnome-terminal -- opencpn &'
        proc = subprocess.Popen(command_text, shell=True)
        
    def _slotMenuAis_rxClicked(self):
        """ Launches ais_rx.
        """
        # Issue the Command
        ais_rx_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Custom_Blocks/maint-3.8/gr-ais-master/apps/ais_rx"
        command_text = 'gnome-terminal -- python3 "' + ais_rx_filepath  + '" &'
        proc = subprocess.Popen(command_text, shell=True) 
        
    def _slotMenuProtocolSpreadsheetClicked(self):
        """ Opens the Protocols_and_More.xlsx spreadsheet.
        """
        # Issue the Command
        spreadsheet_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Help/Protocols_and_More.xlsx"
        command_text = 'libreoffice ' + spreadsheet_filepath + ' &'
        proc = subprocess.Popen(command_text, shell=True)    
        
    def _slotPD_SnifferProtocolsChanged(self):
        """ Updates the packet type combobox in the Sniffer tab.
        """
        # Get Protocol
        get_protocol = str(self.comboBox_pd_sniffer_protocols.currentText())

        # Get the Packet Type
        get_packet_type = getPacketTypes(self.pd_library, get_protocol)
        
        # Clear the ComboBox
        self.comboBox_pd_sniffer_packet_type.clear()
            
        # Fill the ComboBox
        self.comboBox_pd_sniffer_packet_type.addItems(get_packet_type)
        
    def _slotPD_SnifferPacketTypeChanged(self):
        """ Updates the SUB & UDP Port to match the dissector in the library.
        """
        # Get Protocol and Packet Type
        get_protocol = str(self.comboBox_pd_sniffer_protocols.currentText())
        get_packet_type = str(self.comboBox_pd_sniffer_packet_type.currentText())
        
        # Find Dissector Port
        if len(get_packet_type) > 0:
            get_dissectors = getDissector(self.pd_library, get_protocol, get_packet_type)['Filename']
            
            # No Dissector
            if get_dissectors == None:
                self.textEdit_pd_sniffer_sub_udp_port.setPlainText("55555")  
                self.textEdit_pd_sniffer_test_port.setPlainText("55555")  
            
            # Dissector Found
            else:
                get_port = getDissector(self.pd_library, get_protocol, get_packet_type)['Port']
                if get_port == "None":
                    self.textEdit_pd_sniffer_sub_udp_port.setPlainText("55555")    
                    self.textEdit_pd_sniffer_test_port.setPlainText("55555")    
                else:
                    self.textEdit_pd_sniffer_sub_udp_port.setPlainText(str(get_port))    
                    self.textEdit_pd_sniffer_test_port.setPlainText(str(get_port))    
    
    def _slotArchivePlaylistPosition(self, pos):
        """ Highlights the active archive playlist flow graph.
        """
        # Select Table Row
        if len(pos) > 0:
            self.tableWidget_archive_replay.selectRow(int(pos))
            
    def _slotPD_SnifferTestFolderClicked(self):
        """ Selects a folder for listing more crafted packets in the sniffer test listbox.
        """
        # Choose Folder
        get_dir = str(QtWidgets.QFileDialog.getExistingDirectory(self, "Select Directory"))
        
        # Add Directory to the Combobox       
        if len(get_dir) > 0:            
            self.comboBox_pd_sniffer_test_folders.addItem(get_dir)      
            self.comboBox_pd_sniffer_test_folders.setCurrentIndex(self.comboBox_pd_sniffer_test_folders.count()-1)
        
    def _slotPD_SnifferTestFoldersChanged(self):
        """ Updates the list of crafted packet files in the sniffer test listbox.
        """
        # Load the Files in the Listbox
        get_dir = str(self.comboBox_pd_sniffer_test_folders.currentText())
        if get_dir != "":
            self.listWidget_pd_sniffer_test_files.clear()
            file_names = []
            for fname in os.listdir(get_dir):
                if os.path.isfile(get_dir+"/"+fname):
                    file_names.append(fname)
            file_names = sorted(file_names)
            for n in file_names:
                self.listWidget_pd_sniffer_test_files.addItem(n)
        
    def _slotPD_SnifferTestSendClicked(self):
        """ Sends the file data to the Sniffer UDP port using Netcat.
        """
        # Get the Values
        get_file_path = str(self.comboBox_pd_sniffer_test_folders.currentText()) + "/" + str(self.listWidget_pd_sniffer_test_files.currentItem().text())
        get_port = str(self.textEdit_pd_sniffer_test_port.toPlainText())
        
        # Issue the Command
        command_text = 'cat "' + get_file_path + '" | nc -u 127.0.0.1 ' + get_port
        proc = subprocess.Popen(command_text, shell=True)
            
    def _slotPD_SnifferFlowGraphFinished(self, flow_graph_type):
        """ Flow graph finished message returned from FGE.
        """
        # Enable the Buttons
        self.pushButton_pd_sniffer_stream.setText("Sniffer - Stream")
        self.pushButton_pd_sniffer_tagged_stream.setText("Sniffer - Tagged Str.")
        self.pushButton_pd_sniffer_msg_pdu.setText("Sniffer - Msg/PDU")
        
        # if flow_graph_type == "Stream":
            # self.pushButton_pd_sniffer_stream.setEnabled(True)
        # elif flow_graph_type == "Tagged Stream":
            # self.pushButton_pd_sniffer_tagged_stream.setEnabled(True)
        # elif flow_graph_type == "Message/PDU":            
            # self.pushButton_pd_sniffer_msg_pdu.setEnabled(True)
            
        self.pushButton_pd_sniffer_stream.setEnabled(True)
        self.pushButton_pd_sniffer_tagged_stream.setEnabled(True)
        self.pushButton_pd_sniffer_msg_pdu.setEnabled(True)            
    
    def _slotPD_SnifferFlowGraphStarted(self, flow_graph_type):
        """ Flow graph started message returned from FGE.
        """
        # Enable the Buttons
        if flow_graph_type == "Stream":
            self.pushButton_pd_sniffer_stream.setEnabled(True)
        elif flow_graph_type == "Tagged Stream":
            self.pushButton_pd_sniffer_tagged_stream.setEnabled(True)
        elif flow_graph_type == "Message/PDU":
            self.pushButton_pd_sniffer_msg_pdu.setEnabled(True)
        
    def _slotMenuGrgsm_scannerClicked(self):
        """ Opens a terminal with the grgsm_scanner command from gr-gsm for scanning GSM bands.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        # ~ command_text = 'gnome-terminal -- /bin/bash -c "grgsm_scanner -b PCS1900 -g 70 && echo "Done" && read"'  # bash and read keep the terminal open after running
        command_text = 'gnome-terminal -- ' + expect_script_filepath + ' "grgsm_scanner -b PCS1900 -g 70"'  # let the user choose band, hardware, gain
        proc = subprocess.Popen(command_text, shell=True)
        
    def _slotMenuKalibrateClicked(self):
        """ Opens a terminal with the kal command for calibrating RTL-SDRs and HackRF.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        kalibrate_directory = os.path.expanduser("~/Installed_by_FISSURE/kalibrate-rtl/src/")        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "./kal -h"', cwd=kalibrate_directory, shell=True)  
        
    def _slotMenuTowerSearchClicked(self):
        """ Opens a terminal for searching for eNodeB information using the srsRAN cell search binary.
        """
        # Open LTe Band List
        band_list_dir = os.path.dirname(os.path.realpath(__file__)) + "/Tools/LTE_Tower_Search"
        proc=subprocess.Popen('gedit lte_bands.txt &', cwd=band_list_dir, shell=True) 
          
        # Issue the Command
        cell_search_binary_location = os.path.expanduser("~/Installed_by_FISSURE/srsRAN/build/lib/examples/cell_search")
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        lte_script_directory = os.path.dirname(os.path.realpath(__file__)) + "/Tools/LTE_Tower_Search"        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "python3 tower_search_part1.py ' + cell_search_binary_location + ' [2,4]"', cwd=lte_script_directory, shell=True) 
             
    def _slotMenuTowerSearchPart2Clicked(self):
        """ Opens a terminal for finding the LTE MCC/MNC and TAC values for a dictionary result provided by Tower Search Part 1.
        """         
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        lte_script_directory = os.path.dirname(os.path.realpath(__file__)) + "/Tools/LTE_Tower_Search"        
        output_example = """\\\"{\'MHz\': \'2125.0\', \'EARFCN\': \'2100\', \'PHYID\': \'276\', \'PRB\': \'50\', \'ports\': \'4\', \'PSS power\': \'-28.9 dBm\'}\\\" """
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "python3 tower_search_part2.py ' + output_example + '"', cwd=lte_script_directory, shell=True) 
                                 
    def checkFrequencyBounds(self, get_frequency, get_hardware, get_daughterboard):
        """ Returns True or False if the frequency is within the bounds of the hardware.
        """
        if get_hardware == "Computer":
            # Frequency Limits
            if (get_frequency >= 1) and (get_frequency <= 6000):
                return True  
                         
        elif get_hardware == "USRP X310":            
            # Frequency Limits
            if get_daughterboard == "CBX":
                if (get_frequency >= 1200) and (get_frequency <= 6000):
                    return True
            elif get_daughterboard == "SBX":
                if (get_frequency >= 400) and (get_frequency <= 4400):
                    return True                
            elif get_daughterboard == "UBX":
                if (get_frequency >= 10) and (get_frequency <= 6000):
                    return True                       
            elif get_daughterboard == "WBX":
                if (get_frequency >= 25) and (get_frequency <= 2200):
                    return True                       
                   
        elif get_hardware == "USRP B210":
            # Frequency Limits
            if (get_frequency >= 70) and (get_frequency <= 6000):
                return True        
                
        elif get_hardware == "HackRF":
            # Frequency Limits
            if (get_frequency >= 1) and (get_frequency <= 6000):
                return True              
                        
        elif get_hardware == "RTL2832U":
            # Frequency Limits
            if (get_frequency >= 64) and (get_frequency <= 1700):
                return True              
            
        elif get_hardware == "802.11x Adapter":
            # Frequency Limits
            if (get_frequency >= 1) and (get_frequency <= 6000):
                return True              
            
        elif get_hardware == "USRP B205mini":
            # Frequency Limits
            if (get_frequency >= 70) and (get_frequency <= 6000):
                return True                         
            
        elif get_hardware == "LimeSDR":
            # Frequency Limits
            if (get_frequency >= 1) and (get_frequency <= 3800):
                return True              
            
        elif get_hardware == "bladeRF":
            # Frequency Limits
            if (get_frequency >= 280) and (get_frequency <= 3800):
                return True  
                
        elif get_hardware == "Open Sniffer":
            # Frequency Limits
            if (get_frequency >= 1) and (get_frequency <= 6000):
                return True                          
        
        # Not in Bounds
        return False
        
    def _slotLibraryAddDataTypeChanged(self):
        """ Changes the stacked widget for adding different types of protocol data to the library.
        """
        # Change Index
        get_type = str(self.comboBox_library_pd_data_type.currentText())
        if get_type == "Modulation Type":
            self.label_library_add.setText("Add New Modulation Type to Library")
            self.stackedWidget_library_pd.setCurrentIndex(1)            
        elif get_type == "Packet Type":
            self.label_library_add.setText("Add New Packet Type to Library")
            self.stackedWidget_library_pd.setCurrentIndex(2)
        elif get_type == "Signal of Interest":
            self.label_library_add.setText("Add New Signal of Interest to Library")
            self.stackedWidget_library_pd.setCurrentIndex(3)
        elif get_type == "Statistics":
            self.label_library_add.setText("Add New Statistics to Library")
            self.stackedWidget_library_pd.setCurrentIndex(4)
        elif get_type == "Demodulation Flow Graph":
            self.label_library_add.setText("Add New Demodulation Flow Graph to Library")
            self.stackedWidget_library_pd.setCurrentIndex(5)
            
            # Populate Demodulation Flow Graph Modulation Types         
            get_protocol = str(self.comboBox_library_pd_protocol.currentText())
            if len(get_protocol) > 0:
                get_modulation_types = getModulations(self.pd_library, get_protocol)
                if len(get_modulation_types) > 0:
                    self.comboBox_library_pd_modulation_types.addItems(get_modulation_types)    
                    
        elif get_type == "Attack":
            self._slotAttackImportProtocolChanged()
            self.label_library_add.setText("Add New Attack to Library")
            self.stackedWidget_library_pd.setCurrentIndex(6)
                        
    def _slotMenuRetrogramRtlSdrClicked(self):
        """ Opens a terminal with an example command for retrogram-rtlsdr which scans frequencies for RTL devices.
        """         
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        retrogram_directory = os.path.expanduser("~/Installed_by_FISSURE/retrogram-rtlsdr-master")       
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "./retrogram-rtlsdr --rate 2e6 --freq 100e6 --step 1e5"', cwd=retrogram_directory, shell=True) 
    
    def _slotMenuRTLSDR_AirbandClicked(self):
        """ Opens a terminal with an example command for RTLSDR-Airband. Needs a configuration file.
        """         
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        airband_directory = os.path.expanduser("~/Installed_by_FISSURE/RTLSDR-Airband")       
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "rtl_airband -h"', cwd=airband_directory, shell=True)
        
    def _slotMenuRadioReferenceDatabaseClicked(self):
        """ Opens a browser to radioreference.com.
        """
        os.system("sensible-browser https://www.radioreference.com/apps/db/ &")
        
    def _slotMenuSpektrumClicked(self):
        """ Launches Spektrum for RTL devices.
        """
        # Issue the Command
        spektrum_filepath = os.path.expanduser("~/Installed_by_FISSURE/spektrum/spektrum")
        command_text = 'gnome-terminal -- "' + spektrum_filepath + '" &'
        proc = subprocess.Popen(command_text, shell=True) 
        
    def _slotMenuRTL_TestClicked(self):
        """ Runs rtl_test command to detect hardware.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script"       
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "rtl_test -t"', shell=True)
        
    def _slotMenuSDR_TrunkClicked(self):
        """ Launches SDRTrunk.
        """
        # Issue the Command
        sdr_trunk_filepath = os.path.expanduser("~/Installed_by_FISSURE/sdr-trunk-linux-x86_64-v0.5.0-alpha6/bin/sdr-trunk")
        command_text = 'gnome-terminal -- "' + sdr_trunk_filepath + '" &'
        proc = subprocess.Popen(command_text, shell=True) 
        
    def _slotMenuAudacityClicked(self):
        """ Launches Audacity.
        """
        # Issue the Command
        command_text = 'gnome-terminal -- "audacity" &'
        proc = subprocess.Popen(command_text, shell=True)      
        
    def _slotIQ_MorseCodeClicked(self):
        """ Auto-detects Morse Code from the magnitude of an IQ file and returns the text.
        """
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0:
            
            # Get the Number of Samples
            try:
                start_sample = int(self.textEdit_iq_start.toPlainText())
                end_sample = int(self.textEdit_iq_end.toPlainText())
                num_samples = end_sample - start_sample + 1
            except:
                return
            
            # Do Nothing if Bad Range
            if num_samples < 0:
                return
        
            # Get the Size of Each Sample in Bytes   
            complex_multiple = 1  
            if get_type == "Complex Float 32":
                complex_multiple = 2
                sample_size = 4
                num_samples = complex_multiple * num_samples               
            elif get_type == "Float/Float 32":
                sample_size = 4
            elif get_type == "Short/Int 16":
                sample_size = 2
            elif get_type == "Int/Int 32":
                sample_size = 4
            elif get_type == "Byte/Int 8":
                sample_size = 1
            elif get_type == "Complex Int 16":
                complex_multiple = 2
                sample_size = 2
                num_samples = complex_multiple * num_samples    
            elif get_type == "Complex Int 8":
                sample_size = 1
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
            elif get_type == "Complex Float 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
            elif get_type == "Complex Int 64":
                sample_size = 8
                complex_multiple = 2
                num_samples = complex_multiple * num_samples                  
                
            # Check the Range
            if (num_samples*sample_size > number_of_bytes) or (complex_multiple*end_sample*sample_size > number_of_bytes) or (start_sample < 1):
                print("Out of range.")
                return            
            
            # Read the Data 
            filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
            file = open(filepath,"rb")                          # Open the file
            if "Complex" in get_type:
                file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
            else:
                file.seek((start_sample-1) * sample_size)       # Point to the starting sample
            plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
            file.close()
            
            # Format the Data
            if get_type == "Complex Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Float/Float 32":
                plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
            elif get_type == "Short/Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
            elif get_type == "Int/Int 32":
                plot_data_formatted = struct.unpack(num_samples*'i', plot_data)
            elif get_type == "Byte/Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
            elif get_type == "Complex Int 16":
                plot_data_formatted = struct.unpack(num_samples*'h', plot_data)                
            elif get_type == "Complex Int 8":
                plot_data_formatted = struct.unpack(num_samples*'b', plot_data)                
            elif get_type == "Complex Float 64":
                plot_data_formatted = struct.unpack(num_samples*'d', plot_data)                
            elif get_type == "Complex Int 64":
                plot_data_formatted = struct.unpack(num_samples*'l', plot_data)                
                
            # Get I/Q Data
            if "Complex" in get_type:                
                I_squared = [float(i)**2 for i in plot_data_formatted[::2]]
                Q_squared = [float(q)**2 for q in plot_data_formatted[1::2]]

                # Calculate AM
                AM = [math.sqrt(I_squared[x] + Q_squared[x]) for x in range(len(I_squared))]
                
            else:
                AM = [math.sqrt(i**2) for i in plot_data_formatted]
                
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)  
            self.iq_matplotlib_widget.axes.plot(AM,'b',linewidth=1)   
            self.iq_matplotlib_widget.applyLabels("Magnitude",'Samples','Amplitude (LSB)',None,None) 

            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
            #self.iq_matplotlib_widget.draw()
            
            # Get the Magnitude Rising and Falling Edges
            threshold = float(self.dashboard_settings_dictionary['morse_code_amplitude_threshold']) #0.5  # Adjust magnitude threshold accordingly
            state = 0
            edges = []
            for n in range(0,len(AM)):
                if (AM[n] > threshold) and (state == 0):
                    edges.append(n)
                    state = 1
                elif (AM[n] < threshold) and (state == 1):
                    edges.append(n)
                    state = 0
                    
            # Find Dit/Dah Width
            error_tolerance = float(self.dashboard_settings_dictionary['morse_code_error_tolerance'])  # 0.05
            print("Edge Locations: " + str(edges))
            if len(edges) > 5:  # Any number demonstrating consistency 
                edge_diff = []
                for n in range(1,len(edges)):
                    edge_diff.append(edges[n] - edges[n-1])
            
                unique_widths = sorted(set(edge_diff))
                print("Edge Widths: " + str(edge_diff))
                print("Unique Widths: " + str(unique_widths))
                
                if len(unique_widths) > 1:
                    dit = None
                    for n in range(0,len(unique_widths)):
                        temp_dit = unique_widths[n]
                        for m in range(1,len(unique_widths)):
                            if (temp_dit*3 > unique_widths[m]*(1-error_tolerance)) and (temp_dit*3 < unique_widths[m]*(1+error_tolerance)):  # +/- 5%
                                dit = temp_dit
                        if dit:
                            break
                    
                    # Spell Message
                    morse_code = ""
                    for n in range(1,len(edges)-1,2):
                        # Note: People have a tendency to implement the space for the same letter, between letters, and words differently than the International Morse Code method. Adjust accordingly.
                        same_letter_spacing = float(self.dashboard_settings_dictionary['morse_code_same_letter_spacing'])     #1 # 1 - I.M.C.
                        between_letter_spacing = float(self.dashboard_settings_dictionary['morse_code_between_letter_spacing'])  #2 # 3 - I.M.C.
                        between_word_spacing = float(self.dashboard_settings_dictionary['morse_code_between_word_spacing'])    #6 # 7 - I.M.C.
                        
                        # '10'
                        if (edges[n]-edges[n-1] > dit*(1-error_tolerance)) and (edges[n]-edges[n-1] < dit*(1+error_tolerance)) and (edges[n+1]-edges[n] > same_letter_spacing* dit*(1-error_tolerance)) and (edges[n+1]-edges[n] < same_letter_spacing*dit*(1+error_tolerance)):
                            morse_code = morse_code + '.'
                            
                        # '1 [next letter]'
                        elif (edges[n]-edges[n-1] > dit*(1-error_tolerance)) and (edges[n]-edges[n-1] < dit*(1+error_tolerance)) and (edges[n+1]-edges[n] > between_letter_spacing*dit*(1-error_tolerance)) and (edges[n+1]-edges[n] < between_letter_spacing*dit*(1+error_tolerance)):
                            morse_code = morse_code + '. '
                        
                        # '1110'
                        elif (edges[n]-edges[n-1] > 3*dit*(1-error_tolerance)) and (edges[n]-edges[n-1] < 3*dit*(1+error_tolerance)) and (edges[n+1]-edges[n] > same_letter_spacing*dit*(1-error_tolerance)) and (edges[n+1]-edges[n] < same_letter_spacing*dit*(1+error_tolerance)):
                            morse_code = morse_code + '-'
                            
                        # '111 [next letter]'
                        elif (edges[n]-edges[n-1] > 3*dit*(1-error_tolerance)) and (edges[n]-edges[n-1] < 3*dit*(1+error_tolerance)) and (edges[n+1]-edges[n] > between_letter_spacing*dit*(1-error_tolerance)) and (edges[n+1]-edges[n] < between_letter_spacing*dit*(1+error_tolerance)):
                            morse_code = morse_code + '- '
                            
                        # '1 [next word]'
                        elif (edges[n]-edges[n-1] > dit*(1-error_tolerance)) and (edges[n]-edges[n-1] < dit*(1+error_tolerance)) and (edges[n+1]-edges[n] > between_word_spacing*dit*(1-error_tolerance)) and (edges[n+1]-edges[n] < between_word_spacing*dit*(1+error_tolerance)):
                            morse_code = morse_code + '.|'
                            
                        # '111 [next word]'
                        elif (edges[n]-edges[n-1] > 3*dit*(1-error_tolerance)) and (edges[n]-edges[n-1] < 3*dit*(1+error_tolerance)) and (edges[n+1]-edges[n] > between_word_spacing*dit*(1-error_tolerance)) and (edges[n+1]-edges[n] < between_word_spacing*dit*(1+error_tolerance)):
                            morse_code = morse_code + '-|'
                            
                    # Last Dit/Dah
                    if (edges[-1] - edges[-2] > dit*(1-error_tolerance)) and (edges[-1] - edges[-2] < dit*(1+error_tolerance)):
                        morse_code = morse_code + '.'
                    else:
                        morse_code = morse_code + '-'
                              
                    print("\n" + morse_code)
                    
                    # Convert to English
                    get_text = self.morseToEnglish(morse_code)
                    print(get_text + '\n')
                    
                    # Open a MessageBox
                    self.errorMessage(get_text)
                    
    def morseToEnglish(self, message):
        """ Converts dits and dahs to English.
        """
        # Dictionary representing the morse code chart
        MORSE_CODE_DICT = { 'A':'.-', 'B':'-...',
            'C':'-.-.', 'D':'-..', 'E':'.',
            'F':'..-.', 'G':'--.', 'H':'....',
            'I':'..', 'J':'.---', 'K':'-.-',
            'L':'.-..', 'M':'--', 'N':'-.',
            'O':'---', 'P':'.--.', 'Q':'--.-',
            'R':'.-.', 'S':'...', 'T':'-',
            'U':'..-', 'V':'...-', 'W':'.--',
            'X':'-..-', 'Y':'-.--', 'Z':'--..',
            '1':'.----', '2':'..---', '3':'...--',
            '4':'....-', '5':'.....', '6':'-....',
            '7':'--...', '8':'---..', '9':'----.',
            '0':'-----', ', ':'--..--', '.':'.-.-.-',
            '?':'..--..', '/':'-..-.', '-':'-....-',
            '(':'-.--.', ')':'-.--.-','!':'-.-.--'}
            
        # Replace '|' with Double Space
        message = message.replace('|','  ')
            
        # Extra Space Added at the End to Access the Last Morse Code
        message += ' '

        decipher = ''
        citext = ''
        for letter in message:
            # Checks for Space
            if (letter != ' '):
                # Counter to Keep Track of Space
                i = 0

                # Storing Morse Code of a Single Character
                citext += letter

            # In Case of Space
            else:
                # If i = 1 that Indicates a New Character
                i += 1

                # If i = 2 that Indicates a New Word
                if (i == 2):
                    # Adding Space to Separate Words
                    decipher += ' '
                else:
                    # Accessing the Keys using their Values (Reverse of Encryption)
                    decipher += list(MORSE_CODE_DICT.keys())[list(MORSE_CODE_DICT.values()).index(citext)]
                    citext = ''

        return decipher            
        
    def _slotMenuSignalIdentificationGuideClicked(self):
        """ Opens the Signal Identification Guide website in a browser.
        """
        os.system("sensible-browser https://www.sigidwiki.com/wiki/Signal_Identification_Guide &")
        
    def _slotMenuSondeHubRadiosondeTrackerClicked(self):
        """ Opens the SondeHub Radiosonde Tracker website in a browser.
        """
        os.system("sensible-browser https://tracker.sondehub.org/ &")
        
    def _slotMenuCellmapperClicked(self):
        """ Opens cellmapper.net website in a browser.
        """
        os.system("sensible-browser https://cellmapper.net/ &")
        
    def _slotMenuAirLinkClicked(self):
        """ Opens Ubiquiti airLink tool in a browser. Great for line of sight mapping between two points.
        """
        os.system("sensible-browser https://link.ui.com/ &")
        
    def _slotMenuFCC_ID_LookupClicked(self):
        """ Opens fccid.io in a browser.
        """
        os.system("sensible-browser https://fccid.io/ &")
        
    def _slotMenuStandaloneMorseGenClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/MorseGen.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")  
        
    def _slotIQ_FunctionsSettingsClicked(self):
        """ Opens the Options dialog to change the settings for the IQ functions.
        """
        self._slotMenuOptionsClicked()
    
    def _slotIQ_FunctionsLeftClicked(self):
        """ Decreases the index for the stackedwidget of IQ functions.
        """
        # Move Page to the Left
        new_index = self.stackedWidget_IQ_Functions.currentIndex() - 1
        get_count = self.stackedWidget_IQ_Functions.count()
        
        if new_index < 0:
            self.stackedWidget_IQ_Functions.setCurrentIndex(get_count-1)
        else:
            self.stackedWidget_IQ_Functions.setCurrentIndex(new_index)
            
    def _slotIQ_FunctionsRightClicked(self):
        """ Increases the index for the stackedwidget of IQ functions.
        """
        # Move Page to the Right
        new_index = self.stackedWidget_IQ_Functions.currentIndex() + 1
        get_count = self.stackedWidget_IQ_Functions.count()
        
        if new_index >= get_count:
            self.stackedWidget_IQ_Functions.setCurrentIndex(0)
        else:
            self.stackedWidget_IQ_Functions.setCurrentIndex(new_index)
        
    def _slotIQ_EndLabelClicked(self, event):
        """ Puts the maximum number of samples in the plot range end text edit.
        """
        # Copy Other Label Value
        get_samples = str(self.label_iq_samples.text()).replace('Samples:','').replace(' ','')
        self.textEdit_iq_end.setPlainText(get_samples)
        
    def loadConfiguration(self):
        """ Loads a configuration YAML file with all the FISSURE user settings.
        """
        # Load Settings from YAML File
        filename = os.path.dirname(os.path.realpath(__file__)) + "/YAML/fissure_config.yaml"
        yaml_config_file = open(filename)
        self.dashboard_settings_dictionary = yaml.load(yaml_config_file, yaml.FullLoader)
        yaml_config_file.close()   
        
    def _slotMenuProxmark3_Clicked(self):
        """ Opens a terminal with the command for controlling the Proxmark3.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proxmark3_directory = os.path.expanduser("~/Installed_by_FISSURE/proxmark3/client/")       
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo ./proxmark3 /dev/ttyACM0"', cwd=proxmark3_directory, shell=True)
        
    def _slotMenuProxmark3_CheatsheetClicked(self):
        """ Opens a Proxmark3 cheat sheet in a browser.
        """
        os.system("sensible-browser https://scund00r.com/all/rfid/2018/06/05/proxmark-cheatsheet.html &")
        
    def _slotMenuEarthNullschoolClicked(self):
        """ Opens Earth Nullschool in a browser.
        """
        os.system("sensible-browser https://earth.nullschool.net/ &")
        
    def _slotMenuCUSF_LandingPredictorClicked(self):
        """ Opens CUSF Landing Predictor in a browser.
        """
        os.system("sensible-browser http://predict.habhub.org/ &")
        
    def _slotMenuFlightAwareClicked(self):
        """ Opens the FlightAware live map in a browser.
        """
        os.system("sensible-browser https://flightaware.com/live/map &")
        
    def _slotMenuRadiosondeAutoRxClicked(self):
        """ Opens a terminal with the command for starting radiosonde_auto_rx.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        radiosonde_directory = os.path.expanduser("~/Installed_by_FISSURE/radiosonde_auto_rx/auto_rx/")       
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "python3 auto_rx.py"', cwd=radiosonde_directory, shell=True)        
        
    def _slotMenuRadiosondeAutoRxConfigClicked(self):
        """ Opens the radiosonde_auto_rx configuration file.
        """
        # Open the File
        config_directory = os.path.expanduser("~/Installed_by_FISSURE/radiosonde_auto_rx/auto_rx/station.cfg")
        os.system("gedit " + config_directory + " &")

    def _slotMenuSQ6KXY_RadiosondeTrackerClicked(self):
        """ Opens the SQ6KXY Radiosonde Tracker in a browser.
        """
        os.system("sensible-browser https://radiosondy.info/ &")
        
    def _slotMenuSdrGlutClicked(self):
        """ Opens SdrGlut in a new terminal.
        """
        # Issue the Command
        sdr_glut_directory = os.path.expanduser("~/Installed_by_FISSURE/SdrGlut/")       
        proc=subprocess.Popen('gnome-terminal -- "./sdrglut.x" &', cwd=sdr_glut_directory, shell=True)
        
    def _slotMenuUS_FrequencyAllocationsClicked(self):
        """ Opens the US Frequency Allocations wall chart.
        """
        # Open the File
        us_freq_allocations_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/january_2016_spectrum_wall_chart.pdf" 
        os.system("evince " + us_freq_allocations_filepath + " &")
        
    def _slotMenuCyberChefRecipesClicked(self):
        """ Opens the cyberchef-recipes github page.
        """
        os.system("sensible-browser https://github.com/mattnotmax/cyberchef-recipes &")
        
    def _slotMenuRehexClicked(self):
        """ Opens the Reverse Engineers' Hex Editor (rehex).
        """
        # Issue the Command    
        proc=subprocess.Popen('gnome-terminal -- "rehex" &', shell=True)
        
    def _slotMenuZEPASSD_Clicked(self):
        """ Opens a terminal with the command for running ZEPASSD.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        zepassd_directory = os.path.expanduser("~/Installed_by_FISSURE/zepassd/")       
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "./zepassd --tx-port A:A --rx-port A:A --tx-gain 87 --rx-gain 85 -p 20 foobar"', cwd=zepassd_directory, shell=True)  
        
    def _slotMenuIridiumExtractorClicked(self):
        """ Opens a terminal with a command for recording Iridium bits with iridium-extractor.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        iridium_directory = os.path.dirname(os.path.realpath(__file__)) + "/Custom_Blocks/maint-3.8/gr-iridium-maint-3.8/"
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "iridium-extractor -D 4 examples/hackrf.conf | grep A:OK > ~/output.bits"', cwd=iridium_directory, shell=True)  
                
    def _slotMenuIridiumParserClicked(self):
        """ Opens a terminal with the command to parse the bits created by iridium-extractor.py and prepare it for stats-voc.py to allow audio playback.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        iridium_directory = os.path.dirname(os.path.realpath(__file__)) + "/Custom_Blocks/maint-3.8/gr-iridium-maint-3.8/"
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "python2 iridium-parser.py -p ~/output.bits > ~/output.parsed"', cwd=iridium_directory, shell=True)  
            
    def _slotMenuStatsVocClicked(self):
        """ Opens a terminal with the command to play the audio from the parsed Iridium files. Left-click and right-click on the red dots in each row.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        iridium_toolkit_directory = os.path.expanduser("~/Installed_by_FISSURE/iridium-toolkit/")
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "export PATH=$PATH:' + iridium_toolkit_directory + ' && ./stats-voc.py ~/output.parsed"', cwd=iridium_toolkit_directory, shell=True)  
            
    def _slotMenuIridiumLiveClicked(self):
        """ Opens a terminal for running the iridium-extractor/iridium-parser and piping the output to udp-for-il.py (localhost). Runs IridiumLive and opens a browser to 127.0.0.1:7777.
        """
        # Issue the IridiumLive Command
        iridiumlive_directory = os.path.expanduser("~/Installed_by_FISSURE/linux-x64/")       
        proc=subprocess.Popen('gnome-terminal -- "./IridiumLive" &', cwd=iridiumlive_directory, shell=True)
        
        # Open the Browser
        os.system("sensible-browser http://127.0.0.1:7777/ &")
        
        # Issue the Command for Extractor and Parser
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        iridium_directory = os.path.dirname(os.path.realpath(__file__)) + "/Custom_Blocks/maint-3.8/gr-iridium-maint-3.8/"
        tools_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "iridium-extractor --offline --multi-frame ' + iridium_directory + 'examples/hackrf.conf | ~/Installed_by_FISSURE/iridium-toolkit/iridium-parser.py -p /dev/stdin /dev/stdout | python2 ' + tools_filepath + 'IridiumLive/udp-for-il.py"', cwd=iridium_directory, shell=True) 
        
    def _slotMenuNETATTACK2_Clicked(self):
        """ Opens a terminal and launches NETATTACK2.
        """
        # Issue the Command
        netattack2_directory = os.path.expanduser("~/Installed_by_FISSURE/netattack2/")       
        proc=subprocess.Popen('gnome-terminal -- sudo python2 netattack2.py &', cwd=netattack2_directory, shell=True)
        
    def _slotMenuWifiteClicked(self):
        """ Opens a terminal and launches Wifite.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script"  # Expect is needed because Wifite closes on completion
        wifite2_directory = os.path.expanduser("~/Installed_by_FISSURE/wifite2/")       
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo ./Wifite.py"', cwd=wifite2_directory, shell=True)
        
    def _slotMenuRtl_433_Clicked(self):
        """ Opens a terminal and launches rtl_433.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script"         
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "rtl_433"', shell=True)
        
    def _slotMenuRouterSploitClicked(self):
        """ Opens a terminal and launches RouterSploit.
        """
        # Issue the Command
        routersploit_directory = os.path.expanduser("~/Installed_by_FISSURE/routersploit/")       
        proc=subprocess.Popen('gnome-terminal -- python3 rsf.py &', cwd=routersploit_directory, shell=True)
        
    def _slotMenuExploitDatabaseClicked(self):
        """ Opens ExploitDB in a browser.
        """
        # Open the Browser
        os.system("sensible-browser https://www.exploit-db.com/ &")
        
    def _slotMenuMetasploitClicked(self):
        """ Opens msfconsole in a new terminal.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- msfconsole &', shell=True)      
        
    def _slotMenuMonitor_rtl433_Clicked(self):
        """ Runs monitor_rtl433 and opens a browser to view data.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- sudo python3 -m monitor_rtl433 &', shell=True) 
        
        # Open the Browser
        os.system("sensible-browser http://127.0.0.1:5000/ &")    
        
    def _slotMenuWiGLE_Clicked(self):
        """ Opens wigle.net in a browser.
        """
        # Open the Browser
        os.system("sensible-browser https://www.wigle.net/ &")  
        
    def _slotMenuScan_SSID_Clicked(self):
        """ Opens a terminal for scanning SSIDs while in managed mode using scan-ssid.
        """
        # Guess the Wireless Interface Name
        get_interface = "interface"
        
        # Get the Text
        proc=subprocess.Popen("iwconfig &", shell=True, stdout=subprocess.PIPE, )
        output=proc.communicate()[0].decode()
        
        # Pull the Interfaces
        lines = output.split('\n')
        get_interface = ''
        wifi_interfaces = []
        for n in range(0,len(lines)):
            if 'ESSID' in lines[n]:
                wifi_interfaces.append(lines[n].split(' ',1)[0])
        
        # Found an Interface
        if len(wifi_interfaces) > 0:
                        
            # Update the Edit Box
            get_interface = wifi_interfaces[0]

        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script"         
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "scan-ssid -p ' + get_interface + '"', shell=True)
        
    def _slotMenuPySimReadClicked(self):
        """ Opens a terminal in the pySim directory for using pySim-read.py.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        pysim_directory = os.path.expanduser("~/Installed_by_FISSURE/pysim/")
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "./pySim-read.py -p 0"', cwd=pysim_directory, shell=True)  
    
    def _slotMenuPySimProgClicked(self):
        """ Opens a terminal in the pySim directory for using pySim-prog.py.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        pysim_directory = os.path.expanduser("~/Installed_by_FISSURE/pysim/")
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "./pySim-prog.py -p 0 -x 310 -y 070 -n test1 -t sysmoUSIM-SJS1 -i 901700000023688 -s 8988211000000236888 -o 1B0A4D434B184DE7BA88147E725C5AAD -k 0B7BBF089FD188EA0C64FEE245EB03E7 -a 12100237"', cwd=pysim_directory, shell=True)  
            
    def _slotMenuLessonLuaDissectorsClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson2_LuaDissectors.html &") 

    def _slotMenuMinimodemRxClicked(self):
        """ Opens a terminal and populates it with the minimodem --rx command.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "minimodem --rx 110"', shell=True)  
                
    def _slotMenuMinimodemTxClicked(self):
        """ Opens a terminal and populates it with the minimodem --tx command.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        transmit_text = """\\\"This is a test message!\\\" """
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "printf ' + transmit_text + ' | minimodem --tx 110"', shell=True)       
        
    def _slotMenuWSJTX_Clicked(self):
        """ Issues the wsjtx command.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- wsjtx &', shell=True)
        
    def _slotMenuWSPRnetMapClicked(self):
        """ Opens the WSPRnet Map in the browser.
        """
        # Open the Browser
        os.system("sensible-browser https://www.wsprnet.org/drupal/wsprnet/map &")
        
    def _slotMenuAntennaTestRxClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/antenna_test_rx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")  
        
    def _slotMenuAntennaTestTxClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/antenna_test_tx.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")      

    def _slotMenuLessonSound_eXchangeClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson3_Sound_eXchange.html &") 
        
    def _slotMenuVLC_Clicked(self):
        """ Opens VLC.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- vlc &', shell=True)
        
    def _slotMenuZigbeeOpenSnifferClicked(self):
        """ Opens ZigBe Open Sniffer Web GUI
        """
        # Issue the Command
        filepath = os.path.expanduser("~/Installed_by_FISSURE/OpenSniffer-0.1/ZigBee_GUI.py")
        cmd  = "python2 " + filepath
        proc=subprocess.Popen(cmd, shell=True)

    def _slotMenuSimpleScreenRecorderClicked(self):
        """ Opens SimpleScreenRecorder.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- simplescreenrecorder &', shell=True)
        
    def _slotMenuPixieDustListClicked(self):
        """ Opens a list of devices vulnerable to Pixie Dust (Wifite).
        """
        os.system("sensible-browser https://docs.google.com/spreadsheets/d/1tSlbqVQ59kGn8hgmwcPTHUECQ3o9YhXR91A_p7Nnj5Y/edit#gid=2048815923 &") 
        
    def _slotMenuAudioRecordClicked(self):
        """ Opens a terminal with the sox record command loaded.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "rec test.wav trim 0 0:10"', shell=True)          
        
    def _slotMenuESP_BoardClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson4_ESP_Boards.html &") 
        
    def _slotMenuGoogleEarthProClicked(self):
        """ Opens Google Earth Pro.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- google-earth-pro &', shell=True)
        
    def _slotMenuGrAirModesClicked(self):
        """ Opens a terminal with an example command for using gr-air-modes.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "modes_rx -s osmocom -K aircrafts.kml"', shell=True)       
        
    def _slotMenuESP8266_DeautherInoClicked(self):
        """ Opens the .ino file in the Arduino IDE.
        """
        # Open Arduino IDE
        deauther_directory = os.path.expanduser("~/Installed_by_FISSURE/esp8266_deauther-2/esp8266_deauther/")
        proc=subprocess.Popen("sudo arduino " + deauther_directory + "esp8266_deauther.ino &", shell=True)         
        
    def _slotMenuESP8266_DeautherWebInterfaceClicked(self):
        """ Opens a browser to the Deauther web interface. Need to connect to its wireless network.
        """
        os.system("sensible-browser 192.168.4.1 &") 
        
    def _slotMenuESP8266_DeautherCredentialsClicked(self):
        """ Opens a text file with the credentials for joining the deauther's network.
        """
        # Open the File
        credential_directory = os.path.dirname(os.path.realpath(__file__)) + "/Tools/ESP8266_Deauther_v2/credentials.txt" 
        os.system("gedit " + credential_directory + " &")
        
    def _slotMenuLowEarthVisualizationClicked(self):
        """ Opens the LeoLabs visualization page.
        """
        os.system("sensible-browser https://platform.leolabs.space/visualization &") 
        
    def _slotMenuLeoLabsCatalogClicked(self):
        """ Opens the LeoLabs catalog page.
        """
        os.system("sensible-browser https://platform.leolabs.space/catalog &") 

    def _slotMenuCgpsClicked(self):
        """ Runs the cgps command in a terminal.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- cgps &', shell=True)
        
    def _slotMenuGpsdecodeClicked(self):
        """ Decodes the output of gpscat in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo gpscat /dev/ttyACM0 | gpsdecode"', shell=True)
        
    def _slotMenuGpsmonClicked(self):
        """ Runs the gpsmon command in a terminal.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- gpsmon &', shell=True)
                
    def _slotMenuXgpsClicked(self):
        """ Runs the xgps command in a terminal.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- xgps &', shell=True)        
        
    def _slotMenuXgpsspeedClicked(self):
        """ Runs the xgsspeed command in a terminal.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- xgpsspeed &', shell=True)        

    def _slotMenuVikingClicked(self):
        """ Opens Viking tool. May need to link ports to track GPS: "sudo ln -s /dev/ttyACM0 /dev/ttyUSB0"
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- viking &', shell=True)                

    def _slotMenuPyGPSClientClicked(self):
        """ Opens the PyGPSClient program.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- sudo python3 -m pygpsclient &', shell=True)   
        
    def _slotMenuRadioStationLocator(self):
        """ Opens the Radio Station Locator in a browser.
        """
        os.system("sensible-browser https://radio-locator.com/cgi-bin/locate &") 
        
    def _slotMenuLiveATCnetClicked(self):
        """ Opens LiveATC.net in a browser
        """
        os.system("sensible-browser https://www.liveatc.net/ &") 

    def _slotMenuFlightradar24_Clicked(self):
        """ Opens Flightradar24 in a browser.
        """
        os.system("sensible-browser https://www.flightradar24.com/ &") 

    def _slotMenuFlightStatsClicked(self):
        """ Opens FlightStats in a browser.
        """
        os.system("sensible-browser http://www.flightstats.com/ &") 
        
    def _slotMenuPlaneFinderClicked(self):
        """ Opens Plane Finder in a browser.
        """
        os.system("sensible-browser https://planefinder.net/ &") 
        
    def _slotMenuUS_CountyOverlaysClicked(self):
        """ Opens the FCC U.S. County Overlay for Google Earth (KML) in a browser.
        """
        os.system("sensible-browser https://www.fcc.gov/media/radio/us-county-overlays-kml &") 
        
    def _slotMenuAM_QueryClicked(self):
        """ Opens the FCC AM Query in a browser.
        """
        os.system("sensible-browser https://www.fcc.gov/media/radio/am-query &") 
        
    def _slotMenuFM_QueryClicked(self):
        """ Opens the FCC FM Query in a browser.
        """
        os.system("sensible-browser https://www.fcc.gov/media/radio/fm-query &") 
        
    def _slotMenuRadioGardenClicked(self):
        """ Opens Radio Garden in a browser.
        """
        os.system("sensible-browser http://radio.garden/ &") 
        
    def _slotMenuDiffcheckerClicked(self):
        """ Opens Diffchecker in a browser.
        """
        os.system("sensible-browser https://www.diffchecker.com/ &") 

    def _slotMenuEveryTimeZoneClicked(self):
        """ Opens Every Time Zone in a browser.
        """
        os.system("sensible-browser https://everytimezone.com/ &") 

    def _slotMenuCloudConvertClicked(self):
        """ Opens CloudConvert in a browser.
        """
        os.system("sensible-browser https://cloudconvert.com/ &") 
        
    def _slotMenuRoundup_ofSDRsClicked(self):
        """ Opens Roundup of SDRs in a browser.
        """
        os.system("sensible-browser https://www.rtl-sdr.com/roundup-software-defined-radios/ &") 
        
    def _slotMenuList_ofSDRsClicked(self):
        """ Opens List of SDRs in a browser.
        """
        os.system("sensible-browser https://en.wikipedia.org/wiki/List_of_software-defined_radios &") 
        
    def _slotMenuAcarsDemoClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/acars_demo.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuGpredictClicked(self):
        """ Opens Gpredict.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- gpredict &', shell=True) 
        
    def _slotMenuTechInfoDepotClicked(self):
        """ Opens TechInfoDepot in a browser.
        """
        os.system("sensible-browser http://en.techinfodepot.shoutwiki.com/wiki/Main_Page &") 
        
    def _slotMenuWikiDeviClicked(self):
        """ Opens WikiDevi (TechInfoDepot) in a browser.
        """
        os.system("sensible-browser http://en.techinfodepot.shoutwiki.com/wiki/Main_Page/WikiDevi &") 
        
    def _slotMenuApt3000_Clicked(self):
        """ Opens APT3000 in a browser.
        """
        os.system("sensible-browser https://jthatch.com/APT3000/APT3000.html &")  
        
    def _slotMenuFSPL_CalculatorClicked(self):
        """ Opens Free Space Path Loss Calculator in a browser.
        """
        os.system("sensible-browser https://www.pasternack.com/t-calculator-fspl.aspx &")  
        
    def _slotMenuHabhubTrackerClicked(self):
        """ Opens habhub tracker in a browser.
        """
        os.system("sensible-browser https://tracker.habhub.org/ &")
        
    def _slotMenuFoxtrotGPS_Clicked(self):
        """ Opens the FoxtrotGPS program.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- foxtrotgps &', shell=True) 
        
    def _slotMenuGoogleMapsAPRS_Clicked(self):
        """ Opens Google Maps APRS in a browser.
        """
        os.system("sensible-browser https://aprs.fi/ &")
        
    def _slotMenuAPRSmultimon_ngClicked(self):
        """ Places the command to view raw APRS data from an RTL device in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "rtl_fm -f 144.390M -s 22050|multimon-ng -t raw -a AFSK1200 -f alpha -A /dev/stdin"', shell=True)
                
    def _slotMenuLTE_CellScannerClicked(self):
        """ Opens an example command for LTE-Cell-Scanner in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "CellSearch --freq-start 884e6 --freq-end 886e6"', shell=True)
            
    def _slotMenu_esriSatelliteMapClicked(self):
        """ Opens esri Satellite Map in a browser.
        """
        os.system("sensible-browser https://maps.esri.com/rc/sat2/index.html &")        

    def _slotMenuLessonRadiosondeTrackingClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson5_Radiosonde_Tracking.html &")         

    def _slotMenuBtrxClicked(self):
        """ Opens an example command for using btrx (gr-bluetooth).
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "btrx -f 2402M -r 4M -g 40 -a hackrf"', shell=True)
        
    def _slotMenuBleDumpTriggered(self):
        """ Opens an example command for using ble_dump and creates a fifo for Wireshark.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        ble_dump_directory = os.path.dirname(os.path.realpath(__file__)) + "/Tools/ble_dump-master/"              
        proc=subprocess.Popen('mkfifo /tmp/fifo1', shell=True)
        proc=subprocess.call("wireshark -S -k -i /tmp/fifo1 &", shell=True)
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo python2 ble_dump.py -s 4000000 -o /tmp/fifo1"', cwd=ble_dump_directory, shell=True)
        
    def _slotMenuFlashESP32_BoardClicked(self):
        """ Flashes the ESP32 board with the BrakTooth Sniffer.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        esp32_sniffer_directory = os.path.expanduser("~/Installed_by_FISSURE/esp32_bluetooth_classic_sniffer/")
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo ./firmware.py flash /dev/ttyUSB0"', cwd=esp32_sniffer_directory, shell=True)        
        
    def _slotMenuBT_SnifferBREDR_Clicked(self):
        """ Runs the Bluetooth Classic Sniffer in slave role.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        esp32_sniffer_directory = os.path.expanduser("~/Installed_by_FISSURE/esp32_bluetooth_classic_sniffer/")
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo ./BTSnifferBREDR.py --port=/dev/ttyUSB0 --live-terminal --live-wireshark"',  cwd=esp32_sniffer_directory, shell=True)        
        
    def _slotMenuHcitoolScanClicked(self):
        """ Opens the hcitool scan command in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "hcitool scan"', shell=True)        
        
    def _slotMenuSdptoolBrowseClicked(self):
        """ Opens the sdptool browse command in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sdptool browse 00:80:98:24:15:6D"', shell=True)        

    def _slotMenuHcitoolInqClicked(self):
        """ Opens the hcitool inq command in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "hcitool inq"', shell=True)          

    def _slotMenuDeviceClassListClicked(self):
        """ Opens "Bluetooth - Class of Device List" in a browser.
        """
        os.system("sensible-browser http://domoticx.com/bluetooth-class-of-device-lijst-cod/ &")        
        
    def _slotMenuBtclassifyClicked(self):
        """ Opens the btsclassify.py command in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        btclassify_directory = os.path.dirname(os.path.realpath(__file__)) + "/Tools/btclassify-master" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "./btclassify.py 38010c 0x5a020c 240404"', cwd=btclassify_directory, shell=True)   
        
    def _slotMenuL2pingClicked(self):
        """ Opens the l2ping command in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo l2ping 00:80:98:24:15:6D"', shell=True)         
        
    def _slotMenuBtscannerClicked(self):
        """ Opens the btscanner program.
        """
        # Issue the Command
        proc=subprocess.Popen('gnome-terminal -- sudo btscanner &', shell=True)        
        
    def _slotMenuHcidumpClicked(self):
        """ Opens the hcidump command in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo hcidump -Xt"', shell=True)  
        
    def _slotHIPRFISR_Offline(self):
        """ Modifies the statusbar buttons. Needs to be a separate slot to avoid segmentation faults.
        """
        # Modify the Button       
        pass  # HIPRFISR is different than other components 
        
    def _slotHIPRFISR_Online(self):
        """ Modifies the statusbar buttons. Needs to be a separate slot to avoid segmentation faults.
        """
        # Modify the Button       
        pass  # HIPRFISR is different than other components 
        
    def _slotTSI_Offline(self):
        """ Modifies the statusbar buttons. Needs to be a separate slot to avoid segmentation faults.
        """
        # Modify the Button    
        self.statusbar_tsi.setFlat(False)
        self.statusbar_tsi.setText("TSI: XX")   
        
    def _slotTSI_Online(self):
        """ Modifies the statusbar buttons. Needs to be a separate slot to avoid segmentation faults.
        """
        # Modify the Button
        self.statusbar_tsi.setFlat(True)
        self.statusbar_tsi.setText("TSI: OK")  
                
    def _slotPD_Offline(self):
        """ Modifies the statusbar buttons. Needs to be a separate slot to avoid segmentation faults.
        """
        # Modify the Button    
        self.statusbar_pd.setFlat(False)    
        self.statusbar_pd.setText("PD: XX")
        
    def _slotPD_Online(self):
        """ Modifies the statusbar buttons. Needs to be a separate slot to avoid segmentation faults.
        """
        # Modify the Button     
        self.statusbar_pd.setFlat(True)   
        self.statusbar_pd.setText("PD: OK")   
        
    def _slotFGE_Offline(self):
        """ Modifies the statusbar buttons. Needs to be a separate slot to avoid segmentation faults.
        """
        # Modify the Button        
        self.statusbar_fge.setFlat(False)
        self.statusbar_fge.setText("FGE: XX")     
        
    def _slotFGE_Online(self):
        """ Modifies the statusbar buttons. Needs to be a separate slot to avoid segmentation faults.
        """
        # Modify the Button
        self.statusbar_fge.setFlat(True)
        self.statusbar_fge.setText("FGE: OK")
        
    def _slotMenuLessonRFID_Clicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson6_RFID.html &")     
        
    def _slotMenuStandaloneFM_RadioCaptureClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/FM_Radio_Capture.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   

    def _slotTSI_AdvancedSettingsClicked(self):
        """ Displays the advanced settings for the currently selected TSI detector.
        """
        # Switch to Advanced Settings
        fg_detectors = ['wideband_x310.py','wideband_b210.py','wideband_hackrf.py','wideband_b205mini.py','wideband_rtl2832u.py','wideband_limesdr.py','wideband_bladerf.py']
        
        # Flow Graph Detectors
        if str(self.comboBox_tsi_detector.currentText()) in fg_detectors:
            self.stackedWidget_tsi_detector.setCurrentIndex(1)
            
    def _slotTSI_Back1_Clicked(self):
        """ Goes back to the TSI search band settings.
        """
        # Go Back
        self.stackedWidget_tsi_detector.setCurrentIndex(0)
        
    def _slotTSI_DetectorChanged(self):
        """ Adjusts default settings for the current detector.
        """
        # Change Settings
        get_detector = str(self.comboBox_tsi_detector.currentText())
        if get_detector == 'wideband_x310.py':
            self.textEdit_tsi_detector_fg_sample_rate.setPlainText("20e6")
            self.spinBox_tsi_detector_fg_threshold.setValue(-70)
            self.comboBox_tsi_detector_fg_fft_size.setCurrentIndex(1)
            self.spinBox_tsi_detector_fg_gain.setMaximum(35)
            self.spinBox_tsi_detector_fg_gain.setMinimum(0)
            self.spinBox_tsi_detector_fg_gain.setValue(30)
            self.comboBox_tsi_detector_fg_channel.clear()
            self.comboBox_tsi_detector_fg_channel.addItem("A:0")
            self.comboBox_tsi_detector_fg_channel.addItem("B:0")
            self.comboBox_tsi_detector_fg_channel.setCurrentIndex(0)
            self.comboBox_tsi_detector_fg_antenna.clear()
            self.comboBox_tsi_detector_fg_antenna.addItem("TX/RX")
            self.comboBox_tsi_detector_fg_antenna.addItem("RX2")
            self.comboBox_tsi_detector_fg_antenna.setCurrentIndex(0)  
            self.stackedWidget_tsi_detector.setCurrentIndex(0)          
            
        elif get_detector == 'wideband_b210.py':
            self.textEdit_tsi_detector_fg_sample_rate.setPlainText("10e6")
            self.spinBox_tsi_detector_fg_threshold.setValue(-70)
            self.comboBox_tsi_detector_fg_fft_size.setCurrentIndex(1)
            self.spinBox_tsi_detector_fg_gain.setMaximum(80)
            self.spinBox_tsi_detector_fg_gain.setMinimum(0)
            self.spinBox_tsi_detector_fg_gain.setValue(60)
            self.comboBox_tsi_detector_fg_channel.clear()
            self.comboBox_tsi_detector_fg_channel.addItem("A:A")
            self.comboBox_tsi_detector_fg_channel.addItem("A:B")
            self.comboBox_tsi_detector_fg_channel.setCurrentIndex(0)
            self.comboBox_tsi_detector_fg_antenna.clear()
            self.comboBox_tsi_detector_fg_antenna.addItem("TX/RX")
            self.comboBox_tsi_detector_fg_antenna.addItem("RX2")
            self.comboBox_tsi_detector_fg_antenna.setCurrentIndex(0)   
            self.stackedWidget_tsi_detector.setCurrentIndex(0)
            
        elif get_detector == 'wideband_hackrf.py':
            self.textEdit_tsi_detector_fg_sample_rate.setPlainText("20e6")
            self.spinBox_tsi_detector_fg_threshold.setValue(-70)
            self.comboBox_tsi_detector_fg_fft_size.setCurrentIndex(1)
            self.spinBox_tsi_detector_fg_gain.setMaximum(14)
            self.spinBox_tsi_detector_fg_gain.setMinimum(0)
            self.spinBox_tsi_detector_fg_gain.setValue(10)
            self.comboBox_tsi_detector_fg_channel.clear()
            self.comboBox_tsi_detector_fg_channel.addItem("N/A")
            self.comboBox_tsi_detector_fg_channel.setCurrentIndex(0)
            self.comboBox_tsi_detector_fg_antenna.clear()
            self.comboBox_tsi_detector_fg_antenna.addItem("N/A")
            self.comboBox_tsi_detector_fg_antenna.setCurrentIndex(0)  
            self.stackedWidget_tsi_detector.setCurrentIndex(0) 
            
        elif get_detector == 'wideband_b205mini.py':
            self.textEdit_tsi_detector_fg_sample_rate.setPlainText("10e6")
            self.spinBox_tsi_detector_fg_threshold.setValue(-70)
            self.comboBox_tsi_detector_fg_fft_size.setCurrentIndex(1)
            self.spinBox_tsi_detector_fg_gain.setMaximum(80)
            self.spinBox_tsi_detector_fg_gain.setMinimum(0)
            self.spinBox_tsi_detector_fg_gain.setValue(60)
            self.comboBox_tsi_detector_fg_channel.clear()
            self.comboBox_tsi_detector_fg_channel.addItem("A:A")
            self.comboBox_tsi_detector_fg_channel.addItem("A:B")
            self.comboBox_tsi_detector_fg_channel.setCurrentIndex(0)
            self.comboBox_tsi_detector_fg_antenna.clear()
            self.comboBox_tsi_detector_fg_antenna.addItem("TX/RX")
            self.comboBox_tsi_detector_fg_antenna.addItem("RX2")
            self.comboBox_tsi_detector_fg_antenna.setCurrentIndex(0)
            self.stackedWidget_tsi_detector.setCurrentIndex(0)
            
        elif get_detector == 'wideband_rtl2832u.py':
            self.textEdit_tsi_detector_fg_sample_rate.setPlainText("2e6")
            self.spinBox_tsi_detector_fg_threshold.setValue(-70)
            self.comboBox_tsi_detector_fg_fft_size.setCurrentIndex(1)
            self.spinBox_tsi_detector_fg_gain.setMaximum(14)
            self.spinBox_tsi_detector_fg_gain.setMinimum(0)
            self.spinBox_tsi_detector_fg_gain.setValue(10)
            self.comboBox_tsi_detector_fg_channel.clear()
            self.comboBox_tsi_detector_fg_channel.addItem("N/A")
            self.comboBox_tsi_detector_fg_channel.setCurrentIndex(0)
            self.comboBox_tsi_detector_fg_antenna.clear()
            self.comboBox_tsi_detector_fg_antenna.addItem("N/A")
            self.comboBox_tsi_detector_fg_antenna.setCurrentIndex(0) 
            self.stackedWidget_tsi_detector.setCurrentIndex(0)
            
        elif get_detector == 'wideband_limesdr.py':
            self.textEdit_tsi_detector_fg_sample_rate.setPlainText("20e6")
            self.spinBox_tsi_detector_fg_threshold.setValue(-70)
            self.comboBox_tsi_detector_fg_fft_size.setCurrentIndex(1)
            self.spinBox_tsi_detector_fg_gain.setMaximum(70)
            self.spinBox_tsi_detector_fg_gain.setMinimum(0)
            self.spinBox_tsi_detector_fg_gain.setValue(60)
            self.comboBox_tsi_detector_fg_channel.clear()
            self.comboBox_tsi_detector_fg_channel.addItem("A")
            self.comboBox_tsi_detector_fg_channel.addItem("B")
            self.comboBox_tsi_detector_fg_channel.setCurrentIndex(0)
            self.comboBox_tsi_detector_fg_antenna.clear()
            self.comboBox_tsi_detector_fg_antenna.addItem("RX1")
            self.comboBox_tsi_detector_fg_antenna.addItem("RX2")
            self.comboBox_tsi_detector_fg_antenna.setCurrentIndex(0) 
            self.stackedWidget_tsi_detector.setCurrentIndex(0)
            
        elif get_detector == 'wideband_bladerf.py':
            self.textEdit_tsi_detector_fg_sample_rate.setPlainText("20e6")
            self.spinBox_tsi_detector_fg_threshold.setValue(-70)
            self.comboBox_tsi_detector_fg_fft_size.setCurrentIndex(1)
            self.spinBox_tsi_detector_fg_gain.setMaximum(14)
            self.spinBox_tsi_detector_fg_gain.setMinimum(0)
            self.spinBox_tsi_detector_fg_gain.setValue(10)
            self.comboBox_tsi_detector_fg_channel.clear()
            self.comboBox_tsi_detector_fg_channel.addItem("N/A")
            self.comboBox_tsi_detector_fg_channel.setCurrentIndex(0)
            self.comboBox_tsi_detector_fg_antenna.clear()
            self.comboBox_tsi_detector_fg_antenna.addItem("N/A")
            self.comboBox_tsi_detector_fg_antenna.setCurrentIndex(0) 
            self.stackedWidget_tsi_detector.setCurrentIndex(0)
            
        elif get_detector == 'Simulator':
            self.stackedWidget_tsi_detector.setCurrentIndex(2)
            
        elif get_detector == 'IQ File':
            self.stackedWidget_tsi_detector.setCurrentIndex(3)
            
    
    def _slotMenuAddingCustomOptionsClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/AddingCustomOptions.html &")
        
    def _slotPD_StatusSOI_NewClicked(self):
        """ Manually creates a new signal of interest.
        """
        # Open the NewSOI Dialog
        new_soi_dlg = NewSOI(parent=self)
        new_soi_dlg.show()
        new_soi_dlg.exec_() 
        
        # Apply Clicked
        get_value = new_soi_dlg.return_value
        if len(get_value) > 0:             
                        
            # Update the Text
            #target_soi = [get_frequency, get_modulation, get_bandwidth, get_continuous, get_start_frequency, get_end_frequency]
            self.textEdit_pd_status_target.setPlainText("Center Frequency (MHz): " + self.target_soi[0])    
            self.textEdit_pd_status_target.append("Start Frequency (MHz): " + self.target_soi[4])
            self.textEdit_pd_status_target.append("End Frequency (MHz): " + self.target_soi[5]) 
            self.textEdit_pd_status_target.append("Bandwidth (MHz): " + self.target_soi[2])   
            self.textEdit_pd_status_target.append("Modulation: " + self.target_soi[1])            
            self.textEdit_pd_status_target.append("Continuous: " + self.target_soi[3])
            self.textEdit_pd_status_target.append("Notes: " + self.target_soi[6])
            
            self.pushButton_pd_status_untarget.setEnabled(True)
            #self.pushButton_pd_status_blacklist_soi.setEnabled(True)
            self.pushButton_pd_status_search_library.setEnabled(True)
            
    def _slotPD_BitViewerHexChanged(self):
        """ Updates the ASCII values when the hex changes.
        """
        # Display the ASCII
        get_hex_str = str(self.plainTextEdit_pd_bit_viewer_hex.toPlainText()).replace(" ","")         
            
        # Split by Line
        get_hex = get_hex_str.splitlines()
        new_ascii = ""   
        for n in range(0, len(get_hex)):
            if (len(get_hex[n])%2 == 0):
                new_ascii = new_ascii + str(bytes.fromhex(get_hex[n]))[2:-1] + "\n"
                                
        self.plainTextEdit_pd_bit_viewer_ascii.setPlainText(new_ascii)
     
    def _slotMenuProtocolCSV_Clicked(self):
        """ Opens a CSV with RF protocols sorted by frequency.
        """
        # Issue the Command
        csv_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Help/protocols_by_frequency.csv"
        command_text = 'libreoffice ' + csv_filepath + ' &'
        proc = subprocess.Popen(command_text, shell=True) 
        
    def _slotTSI_DetectorIQ_FileBrowseClicked(self):
        """ Chooses an IQ file for detection.
        """        
        # Look for a File
        default_directory = os.path.dirname(os.path.realpath(__file__)) +"/IQ Recordings/"
        fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select IQ File...", default_directory, filter="All Files (*)")[0]

        # Valid File
        if fname != "":
            self.textEdit_tsi_detector_iq_file_file.setPlainText(fname)
                          
    def _slotMenuUHD_ImageLoaderClicked(self):
        """ Opens a terminal and displays the uhd_image_loader command for the USRP X310.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        uhd_command = """\\\"/usr/bin/uhd_image_loader\\\" --args=\\\"type=x300,addr=192.168.40.2\\\" """        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + uhd_command + '"', shell=True) 
        
    def _slotMenuTinyWowClicked(self):
        """ Opens TinyWow in a browser.
        """
        os.system("sensible-browser https://tinywow.com/ &") 
                
    def _slotIQ_MovingAverageClicked(self):
        """ Applies a moving average filter to the data in the plot window.
        """
        # Get the Data from the Window
        num_lines = self.iq_matplotlib_widget.axes.lines
        
        # Taps
        num_points = int(self.dashboard_settings_dictionary['moving_avg_points'])
        taps = (np.ones(num_points))/num_points
        
        # Single Line: Not IQ
        if len(num_lines) == 1:
            y_data = self.iq_matplotlib_widget.axes.lines[0].get_ydata()
            
            # Ignore lfilter Warning
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                warnings.filterwarnings("ignore", module="matplotlib")
                avg_data = lfilter(taps, 1.0, y_data)
            
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)

            # Ignore hold() Deprecation Warnings
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                warnings.filterwarnings("ignore", module="matplotlib")
                
                self.iq_matplotlib_widget.axes.plot(avg_data,'b',linewidth=1)
            
            self.iq_matplotlib_widget.applyLabels("IQ Data",'Samples','Amplitude (LSB)',None,None) 
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked() 
            self.iq_matplotlib_widget.draw()            
           
        # Two Lines: IQ
        elif len(num_lines) == 2:
            I = self.iq_matplotlib_widget.axes.lines[0].get_ydata()
            Q = self.iq_matplotlib_widget.axes.lines[1].get_ydata()
            complex_data = [complex(I[x],Q[x]) for x in range(len(I))]
            
            # Ignore lfilter Warning
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                warnings.filterwarnings("ignore", module="matplotlib")
                avg_data = lfilter(taps, 1.0, complex_data)
            
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=False)

            # Ignore hold() Deprecation Warnings
            with warnings.catch_warnings():
                warnings.simplefilter("ignore")
                warnings.filterwarnings("ignore", module="matplotlib")
                
                self.iq_matplotlib_widget.axes.plot(np.real(avg_data),'b',linewidth=1)
                #self.iq_matplotlib_widget.axes.hold(True)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
                self.iq_matplotlib_widget.axes.plot(np.imag(avg_data),'r',linewidth=1)
                #self.iq_matplotlib_widget.axes.hold(False)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
            
            self.iq_matplotlib_widget.applyLabels("IQ Data",'Samples','Amplitude (LSB)',None,None) 
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked() 
            self.iq_matplotlib_widget.draw()
            
    def _slotMenuGrPaintConverterClicked(self):
        """ Converts text into a raw file formatted for gr-paint.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        spectrum_painter_directory = os.path.expanduser("~/Installed_by_FISSURE/spectrum_painter/")
        converter_command = "convert -pointsize 30 -fill black label:hello hello.png && python3 -m spectrum_painter.img2iqstream hello.png --samplerate 8000000 --format hackrf > hello.raw"        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + converter_command + '"', cwd=spectrum_painter_directory, shell=True) 

    def _slotMenuModifyingDashboardClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Help/ModifyingDashboard.html &")
    
    def _slotMenuNrsc5_Clicked(self):
        """ Opens the nrsc5 command (for rtl devices) in a terminal. Press 0,1,2,3 once running to switch programs.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        nrsc_command = "nrsc5 94.9 0 -g 40"        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + nrsc_command + '"', shell=True)         
    
    def _slotMenuStandaloneHd_tx_usrpClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/hd_tx_usrp.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuAntennaComparisonClicked(self):
        """ Opens the AntennaComparison spreadsheet.
        """
        # Issue the Command
        spreadsheet_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Help/AntennaComparison.ods"
        command_text = 'libreoffice ' + spreadsheet_filepath + ' &'
        proc = subprocess.Popen(command_text, shell=True)         
        
    def _slotPD_DissectorApplyClicked(self):
        """ Assigns the selected dissector to the selected packet type.
        """
        # Update Library
        get_protocol = str(self.comboBox_pd_dissectors_protocol.currentText())
        get_packet_type = str(self.comboBox_pd_dissectors_packet_type.currentText())
        get_dissector_file = str(self.comboBox_pd_dissectors_existing_dissectors.currentText())
        if len(get_protocol) > 0 and len(get_packet_type) > 0:
            # Find Port for Existing Dissector
            get_packet_types = getPacketTypes(self.pd_library, get_protocol)
            for n in get_packet_types:
                dissector = getDissector(self.pd_library, get_protocol, n)
                if get_dissector_file == dissector['Filename']:
                    get_dissector_port = dissector['Port']
                    break
                    
            new_dissector = [get_dissector_file, get_dissector_port]
            self.dashboard_hiprfisr_server.sendmsg('Commands', Identifier = 'Dashboard', MessageName = 'Add To Library', Parameters = [get_protocol, get_packet_type, [], [], [], [], [], [], new_dissector])

    def _slotIQ_ConvertOriginalLoadClicked(self):
        """ Selects a file to convert to a new data type.
        """
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['Data File (*.*)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_convert_original.setPlainText(folder)
        except:
            pass  
            
    def _slotIQ_ConvertNewLoadClicked(self):
        """ Selects the location for the new data file.
        """
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['Data File (*.*)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_convert_new.setPlainText(folder)
        except:
            pass    
            
    def _slotIQ_ConvertCopyClicked(self):
        """ Copies the contents from the "Original File" text edit box to the "New File" text edit box.
        """
        # Copy the Contents
        get_original_file = str(self.textEdit_iq_convert_original.toPlainText())
        self.textEdit_iq_convert_new.setPlainText(get_original_file)
        
    def _slotIQ_ConvertClicked(self):
        """ Converts the original file to a new data type.
        """
        # Get Values
        get_original_file = str(self.textEdit_iq_convert_original.toPlainText())
        get_original_type = str(self.comboBox_iq_convert_original.currentText())
        get_new_file = str(self.textEdit_iq_convert_new.toPlainText())
        get_new_type = str(self.comboBox_iq_convert_new.currentText())
            
        # Files Selected
        if (len(get_original_file) > 0) and (len(get_new_file) > 0):
            # Read the Data 
            file = open(get_original_file,"rb")                    
            plot_data = file.read() 
            file.close()
                                       
            # Complex Float 64 >> Complex Int 64
            if (get_original_type == "Complex Float 64") and (get_new_type == "Complex Int 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'d', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int64)
                np_data.tofile(get_new_file)
                                       
            # Complex Float 64, Complex Float 32 >> Complex Float 32
            elif (get_original_type == "Complex Float 64") and ((get_new_type == "Complex Float 32") or (get_new_type == "Float/Float 32")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'d', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.float32)
                np_data.tofile(get_new_file)
                                       
            # Complex Float 64 >> Int/Int 32
            elif (get_original_type == "Complex Float 64") and (get_new_type == "Int/Int 32"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'d', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int32)
                np_data.tofile(get_new_file)
                                       
            # Complex Float 64 >> Complex Int 16, Short/Int 16
            elif (get_original_type == "Complex Float 64") and ((get_new_type == "Complex Int 16") or (get_new_type == "Short/Int 16")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'d', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int16)
                np_data.tofile(get_new_file)
                                       
            # Complex Float 64 >> Complex Int 8, Byte/Int 8
            elif (get_original_type == "Complex Float 64") and ((get_new_type == "Complex Int 8") or (get_new_type == "Byte/Int 8")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'d', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int8)
                np_data.tofile(get_new_file)
                
            # Complex Int 64 >> Complex Float 32, Float/Float 32
            elif (get_original_type == "Complex Int 64") and ((get_new_type == "Complex Float 32") or (get_new_type == "Float/Float 32")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'q', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.float32)
                np_data.tofile(get_new_file)                
                
            # Complex Int 64 >> Complex Float 64
            elif (get_original_type == "Complex Int 64") and (get_new_type == "Complex Float 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'q', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.float64)
                np_data.tofile(get_new_file)      
                
            # Complex Int 64 >> Int/Int 32
            elif (get_original_type == "Complex Int 64") and (get_new_type == "Int/Int 32"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'q', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int32)
                np_data.tofile(get_new_file)      
                          
            # Complex Int 64 >> Complex Int 16, Short/Int 16
            elif (get_original_type == "Complex Int 64") and ((get_new_type == "Complex Int 16") or (get_new_type == "Short/Int 16")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'q', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int16)
                np_data.tofile(get_new_file)                
                          
            # Complex Int 64 >> Complex Int 8, Byte/Int 8
            elif (get_original_type == "Complex Int 64") and ((get_new_type == "Complex Int 8") or (get_new_type == "Byte/Int 8")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'q', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int8)
                np_data.tofile(get_new_file)                
                                       
            # Complex Float 32 >> Complex Int 16, Short/Int 16
            elif (get_original_type == "Complex Float 32") and ((get_new_type == "Complex Int 16") or (get_new_type == "Short/Int 16")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'f', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int16)
                np_data.tofile(get_new_file)
                
            # Complex Float 32, Float/Float 32 >> Complex Int 8, Byte/Int 8
            elif ((get_original_type == "Complex Float 32") or (get_original_type == "Float/Float 32")) and ((get_new_type == "Complex Int 8") or (get_new_type == "Byte/Int 8")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'f', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int8)
                np_data.tofile(get_new_file)
                
            # Complex Float 32, Float/Float 32 >> Int/Int 32
            elif ((get_original_type == "Complex Float 32") or (get_original_type == "Float/Float 32")) and (get_new_type == "Int/Int 32"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'f', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int32)
                np_data.tofile(get_new_file)
                
            # Complex Float 32, Float/Float 32 >> Complex Float 64
            elif ((get_original_type == "Complex Float 32") or (get_original_type == "Float/Float 32")) and (get_new_type == "Complex Float 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'f', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.float64)
                np_data.tofile(get_new_file)
                
            # Complex Float 32, Float/Float 32 >> Complex Int 64
            elif ((get_original_type == "Complex Float 32") or (get_original_type == "Float/Float 32")) and (get_new_type == "Complex Int 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'f', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int64)
                np_data.tofile(get_new_file)
                
            # Int/Int 32 >> Complex Float 64
            elif (get_original_type == "Int/Int 32") and (get_new_type == "Complex Float 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'i', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.float64)
                np_data.tofile(get_new_file)
                
            # Int/Int 32 >> Complex Int 64
            elif (get_original_type == "Int/Int 32") and (get_new_type == "Complex Int 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'i', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int64)
                np_data.tofile(get_new_file)
                
            # Int/Int 32 >> Complex Float 32, Float/Float 32
            elif (get_original_type == "Int/Int 32") and ((get_new_type == "Complex Float 32") or (get_new_type == "Float/Float 32")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'i', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.float32)
                np_data.tofile(get_new_file)
                
            # Int/Int 32 >> Complex Int 16, Short/Int 16
            elif (get_original_type == "Int/Int 32") and ((get_new_type == "Complex Int 16") or (get_new_type == "Short/Int 16")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'i', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int16)
                np_data.tofile(get_new_file)
                
            # Int/Int 32 >> Complex Int 8, Byte/Int 8
            elif (get_original_type == "Int/Int 32") and ((get_new_type == "Complex Int 8") or (get_new_type == "Byte/Int 8")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'i', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int8)
                np_data.tofile(get_new_file)
                
            # Complex Int 16, Short/Int 16 >> Complex Float 32, Float/Float 32
            elif ((get_original_type == "Complex Int 16") or (get_original_type == "Short/Int 16")) and ((get_new_type == "Complex Float 32") or (get_new_type == "Float/Float 32")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/2)*'h', plot_data)
                np_data = np.array(plot_data_formatted, dtype=np.float32)
                np_data.tofile(get_new_file)
                
            # Complex Int 16, Short/Int 16 >> Complex Float 64
            elif ((get_original_type == "Complex Int 16") or (get_original_type == "Short/Int 16")) and (get_new_type == "Complex Float 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/2)*'h', plot_data)
                np_data = np.array(plot_data_formatted, dtype=np.float64)
                np_data.tofile(get_new_file)
                
            # Complex Int 16, Short/Int 16 >> Complex Int 64
            elif ((get_original_type == "Complex Int 16") or (get_original_type == "Short/Int 16")) and (get_new_type == "Complex Int 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/2)*'h', plot_data)
                np_data = np.array(plot_data_formatted, dtype=np.int64)
                np_data.tofile(get_new_file)
                
            # Complex Int 16, Short/Int 16 >> Int/Int 32
            elif ((get_original_type == "Complex Int 16") or (get_original_type == "Short/Int 16")) and (get_new_type == "Int/Int 32"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/2)*'h', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int32)
                np_data.tofile(get_new_file)
                
            # Complex Int 16, Short/Int 16 >> Complex Int 8, Byte/Int 8
            elif ((get_original_type == "Complex Int 16") or (get_original_type == "Short/Int 16")) and ((get_new_type == "Complex Int 8") or (get_new_type == "Byte/Int 8")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/2)*'h', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int8)
                np_data.tofile(get_new_file)
                
            # Complex Int 8, Byte/Int 8 >> Complex Float 32, Float/Float 32
            elif ((get_original_type == "Complex Int 8") or (get_original_type == "Byte/Int 8")) and ((get_new_type == "Complex Float 32") or (get_new_type == "Float/Float 32")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes)*'b', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.float32)
                np_data.tofile(get_new_file)
                
            # Complex Int 8, Byte/Int 8 >> Complex Float 64
            elif ((get_original_type == "Complex Int 8") or (get_original_type == "Byte/Int 8")) and (get_new_type == "Complex Float 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes)*'b', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.float64)
                np_data.tofile(get_new_file)
                
            # Complex Int 8, Byte/Int 8 >> Complex Int 64
            elif ((get_original_type == "Complex Int 8") or (get_original_type == "Byte/Int 8")) and (get_new_type == "Complex Int 64"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes)*'b', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int64)
                np_data.tofile(get_new_file)
                
            # Complex Int 8, Byte/Int 8 >> Int/Int 32
            elif ((get_original_type == "Complex Int 8") or (get_original_type == "Byte/Int 8")) and (get_new_type == "Int/Int 32"):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes)*'b', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int32)
                np_data.tofile(get_new_file)
                
            # Complex Int 8, Byte/Int 8 >> Complex Int 16, Short/Int 16
            elif ((get_original_type == "Complex Int 8") or (get_original_type == "Byte/Int 8")) and ((get_new_type == "Complex Int 16") or (get_new_type == "Short/Int 16")):                
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes)*'b', plot_data)
                np_data = np.asarray(plot_data_formatted, dtype=np.int16)
                np_data.tofile(get_new_file)
                                  
            # Unknown
            else:
                self.errorMessage("Cannot convert " + str(get_original_type) + " to " + str(get_new_type) + ".")
                return
            
            print("Done.")
                                
    def _slotIQ_TerminalClicked(self):
        """ Opens a terminal to the current IQ folder.
        """
        # Open the Terminal
        get_dir = str(self.comboBox_iq_folders.currentText())
        proc=subprocess.Popen('gnome-terminal', cwd=get_dir, shell=True)

    def _slotIQ_TabClicked(self, button_name):
        """ Simulates a QTabWidget and changes the IQ QStackedWidget index.
        """
        # Change the Index
        if button_name == "pushButton_iq_tab_record":
            self.stackedWidget_iq.setCurrentIndex(0)
        elif button_name == "pushButton_iq_tab_playback":
            self.stackedWidget_iq.setCurrentIndex(1)
        elif button_name == "pushButton_iq_tab_inspection":
            self.stackedWidget_iq.setCurrentIndex(2)
        elif button_name == "pushButton_iq_tab_crop":
            self.stackedWidget_iq.setCurrentIndex(3)
        elif button_name == "pushButton_iq_tab_convert":
            self.stackedWidget_iq.setCurrentIndex(4)
        elif button_name == "pushButton_iq_tab_append":
            self.stackedWidget_iq.setCurrentIndex(5)
        elif button_name == "pushButton_iq_tab_transfer":
            self.stackedWidget_iq.setCurrentIndex(6)
        elif button_name == "pushButton_iq_tab_timeslot":
            self.stackedWidget_iq.setCurrentIndex(7)
        elif button_name == "pushButton_iq_tab_overlap":
            self.stackedWidget_iq.setCurrentIndex(8)
        elif button_name == "pushButton_iq_tab_resample":
            self.stackedWidget_iq.setCurrentIndex(9)
        elif button_name == "pushButton_iq_tab_ofdm":
            self.stackedWidget_iq.setCurrentIndex(10)
        elif button_name == "pushButton_iq_tab_normalize":
            self.stackedWidget_iq.setCurrentIndex(11)
        
        # Reset All Stylesheets                
        button_list = ['pushButton_iq_tab_record','pushButton_iq_tab_playback','pushButton_iq_tab_inspection','pushButton_iq_tab_crop','pushButton_iq_tab_convert','pushButton_iq_tab_append','pushButton_iq_tab_transfer','pushButton_iq_tab_timeslot','pushButton_iq_tab_overlap','pushButton_iq_tab_overlap','pushButton_iq_tab_resample','pushButton_iq_tab_ofdm','pushButton_iq_tab_normalize']
        for n in button_list:
            exec("self." + n + """.setStyleSheet("QPushButton#""" + n + """ {"
                                                "background-color: qlineargradient(spread:pad, x1:0, y1:0, x2:0, y2:1, stop:0 #e7eaee, stop:0.12 #455e7d, stop:0.3 #2e4a6d,   stop:0.85 #17365D, stop:1 #17365D);"
                                                "color: rgb(255, 255, 255);"
                                                "border: 1px solid #17365D;"
                                                "border-top-left-radius: 15px;"
                                                "border-top-right-radius: 15px;"
                                                "width:107px;"
                                                "margin-top: 6px;"
                                                "height: 21px;}"
                                                )""")
        
        # Change Selected Stylesheet
        exec("self." + button_name + """.setStyleSheet("QPushButton#""" + button_name + """ {"
                                                    "background-color: qlineargradient(spread:pad, x1:0, y1:0, x2:0, y2:1, stop:0 #e7eaee, stop:0.12 #455e7d, stop:0.3 #2e4a6d,   stop:0.85 #17365D, stop:1 #17365D);"
                                                    "color:rgb(0, 220, 0);"
                                                    "border: 1px solid #17365D;"
                                                    "border-top-left-radius: 15px;"
                                                    "border-top-right-radius: 15px;"
                                                    "height:27px;"
                                                    "margin-top: 3px;}"
                                                    )""")                                                  

    def _slotIQ_PolarClicked(self):
        """ Plots file data as a polar plot.
        """
        # Get the Filepath
        get_type = self.comboBox_iq_data_type.currentText()
        try:
            number_of_bytes = os.path.getsize(self.label_iq_folder.text() + "/"+self.listWidget_iq_files.currentItem().text())
        except:
            number_of_bytes = -1
            
        if number_of_bytes > 0:
            
            # Get the Number of Samples
            try:
                start_sample = int(self.textEdit_iq_start.toPlainText())
                end_sample = int(self.textEdit_iq_end.toPlainText())
                num_samples = end_sample - start_sample + 1
            except:
                return
            
            # Do Nothing if Bad Range
            if num_samples < 0:
                return
            
            # Do Not Load Large Amounts of Data
            if num_samples < 5000000:
        
                # Get the Size of Each Sample in Bytes      
                complex_multiple = 1
                if get_type == "Complex Float 32":
                    complex_multiple = 2
                    sample_size = 4
                    num_samples = complex_multiple * num_samples               
                elif get_type == "Float/Float 32":
                    sample_size = 4
                elif get_type == "Short/Int 16":
                    sample_size = 2
                elif get_type == "Int/Int 32":
                    sample_size = 4
                elif get_type == "Byte/Int 8":
                    sample_size = 1
                elif get_type == "Complex Int 16":
                    complex_multiple = 2
                    sample_size = 2
                    num_samples = complex_multiple * num_samples   
                elif get_type == "Complex Int 8":
                    complex_multiple = 2
                    sample_size = 1
                    num_samples = complex_multiple * num_samples                      
                elif get_type == "Complex Float 64":
                    complex_multiple = 2
                    sample_size = 8
                    num_samples = complex_multiple * num_samples                      
                elif get_type == "Complex Int 64":
                    complex_multiple = 2
                    sample_size = 8
                    num_samples = complex_multiple * num_samples                      
                    
                # Check the Range
                if (num_samples*sample_size > number_of_bytes) or (complex_multiple*end_sample*sample_size > number_of_bytes) or (start_sample < 1):
                    print("Out of range.")
                    return
                
                # Read the Data 
                filepath = self.label_iq_folder.text() + "/" + self.label_iq_file_name.text().replace("File: ","") 
                file = open(filepath,"rb")                          # Open the file
                if "Complex" in get_type:
                    file.seek(2*(start_sample-1) * sample_size)     # Point to the starting sample
                else:
                    file.seek((start_sample-1) * sample_size)       # Point to the starting sample
                plot_data = file.read(num_samples * sample_size)    # Read the right number of bytes
                file.close()
                
                # Format the Data
                if get_type == "Complex Float 32":
                    plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
                elif get_type == "Float/Float 32":
                    plot_data_formatted = struct.unpack(num_samples*'f', plot_data)
                elif get_type == "Short/Int 16":
                    plot_data_formatted = struct.unpack(num_samples*'h', plot_data)
                elif get_type == "Int/Int 32":
                    plot_data_formatted = struct.unpack(num_samples*'i', plot_data)
                elif get_type == "Byte/Int 8":
                    plot_data_formatted = struct.unpack(num_samples*'b', plot_data)
                elif get_type == "Complex Int 16":
                    plot_data_formatted = struct.unpack(num_samples*'h', plot_data)                    
                elif get_type == "Complex Int 8":
                    plot_data_formatted = struct.unpack(num_samples*'b', plot_data)  
                elif get_type == "Complex Float 64":
                    plot_data_formatted = struct.unpack(num_samples*'d', plot_data)  
                elif get_type == "Complex Int 64":
                    plot_data_formatted = struct.unpack(num_samples*'l', plot_data) 
                    
            # Too Many Samples
            else:
                self.errorMessage("Samples must be less than 5,000,000.")
                return
                    
            # Plot
            self.iq_matplotlib_widget.clearPlot()
            self.iq_matplotlib_widget.configureAxes(polar=True)
            self.iq_matplotlib_widget.axes.plot(2*np.pi*np.arange(0,complex_multiple,complex_multiple/float(len(plot_data_formatted))),plot_data_formatted,'bo',markersize=1)
            self.iq_matplotlib_widget.applyLabels("Polar Plot",'','Amplitude (LSB)',None,None)
            
            # Reset the Cursor and Draw
            self.pushButton_iq_cursor1.setChecked(False)
            self._slotIQ_Cursor1Clicked()  # Does the draw()
        
    def _slotIQ_NormalizeMinMaxChanged(self):
        """ Enables/Disables the min and max labels and comboboxes.
        """    
        # Enable Widgets
        if self.comboBox_iq_normalize_min_max.currentIndex() == 5:
            self.label_iq_normalize_min.setEnabled(True)
            self.textEdit_iq_normalize_min.setEnabled(True)
            self.label_iq_normalize_max.setEnabled(True)
            self.textEdit_iq_normalize_max.setEnabled(True)            
        
        # Disable Widgets
        else:
            self.label_iq_normalize_min.setEnabled(False)
            self.textEdit_iq_normalize_min.setEnabled(False)
            self.label_iq_normalize_max.setEnabled(False)
            self.textEdit_iq_normalize_max.setEnabled(False)                 
    
    def _slotIQ_NormalizeOriginalLoadClicked(self):
        """ Selects a file to convert to a new data type.
        """
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['Data File (*.*)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_normalize_original.setPlainText(folder)
        except:
            pass  
        
    def _slotIQ_NormalizeNewLoadClicked(self):
        """ Selects the location for the new data file.
        """
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['Data File (*.*)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_normalize_new.setPlainText(folder)
        except:
            pass   
        
    def _slotIQ_NormalizeCopyClicked(self):
        """ Copies the contents from the "Original File" text edit box to the "New File" text edit box.
        """
        # Copy the Contents
        get_original_file = str(self.textEdit_iq_normalize_original.toPlainText())
        filename_split = get_original_file.rsplit('.',1)
        if len(filename_split) == 2:
            self.textEdit_iq_normalize_new.setPlainText(filename_split[0] + "_norm." + filename_split[1])
        else:
            self.textEdit_iq_normalize_new.setPlainText(filename_split[0] + "_norm")

    def _slotIQ_NormalizeClicked(self):
        """ Normalizes data from a file and saves it to a new file.
        """
        # Get Min/Max
        if self.comboBox_iq_normalize_min_max.currentIndex() == 0:
            get_min = -1
            get_max = 1
        elif self.comboBox_iq_normalize_min_max.currentIndex() == 1:
            get_min = -128
            get_max = 127        
        elif self.comboBox_iq_normalize_min_max.currentIndex() == 2:
            get_min = -32768
            get_max = 32767      
        elif self.comboBox_iq_normalize_min_max.currentIndex() == 3:
            get_min = -2147483648
            get_max = 2147483647 
        elif self.comboBox_iq_normalize_min_max.currentIndex() == 4:
            get_min = -9223372036854775808
            get_max = 9223372036854775807
        else:
            try:
                get_min = float(self.textEdit_iq_normalize_min.toPlainText())
                get_max = float(self.textEdit_iq_normalize_max.toPlainText())
            except:
                print("Not a valid float.")
                return
        
        # Load the Data
        get_data_type = str(self.comboBox_iq_normalize_data_type.currentText())
        get_original_file = str(self.textEdit_iq_normalize_original.toPlainText())
        get_new_file = str(self.textEdit_iq_normalize_new.toPlainText())        

        # Files Selected
        if (len(get_original_file) > 0) and (len(get_new_file) > 0):
            # Read the Data 
            file = open(get_original_file,"rb")                    
            plot_data = file.read() 
            file.close()
            
            # Complex Float 64
            if (get_data_type == "Complex Float 64"):                
                # Normalize and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'d', plot_data)                
                np_data = np.asarray(plot_data_formatted, dtype=np.float64)
                array_min = float(min(np_data))
                array_max = float(max(np_data))
                for n in range(0, len(np_data)):
                    np_data[n] = (np_data[n] - array_min)*(get_max-get_min)/(array_max-array_min) + get_min
                np_data.tofile(get_new_file)            
                  
            # Complex Float 32
            elif (get_data_type == "Complex Float 32") or (get_data_type == "Float/Float 32"):                
                # Normalize and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'f', plot_data)                
                np_data = np.asarray(plot_data_formatted, dtype=np.float32)
                array_min = float(min(np_data))
                array_max = float(max(np_data))
                for n in range(0, len(np_data)):
                    np_data[n] = (np_data[n] - array_min)*(get_max-get_min)/(array_max-array_min) + get_min
                np_data.tofile(get_new_file)              
            
            # Complex Int 16
            elif (get_data_type == "Complex Int 16") or (get_data_type == "Short/Int 16"):               
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/2)*'h', plot_data)
                np_data = np.array(plot_data_formatted, dtype=np.int16)
                array_min = float(min(np_data))
                array_max = float(max(np_data))
                for n in range(0, len(np_data)):
                    np_data[n] = (float(np_data[n]) - array_min)*(get_max-get_min)/(array_max-array_min) + get_min
                np_data.tofile(get_new_file)
            
            # Complex Int 64
            elif (get_data_type == "Complex Int 64"):               
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/8)*'l', plot_data)
                np_data = np.array(plot_data_formatted, dtype=np.int64)
                array_min = float(min(np_data))
                array_max = float(max(np_data))
                for n in range(0, len(np_data)):
                    np_data[n] = (float(np_data[n]) - array_min)*(get_max-get_min)/(array_max-array_min) + get_min
                np_data.tofile(get_new_file)
                
            # Int/Int 32
            elif (get_data_type == "Int/Int 32"):               
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes/4)*'h', plot_data)
                np_data = np.array(plot_data_formatted, dtype=np.int32)
                array_min = float(min(np_data))
                array_max = float(max(np_data))
                for n in range(0, len(np_data)):
                    np_data[n] = (float(np_data[n]) - array_min)*(get_max-get_min)/(array_max-array_min) + get_min
                np_data.tofile(get_new_file)
                
            # Complex Int 8
            elif (get_data_type == "Complex Int 8") or (get_data_type == "Byte/Int 8"):               
                # Convert and Write
                print("Writing to file...")
                number_of_bytes = os.path.getsize(get_original_file)
                plot_data_formatted = struct.unpack(int(number_of_bytes)*'b', plot_data)
                np_data = np.array(plot_data_formatted, dtype=np.int8)
                array_min = float(min(np_data))
                array_max = float(max(np_data))
                for n in range(0, len(np_data)):
                    np_data[n] = (float(np_data[n]) - array_min)*(get_max-get_min)/(array_max-array_min) + get_min
                np_data.tofile(get_new_file)
            
            # Unknown
            else:
                self.errorMessage("Cannot normalize " + get_data_type + ".")
                return
                
            print("Done.")
    
    def _slotIQ_ResampleOriginalLoadClicked(self):
        """ Selects a file to convert to a new data type.
        """
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['Data File (*.*)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_resample_original_file.setPlainText(folder)
        except:
            pass  
        
    def _slotIQ_ResampleNewLoadClicked(self):
        """ Selects the location for the new data file.
        """
        # Select a File
        dialog = QtWidgets.QFileDialog(self)
        directory = os.path.dirname(os.path.realpath(__file__)) + "/IQ Recordings/"  # Default Directory
        dialog.setDirectory(directory)
        dialog.setNameFilters(['Data File (*.*)'])

        if dialog.exec_():
            for d in dialog.selectedFiles():
                folder = d
        try:           
            self.textEdit_iq_resample_new_file.setPlainText(folder)
        except:
            pass   
        
    def _slotIQ_ResampleCopyClicked(self):
        """ Copies the contents from the "Original File" text edit box to the "New File" text edit box.
        """
        # Copy the Contents
        get_original_file = str(self.textEdit_iq_resample_original_file.toPlainText())
        filename_split = get_original_file.rsplit('.',1)
        if len(filename_split) == 2:
            self.textEdit_iq_resample_new_file.setPlainText(filename_split[0] + "_resampled." + filename_split[1])
        else:
            self.textEdit_iq_resample_new_file.setPlainText(filename_split[0] + "_resampled")
            
    def _slotIQ_ResampleOriginalSelectClicked(self):
        """ Loads the current file selected in the list widget as the input file.
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_resample_original_file.setPlainText(get_folder + '/' + get_file) 
            
        except:
            pass
        
    def _slotIQ_ResampleNewSelectClicked(self):
        """ Loads the current file selected in the list widget as the output file. 
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_resample_new_file.setPlainText(get_folder + '/' + get_file) 
            
        except:
            pass            
            
    def _slotIQ_NormalizeOriginalSelectClicked(self):
        """ Loads the current file selected in the list widget as the input file.
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_normalize_original.setPlainText(get_folder + '/' + get_file) 
            
        except:
            pass    
    
    def _slotIQ_NormalizeNewSelectClicked(self):
        """ Loads the current file selected in the list widget as the output file. 
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_normalize_new.setPlainText(get_folder + '/' + get_file) 
            
        except:
            pass              
            
    def _slotIQ_ConvertNewSelectClicked(self):
        """ Loads the current file selected in the list widget as the output file. 
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_convert_original.setPlainText(get_folder + '/' + get_file) 
            
        except:
            pass          
        
    def _slotIQ_ConvertOriginalSelectClicked(self):
        """ Loads the current file selected in the list widget as the output file. 
        """
        try:
            # Get Highlighted File from Listbox
            get_file = str(self.listWidget_iq_files.currentItem().text())
            get_folder = str(self.label_iq_folder.text())
            self.textEdit_iq_convert_new.setPlainText(get_folder + '/' + get_file) 
            
        except:
            pass                
            
    def _slotMenu2022_2026_TechnicianPoolClicked(self):
        """ Opens the 2022-2026 Technician Pool pdf.
        """
        # Open the File
        pdf_location = os.path.dirname(os.path.realpath(__file__)) + "/Tools/Ham Radio Exam/2022-2026 Technician Pool Released Jan17 Revised.pdf" 
        os.system('evince "' + pdf_location + '" &')
        
    def _slotMenuLicenseSearchClicked(self):
        """ Opens a browser to the license search for the Universal Licensing System.
        """
        # Open a Browser 
        os.system("sensible-browser https://wireless2.fcc.gov/UlsApp/UlsSearch/searchLicense.jsp &")
                    
    def _slotMenuAnkiClicked(self):
        """ Opens Anki for reviewing flashcards.
        """
        # Launch Anki
        proc = subprocess.Popen("anki &", shell=True) 
        
    def _slotMenuAnkiDecksClicked(self):
        """ Opens a browser to download amateur radio Anki decks.
        """
        # Open a Browser 
        os.system("sensible-browser https://ankiweb.net/shared/decks/amateur%20radio &")
        
    def _slotMenuWavelengthCalculatorClicked(self):
        """ Opens a browser to a frequency to wavelength calculator.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.ahsystems.com/EMC-formulas-equations/frequency-wavelength-calculator.php &")                
                
    def _slotMenuAntennaSearchClicked(self):
        """ Opens a browser to AntennaSearch.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.antennasearch.com/ &")    
                
    def _slotMenuCommandClassSpecificationClicked(self):
        """ Opens the Z-Wave Application Command Class Specification (SDS13781).
        """
        # Open the File
        pdf_location = os.path.dirname(os.path.realpath(__file__)) + "/Tools/SDS13781-Z-Wave-Application-Command-Class-Specification.pdf" 
        os.system('evince "' + pdf_location + '" &')        
        
    def _slotMenuCommandClassListClicked(self):
        """ Opens the Z-Wave Command Class List.
        """
        # Issue the Command
        xlsx_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/SDS13548-List-of-defined-Z-Wave-Command-Classes.xlsx"
        command_text = 'libreoffice ' + xlsx_filepath + ' &'
        proc = subprocess.Popen(command_text, shell=True)     
        
    def _slotMenuSCADACoreRF_LineOfSightClicked(self):
        """ Opens the SCADACore RF Line-of-Sight plot tool in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.scadacore.com/tools/rf-path/rf-line-of-sight/ &") 
        
    def _slotMenuOnlineHexConverterClicked(self):
        """ Opens the SCADACore Online Hex Converter in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.scadacore.com/tools/programming-calculators/online-hex-converter/ &") 
        
    def _slotMenuExamLocationsClicked(self):
        """ Opens the ARRL page with instructions on how to register and find Amateur Radio License exam locations.
        """
        # Open a Browser 
        os.system("sensible-browser http://www.arrl.org/find-an-amateur-radio-license-exam-session &") 
        
    def _slotMenuEchoLinkLinkStatusClicked(self):
        """ Opens the online search for EchoLink links in a browser. Must register your call sign and provide proof of license to use EchoLink.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.echolink.org/links.jsp &") 
        
    def _slotTSI_DetectorSearchClicked(self):
        """ Switches to the Search tab and copies the selected frequency.
        """
        # Copy the Value
        get_row = self.tableWidget_tsi_wideband.currentRow()
        if get_row >= 0:
            get_freq = self.tableWidget_tsi_wideband.item(get_row,0).text()
            self.textEdit_library_search_frequency.setPlainText(get_freq)
        
            # Format the Search
            self.checkBox_library_search_frequency.setChecked(True)
            self.textEdit_library_search_frequency_margin.setPlainText("5")
            self.checkBox_library_search_start_frequency.setChecked(False)
            self.checkBox_library_search_end_frequency.setChecked(False)
            self.checkBox_library_search_bandwidth.setChecked(False)
            self.checkBox_library_search_modulation.setChecked(False)
            self.checkBox_library_search_continuous.setChecked(False)
            
            # Change Tabs
            self.tabWidget_library.setCurrentIndex(2)  # Search
            self.tabWidget.setCurrentIndex(7)  # Library
            
    def _slotMenuSolarHamClicked(self):
        """ Opens the SolarHam in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.solarham.net/ &") 
        
    def _slotTSI_DetectorCSV_FileBrowseClicked(self):
        """ Selects a CSV file for the TSI detector simulator.
        """
        # Look for a File
        default_directory = os.path.dirname(os.path.realpath(__file__)) +"/Tools/TSI_Detector_Sim_Data/"
        fname = QtWidgets.QFileDialog.getOpenFileName(None,"Select CSV File...", default_directory, filter="CSV Files (*.csv)")[0]

        # Valid File
        if fname != "":
            self.textEdit_tsi_detector_csv_file.setPlainText(fname)
            
    def _slotTSI_DetectorCSV_FileEditClicked(self):
        """ Opens the CSV file selected for the TSI detector simulator.
        """
        # Issue the Command
        csv_filepath = str(self.textEdit_tsi_detector_csv_file.toPlainText())
        if len(csv_filepath) > 0:
            command_text = 'libreoffice ' + csv_filepath + ' &'
            proc = subprocess.Popen(command_text, shell=True) 
        
    def _slotMenuBlessHexEditorClicked(self):
        """ Opens the Bless hex editor.
        """
        # Issue the Command
        proc = subprocess.Popen("bless", shell=True)   
        
    def _slotMenuTrackjackerClicked(self):
        """ Opens a terminal with an example trackerjacker command.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        trackerjacker_command = "sudo trackerjacker -i wlan1337 --map --map-file ~/wifi_map.yaml"        
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + trackerjacker_command + '"', shell=True) 
        
    def _slotMenuSanitizedIEEE_OUI_DataClicked(self):
        """ Open a browser to download updated OUI lists.
        """
        # Open a Browser 
        os.system("sensible-browser https://linuxnet.ca/ieee/oui/ &") 
                
    def _slotMenuMarineTrafficClicked(self):
        """ Opens MarineTraffic map in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.marinetraffic.com/ &")         
        
    def _slotMenuVesselFinderClicked(self):
        """ Opens VesselFinder map in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.vesselfinder.com/ &")         
        
    def _slotMenuBoatnerdClicked(self):
        """ Opens Boatnerd map in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://ais.boatnerd.com/ &")         
        
    def _slotMenuCruiseMapperClicked(self):
        """ Opens CruiseMapper map in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.cruisemapper.com/ &")         

    def _slotMenuLessonDataTypesClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson7_Data_Types.html &")
        
    def _slotMenuLessonCustomGNU_RadioBlocksClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson8_Custom_GNU_Radio_Blocks.html &")

    def _slotMenuADSB_ExchangeClicked(self):
        """ Opens ADS-B Exchange in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://globe.adsbexchange.com/ &")     
        
    def _slotMenuStandaloneClapperPlusTransmitClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/Clapper_Plus_Transmit.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   

    def _slotMenuStandaloneGarageDoorTransmitClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/Garage_Door_Transmit.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuStandaloneGarageDoorCycleClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/Garage_Door_Cycle.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuLessonTPMS_Clicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson9_TPMS.html &")  

    def _slotMenuHowToFileClicked(self):
        """ Opens RadioQTH page on how to file for a call sign in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser http://www.radioqth.net/howtofile/ &")    
        
    def _slotMenuRadioQTH_Clicked(self):
        """ Opens RadioQTH page for finding available call signs in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser http://www.radioqth.net/vanity/available &")    
        
    def _slotMenuAE7Q_Clicked(self):
        """ Opens AE7Q for finding available call signs in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://www.ae7q.com/query/ &")                    

    def _slotMenuAirgeddonClicked(self):
        """ Opens airgeddon in a terminal.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        airgeddon_directory = os.path.expanduser("~/Installed_by_FISSURE/airgeddon/")
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "sudo bash airgeddon.sh"', cwd=airgeddon_directory, shell=True)   
        
    def _slotMenuWhoisherePyClicked(self):
        """ Opens a terminal with whoishere.py command.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        whoishere_command = "sudo python2 whoishere.py"   
        whoishere_dir = os.path.dirname(os.path.realpath(__file__)) + "/Tools/whoishere.py-master/"  
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + whoishere_command + '"', cwd=whoishere_dir, shell=True)         
        
    def _slotMenuWhoishereConfClicked(self):
        """ Opens the whoishere.conf file.
        """
        # Open the File
        config_directory = os.path.dirname(os.path.realpath(__file__)) + "/Tools/whoishere.py-master/whoishere.conf"
        os.system("gedit " + config_directory + " &")        

    def _slotMenuHydraClicked(self):
        """ Opens a terminal with the Hydra command for brute-forcing SSH.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        password_list = os.path.dirname(os.path.realpath(__file__)) + "/Tools/Credentials/top-20-common-SSH-passwords.txt"  
        hydra_command = "hydra -l root -P " + password_list + " ssh://192.168.1.1 -t 4"   
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + hydra_command + '"', shell=True)     
        
    def _slotMenuSecListsClicked(self):
        """ Opens the SecLists GitHub page for usernames, passwords, and other data.
        """
        # Open a Browser 
        os.system("sensible-browser https://github.com/danielmiessler/SecLists &")            
            
    def _slotMenu_ssh_loginClicked(self):
        """ Opens a terminal with the Metasploit ssh_login command for brute-forcing SSH.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        password_list = os.path.dirname(os.path.realpath(__file__)) + "/Tools/Credentials/root_userpass.txt"  
        msf_command = """msfconsole -x \\\"use auxiliary/scanner/ssh/ssh_login; set RHOSTS 192.168.1.1; set USERPASS_FILE """ + password_list + """; run\\\" """   
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + msf_command + '"', shell=True)  
        
    def _slotMenuMetasploitWordlistsClicked(self):
        """ Opens the Metasploit Wordlists GitHub page for usernames, passwords, and other data.
        """
        # Open a Browser 
        os.system("sensible-browser https://github.com/rapid7/metasploit-framework/tree/master/data/wordlists &")          
        
    def _slotMenuOpenSSH_UsernameEnumerationClicked(self):
        """ Opens the command for a script used to enumerate SSH usernames for OpenSSH versions <7.2.
        """
        # Issue the Command
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        username_list = "multiplesources-users-fabian-fingerle.de.txt"  
        script_command = "python3 OpenSSH7-2_Username_Enumeration.py 192.168.1.1 -U " + username_list + " --factor 10"   
        script_dir = os.path.dirname(os.path.realpath(__file__)) + "/Tools/Credentials/"  
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + script_command + '"', cwd=script_dir, shell=True)  
               
    def _slotMenuLessonHamRadioExamsClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson10_Ham_Radio_Exams.html &") 
        
    def _slotMenu2019_2023_GeneralPoolClicked(self):
        """ Opens the 2019-2023 General Class Question Pool pdf.
        """
        # Open the File
        pdf_location = os.path.dirname(os.path.realpath(__file__)) + "/Tools/Ham Radio Exam/2019-2023GeneralClassQuestionPool.pdf" 
        os.system('evince "' + pdf_location + '" &')
        
    def _slotMenuGitHubFISSURE_Clicked(self):
        """ Opens the FISSURE GitHub page.
        """
        # Open a Browser 
        os.system("sensible-browser https://github.com/ainfosec/fissure &") 
        
    def _slotMenuGitHub_cpoore1_Clicked(self):
        """ Opens the cpoore1 GitHub page.
        """
        # Open a Browser 
        os.system("sensible-browser https://github.com/cpoore1 &") 
        
    def _slotMenuGitHub_ainfosecClicked(self):
        """ Opens the ainfosec GitHub page.
        """
        # Open a Browser 
        os.system("sensible-browser https://github.com/ainfosec &") 
        
    def _slotMenuLessonWiFiToolsClicked(self):
        """ Opens the html file in a browser.
        """
        os.system("sensible-browser " + os.path.dirname(os.path.realpath(__file__)) + "/Lessons/Lesson11_WiFi_Tools.html &")         
        
    def _slotMenuHelpPySDR_orgClicked(self):
        """ Opens PySDR.org in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://pysdr.org/ &") 
        
    def _slotMenuNrsc5_GuiClicked(self):
        """ Opens the nrsc5-gui for decoding HD radio signals.
        """
        # Issue the Command
        nrsc5_gui_filepath = os.path.expanduser("~/Installed_by_FISSURE/nrsc5-gui/")
        proc=subprocess.Popen('gnome-terminal -- ./nrsc5_gui.py', shell=True, cwd=nrsc5_gui_filepath)  
        
    def _slotMenuStandaloneJ2497_ModHackRF_Direct_Clicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/j2497_mod_hackrfdirect.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuStandaloneJ2497_fl2kClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/j2497_mod_fl2k.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuStandaloneJ2497_ModClicked(self):
        """ Opens the standalone flow graph in GNU Radio Companion.
        """
        # Open the Flow Graph in GNU Radio Companion
        filepath = os.path.dirname(os.path.realpath(__file__)) + "/Flow\ Graph\ Library/Standalone\ Flow\ Graphs/j2497_mod.grc"
        osCommandString = "gnuradio-companion " + filepath
        os.system(osCommandString+ " &")   
        
    def _slotMenuEnscribeClicked(self):
        """ Opens a terminal with an example command for enscribe.
        """
        # Open a Terminal
        expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
        enscribe_command = "enscribe -oversample -lf=5 -hf=70 -color=yb -wav input.jpg output.wav"   
        proc=subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + enscribe_command + '"', shell=True)       
        
    def _slotMenuOpenWeatherClicked(self):
        """ Opens the Open-weather website in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser https://open-weather.community/ &") 
        
    def _slotMenuLTE_ciphercheckClicked(self):
        """ Asks for config values and then runs LTE-ciphercheck.
        """
        # Open the Band Chooser Dialog
        dl_earfcn, done1 = QtWidgets.QInputDialog().getText(self, "Enter target DL_EARFCN", "dl_earfcn (blank=default)")
        apn, done2 = QtWidgets.QInputDialog().getText(self, "Enter target APN", "apn (blank=default)")
        imei, done3 = QtWidgets.QInputDialog().getText(self, "Enter target IMEI", "imei (blank=default)")
        if done1 and done2 and done3:
            # Rewrite the Config File
            with open(os.path.expanduser('~/Installed_by_FISSURE/LTE-ciphercheck/srsue/ciphercheck.conf'), 'r') as conf:
                data = conf.readlines()
                if len(dl_earfcn) > 0:
                    data[37] = "dl_earfcn = {}\n".format(dl_earfcn)
                if len(imei) > 0:
                    data[122] = "imei = {}\n".format(imei)
                if len(apn) > 0:
                    data[158] = "apn = {}\n".format(apn)
                with open(os.path.expanduser('~/Installed_by_FISSURE/LTE-ciphercheck/srsue/ciphercheck.conf'), 'w') as conf:
                    conf.writelines(data)
            
            # Open a Terminal
            expect_script_filepath = os.path.dirname(os.path.realpath(__file__)) + "/Tools/expect_script" 
            srsue_location = os.path.expanduser("~/Installed_by_FISSURE/LTE-ciphercheck/build/srsue/src") 
            config_file_location = os.path.expanduser("~/Installed_by_FISSURE/LTE-ciphercheck/srsue/ciphercheck.conf")            
            command_text = 'sudo ./srsue ' + config_file_location
            proc = subprocess.Popen('gnome-terminal -- ' + expect_script_filepath + ' "' + command_text + '"', cwd=srsue_location, shell=True)    
            
    def _slotMenuElectromagneticRadiationSpectrumClicked(self):
        """ Opens the unihedron Electromagnetic Radiation Spectrum Poster in a browser.
        """
        # Open a Browser 
        os.system("sensible-browser http://www.unihedron.com/projects/spectrum/downloads/full_spectrum.jpg &") 
        
        

class HelpMenuDialog(QtWidgets.QDialog, form_class6):
    def __init__(self):
        """ First thing that executes.
        """
        QtWidgets.QDialog.__init__(self)            
        self.setupUi(self)       
            
        # Prevent Resizing/Maximizing
        self.setFixedSize(700, 700)         
        
        # Do SIGNAL/Slots Connections
        self._connectSlots()    
    
    def _connectSlots(self):
        """ Contains the connect functions for all the signals and slots
        """        
        # Combo Boxes       
        self.comboBox_how_to.currentIndexChanged.connect(self._slotHowToTabChanged)

    def _slotHowToTabChanged(self):
        """ Changes the stacked widget index in the help dialog how to section depending on which item in the combobox is selected.
        """
        # Change the Stacked Widget
        self.stackedWidget_how_to.setCurrentIndex(self.comboBox_how_to.currentIndex())
        
        
class VLine(QtWidgets.QFrame):
    """ Vertical line for the statusbar.
    """
    # a simple VLine, like the one you get from designer
    def __init__(self, parent):
        super(VLine, self).__init__(parent)
        self.parent = parent
        self.setFrameShape(self.VLine|self.Sunken)
        #self.setMaximumWidth(2)
        
        
class StatusLabel(QtWidgets.QLabel):
    def __init__(self, parent):
        super(StatusLabel, self).__init__(parent)
        self.parent = parent
        self.setAutoFillBackground(True)
        p = self.palette()
        p.setColor(self.backgroundRole(), QtGui.QColor(223, 230, 248))
        self.setPalette(p)
        self.setMouseTracking(True)
        self.setFont(QtGui.QFont("Ubuntu",10))

    def enterEvent(self, event):
        self.parent.status_dialog.show()

    def leaveEvent(self, event):
        self.parent.status_dialog.hide()
        
class CustomStatusBar(QtWidgets.QStatusBar):
    def __init__(self, parent):
        super(CustomStatusBar, self).__init__(parent)
        self.parent = parent
        #self.setAutoFillBackground(True)
        #p = self.palette()
        #p.setColor(self.backgroundRole(), QtGui.QColor(223, 230, 248))
        #self.setPalette(p)
        self.setMouseTracking(True)
        self.setFont(QtGui.QFont("Ubuntu",10))

    def enterEvent(self, event):
        self.parent.status_dialog.show()

    def leaveEvent(self, event):
        self.parent.status_dialog.hide()

class StatusDialog(QtWidgets.QFrame, form_class7):
    def __init__(self, parent):
        """ First thing that executes.
        """
        QtWidgets.QDialog.__init__(self, parent)
        self.parent = parent             
        self.setupUi(self)       
            
        # Prevent Resizing/Maximizing
        # ~ self.setFixedSize(700, 500)         
        
class MiscChooser(QtWidgets.QDialog, form_class8):
    def __init__(self, parent, label_text, chooser_items):
        """ Multi-purpose combobox.
        """
        QtWidgets.QDialog.__init__(self,parent)        
        self.parent = parent        
        self.setupUi(self)     
        self.return_value = ""
        
        # Prevent Resizing/Maximizing
        self.setFixedSize(205, 120)    
        
        # Connect Slots
        self.pushButton_ok.clicked.connect(self._slotOK_Clicked)
        self.pushButton_cancel.clicked.connect(self._slotCancelClicked) 
        
        # Update Label Text
        self.label_1.setText(label_text)
        
        # Update Combobox Items
        self.comboBox_1.addItems(chooser_items)
        
    def _slotOK_Clicked(self):
        self.return_value = str(self.comboBox_1.currentText())
        self.close()
               
    def _slotCancelClicked(self):
        self.reject()
        
class NewSOI(QtWidgets.QDialog, form_class9):
    def __init__(self, parent):
        """ Creates a new Signal of Interest in Protocol Discovery.
        """
        QtWidgets.QDialog.__init__(self,parent)        
        self.parent = parent        
        self.setupUi(self)     
        self.return_value = ""
        
        # Prevent Resizing/Maximizing
        self.setFixedSize(380, 300)    
        
        # Connect Slots
        self.pushButton_ok.clicked.connect(self._slotOK_Clicked)
        self.pushButton_cancel.clicked.connect(self._slotCancelClicked) 
        
        # Fill in Default Values as Last SOI
        if len(self.parent.target_soi) > 0:
            self.textEdit_frequency.setPlainText(str(self.parent.target_soi[0]))
            self.textEdit_modulation.setPlainText(str(self.parent.target_soi[1]))
            self.textEdit_bandwidth.setPlainText(str(self.parent.target_soi[2]))
            
            if self.parent.target_soi[3] == "True":
                self.comboBox_continuous.setCurrentIndex(0)
            else:
                self.comboBox_continuous.setCurrentIndex(1)

            self.textEdit_start_frequency.setPlainText(str(self.parent.target_soi[4]))
            self.textEdit_end_frequency.setPlainText(str(self.parent.target_soi[5]))
            self.textEdit_notes.setPlainText(str(self.parent.target_soi[6]))
        
    def _slotOK_Clicked(self):
        self.return_value = "1"
                
        # Assemble the Target SOI
        get_frequency = str(self.textEdit_frequency.toPlainText())
        get_modulation = str(self.textEdit_modulation.toPlainText())
        get_bandwidth = str(self.textEdit_bandwidth.toPlainText())
        get_continuous = str(self.comboBox_continuous.currentText())
        get_start_frequency = str(self.textEdit_start_frequency.toPlainText())
        get_end_frequency = str(self.textEdit_end_frequency.toPlainText())
        get_notes = str(self.textEdit_notes.toPlainText())
        
        self.parent.target_soi = [get_frequency, get_modulation, get_bandwidth, get_continuous, get_start_frequency, get_end_frequency, get_notes]
        self.close()
               
    def _slotCancelClicked(self):
        self.reject()        
        
    
class HardwareSelectDialog(QtWidgets.QDialog, form_class5):
    def __init__(self, parent, mode, hardware, ip, serial, interface, daughterboard):
        """ First thing that executes.
        """
        #super(HardwareSelectDialog, self).__init__(parent)  # Same thing as the line below
        QtWidgets.QDialog.__init__(self,parent)        
        self.parent = parent        
        self.setupUi(self)       
            
        # Prevent Resizing/Maximizing
        self.setFixedSize(950, 115)         
        
        # Do SIGNAL/Slots Connections
        self._connectSlots()    
        
        # Update Display        
        self.label_mode.setText(mode)
        self.label_probe.setVisible(False)
        self._slotHardwareChanged()

        if hardware == "Computer":
            self.comboBox_hardware.setCurrentIndex(0)
        elif hardware == "USRP X310":
            self.comboBox_hardware.setCurrentIndex(1)
        elif hardware == "USRP B210":
            self.comboBox_hardware.setCurrentIndex(2)
        elif hardware == "HackRF":
            self.comboBox_hardware.setCurrentIndex(3)
        elif hardware == "RTL2832U":
            self.comboBox_hardware.setCurrentIndex(4)            
        elif hardware == "802.11x Adapter":
            self.comboBox_hardware.setCurrentIndex(5)
        elif hardware == "USRP B205mini":
            self.comboBox_hardware.setCurrentIndex(6)
        elif hardware == "LimeSDR":
            self.comboBox_hardware.setCurrentIndex(7)
        elif hardware == "bladeRF":
            self.comboBox_hardware.setCurrentIndex(8)
        elif hardware == "Open Sniffer":
            self.comboBox_hardware.setCurrentIndex(9)            
        
        self.textEdit_ip.setPlainText(ip)
        self.textEdit_ip.setAlignment(QtCore.Qt.AlignCenter)
        self.textEdit_serial.setPlainText(serial)
        self.textEdit_serial.setAlignment(QtCore.Qt.AlignCenter)
        self.textEdit_interface.setPlainText(interface)
        self.textEdit_interface.setAlignment(QtCore.Qt.AlignCenter)       
        
        if "CBX" in daughterboard:
            self.comboBox_daughterboard.setCurrentIndex(0)
        elif "SBX" in daughterboard:
            self.comboBox_daughterboard.setCurrentIndex(1)
        elif "UBX" in daughterboard:
            self.comboBox_daughterboard.setCurrentIndex(2)
        elif "WBX" in daughterboard:
            self.comboBox_daughterboard.setCurrentIndex(3)                    
    
    def _connectSlots(self):
        """ Contains the connect functions for all the signals and slots
        """
        # Push Buttons
        self.pushButton_ok.clicked.connect(self._slotOK_Clicked)
        self.pushButton_cancel.clicked.connect(self._slotCancelClicked)
        self.pushButton_guess.clicked.connect(self._slotGuessClicked)
        self.pushButton_probe_usrp.clicked.connect(self._slotProbeClicked)
        self.pushButton_apply_to_all.clicked.connect(self._slotApplyToAllClicked)
        
        # Combo Boxes       
        self.comboBox_hardware.currentIndexChanged.connect(self._slotHardwareChanged)

    def _slotOK_Clicked(self):
        """ Save hardware select changes and closes the window.
        """
        if "TSI" in self.label_mode.text():
            self.parent.dashboard_settings_dictionary['hardware_tsi'] = str(self.comboBox_hardware.currentText())
            self.parent.dashboard_settings_dictionary['hardware_ip_tsi'] = str(self.textEdit_ip.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_serial_tsi'] = str(self.textEdit_serial.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_interface_tsi'] = str(self.textEdit_interface.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_daughterboard_tsi'] = str(self.comboBox_daughterboard.currentText())
            self.parent.configureTSI_Hardware()
        
        elif "PD" in self.label_mode.text():
            self.parent.dashboard_settings_dictionary['hardware_pd'] = str(self.comboBox_hardware.currentText())
            self.parent.dashboard_settings_dictionary['hardware_ip_pd'] = str(self.textEdit_ip.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_serial_pd'] = str(self.textEdit_serial.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_interface_pd'] = str(self.textEdit_interface.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_daughterboard_pd'] = str(self.comboBox_daughterboard.currentText())
            self.parent.configurePD_Hardware()
            
        elif "Attack" in self.label_mode.text():
            self.parent.dashboard_settings_dictionary['hardware_attack'] = str(self.comboBox_hardware.currentText())
            self.parent.dashboard_settings_dictionary['hardware_ip_attack'] = str(self.textEdit_ip.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_serial_attack'] = str(self.textEdit_serial.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_interface_attack'] = str(self.textEdit_interface.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_daughterboard_attack'] = str(self.comboBox_daughterboard.currentText())
            self.parent.configureAttackHardware()
            
        elif "IQ" in self.label_mode.text():
            self.parent.dashboard_settings_dictionary['hardware_iq'] = str(self.comboBox_hardware.currentText())
            self.parent.dashboard_settings_dictionary['hardware_ip_iq'] = str(self.textEdit_ip.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_serial_iq'] = str(self.textEdit_serial.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_interface_iq'] = str(self.textEdit_interface.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_daughterboard_iq'] = str(self.comboBox_daughterboard.currentText())
            self.parent.configureIQ_Hardware()
            
        elif "Archive" in self.label_mode.text():
            self.parent.dashboard_settings_dictionary['hardware_archive'] = str(self.comboBox_hardware.currentText())
            self.parent.dashboard_settings_dictionary['hardware_ip_archive'] = str(self.textEdit_ip.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_serial_archive'] = str(self.textEdit_serial.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_interface_archive'] = str(self.textEdit_interface.toPlainText())
            self.parent.dashboard_settings_dictionary['hardware_daughterboard_archive'] = str(self.comboBox_daughterboard.currentText())
            self.parent.configureArchiveHardware()            
        
        self.accept()
        
    def _slotCancelClicked(self):
        """ Does not save hardware select changes and closes the window.
        """
        self.accept()
        
    def _slotGuessClicked(self):
        """ Guesses the IP address, serial number, interface, and daughterboard for the current hardware setup.
        """
        if str(self.comboBox_hardware.currentText()) == "Computer":
            pass        
        elif str(self.comboBox_hardware.currentText()) == "USRP X310":       
            self.parent.findX310(self.textEdit_ip, self.textEdit_serial, self.comboBox_daughterboard, self.label_probe)          
        elif str(self.comboBox_hardware.currentText()) == "USRP B210":
            self.parent.findB210(self.textEdit_serial)
        elif str(self.comboBox_hardware.currentText()) == "HackRF":
            self.parent.findHackRF(self.textEdit_serial)
        elif str(self.comboBox_hardware.currentText()) == "RTL2832U":
            pass
        elif str(self.comboBox_hardware.currentText()) == "802.11x Adapter":
            self.parent.find80211x(self.textEdit_interface)
        elif str(self.comboBox_hardware.currentText()) == "USRP B205mini":
            self.parent.findB205mini(self.textEdit_serial)   
        elif str(self.comboBox_hardware.currentText()) == "LimeSDR":
            self.parent.findLimeSDR(self.textEdit_serial)
        elif str(self.comboBox_hardware.currentText()) == "bladeRF":
            pass
        elif str(self.comboBox_hardware.currentText()) == "Open Sniffer":
            pass            

    def _slotProbeClicked(self):
        """ Opens a message box and copies the results of "uhd_usrp_probe xxx.xxx.xxx.xxx"
        """
        if str(self.comboBox_hardware.currentText()) == "USRP X310":
            # Get IP Address
            get_ip = str(self.textEdit_ip.toPlainText())
            
            # Probe
            try:
                self.label_probe.setVisible(True)
                QtWidgets.QApplication.processEvents()
                proc = subprocess.Popen('uhd_usrp_probe --args="addr=' + get_ip + '" &', shell=True, stdout=subprocess.PIPE, )
                output = proc.communicate()[0].decode()
                self.label_probe.setVisible(False)
            except:
                self.label_probe.setVisible(False)
                output = "Error"            
                
            # Create a Dialog Window    
            msgBox = MyMessageBox(my_text = output)
            msgBox.exec_()    
            
        elif (str(self.comboBox_hardware.currentText()) == "USRP B210") or (str(self.comboBox_hardware.currentText()) == "USRP B205mini"):
            # Probe
            try:
                self.label_probe.setVisible(True)
                QtWidgets.QApplication.processEvents()
                proc = subprocess.Popen('uhd_usrp_probe --args="type=b200" &', shell=True, stdout=subprocess.PIPE, )
                output = proc.communicate()[0].decode()
                self.label_probe.setVisible(False)               
            except:
                self.label_probe.setVisible(False)
                output = "Error"            
                
            # Create a Dialog Window    
            msgBox = MyMessageBox(my_text = output)
            msgBox.exec_() 
            
        elif (str(self.comboBox_hardware.currentText()) == "bladeRF"):
            # Probe
            try:
                self.label_probe.setVisible(True)
                QtWidgets.QApplication.processEvents()
                proc=subprocess.Popen('bladeRF-cli -p &', shell=True, stdout=subprocess.PIPE, )
                output=proc.communicate()[0].decode()
                self.label_probe.setVisible(False)               
            except:
                self.label_probe.setVisible(False)
                output = "Error"            
                
            # Create a Dialog Window    
            msgBox = MyMessageBox(my_text = output)
            msgBox.exec_() 
            
        elif (str(self.comboBox_hardware.currentText()) == "LimeSDR"):
            # Probe
            try:
                self.label_probe.setVisible(True)   
                QtWidgets.QApplication.processEvents()            
                proc=subprocess.Popen('LimeUtil --find &', shell=True, stdout=subprocess.PIPE, )
                output=proc.communicate()[0].decode()
                self.label_probe.setVisible(False)                
            except:
                self.label_probe.setVisible(False)
                output = "Error"            
                
            # Create a Dialog Window    
            msgBox = MyMessageBox(my_text = output, height = 75, width = 700)
            msgBox.exec_() 
            
        elif (str(self.comboBox_hardware.currentText()) == "HackRF"):
            # Probe
            try:
                self.label_probe.setVisible(True)   
                QtWidgets.QApplication.processEvents()            
                proc=subprocess.Popen('hackrf_info &', shell=True, stdout=subprocess.PIPE, )
                output=proc.communicate()[0].decode()
                self.label_probe.setVisible(False)                
            except:
                self.label_probe.setVisible(False)
                output = "Error"            
                
            # Create a Dialog Window    
            msgBox = MyMessageBox(my_text = output, height = 300, width = 500)
            msgBox.exec_() 
                        
    def _slotHardwareChanged(self):
        """ Updates display options for selected hardware.
        """
        # Clear Text
        self.textEdit_ip.setPlainText("")
        self.textEdit_serial.setPlainText("")		
        self.textEdit_interface.setPlainText("")        
        self.textEdit_ip.setAlignment(QtCore.Qt.AlignCenter)
        self.textEdit_serial.setAlignment(QtCore.Qt.AlignCenter)
        self.textEdit_interface.setAlignment(QtCore.Qt.AlignCenter)       
        
        # Set Visibility    
        if str(self.comboBox_hardware.currentText()) == "Computer":
            self.textEdit_ip.setVisible(False)
            self.textEdit_serial.setVisible(False) 
            self.pushButton_guess.setVisible(False)     	
            self.pushButton_probe_usrp.setVisible(False)
            self.textEdit_interface.setVisible(False)
            self.comboBox_daughterboard.setVisible(False)        
        elif str(self.comboBox_hardware.currentText()) == "USRP X310":
            self.textEdit_ip.setVisible(True)
            self.textEdit_serial.setVisible(True)		
            self.pushButton_guess.setVisible(True)
            self.pushButton_probe_usrp.setVisible(True)
            self.textEdit_interface.setVisible(False)	
            self.comboBox_daughterboard.setVisible(True)
        elif str(self.comboBox_hardware.currentText()) == "USRP B210":
            self.textEdit_ip.setVisible(False)
            self.textEdit_serial.setVisible(True)
            self.pushButton_guess.setVisible(True)
            self.pushButton_probe_usrp.setVisible(True)
            self.textEdit_interface.setVisible(False)
            self.comboBox_daughterboard.setVisible(False)
        elif str(self.comboBox_hardware.currentText()) == "HackRF":
            self.textEdit_ip.setVisible(False)
            self.textEdit_serial.setVisible(True)
            self.pushButton_guess.setVisible(True)
            self.pushButton_probe_usrp.setVisible(True)
            self.textEdit_interface.setVisible(False)
            self.comboBox_daughterboard.setVisible(False)
        elif str(self.comboBox_hardware.currentText()) == "RTL2832U":
            self.textEdit_ip.setVisible(False)
            self.textEdit_serial.setVisible(False)      
            self.pushButton_guess.setVisible(False)   
            self.pushButton_probe_usrp.setVisible(False)
            self.textEdit_interface.setVisible(False)
            self.comboBox_daughterboard.setVisible(False)
        elif str(self.comboBox_hardware.currentText()) == "802.11x Adapter":
            self.textEdit_ip.setVisible(False)
            self.textEdit_serial.setVisible(False) 
            self.pushButton_guess.setVisible(True)     	
            self.pushButton_probe_usrp.setVisible(False)
            self.textEdit_interface.setVisible(True)
            self.comboBox_daughterboard.setVisible(False)
        elif str(self.comboBox_hardware.currentText()) == "USRP B205mini":
            self.textEdit_ip.setVisible(False)
            self.textEdit_serial.setVisible(True)
            self.pushButton_guess.setVisible(True)
            self.pushButton_probe_usrp.setVisible(True)
            self.textEdit_interface.setVisible(False)   
            self.comboBox_daughterboard.setVisible(False)
        elif str(self.comboBox_hardware.currentText()) == "LimeSDR":
            self.textEdit_ip.setVisible(False)
            self.textEdit_serial.setVisible(True)
            self.pushButton_guess.setVisible(True)
            self.pushButton_probe_usrp.setVisible(True)
            self.textEdit_interface.setVisible(False)    
            self.comboBox_daughterboard.setVisible(False)
        elif str(self.comboBox_hardware.currentText()) == "bladeRF":
            self.textEdit_ip.setVisible(False)
            self.textEdit_serial.setVisible(True)
            self.pushButton_guess.setVisible(True)
            self.pushButton_probe_usrp.setVisible(True)
            self.textEdit_interface.setVisible(False)   
            self.comboBox_daughterboard.setVisible(False)
        elif str(self.comboBox_hardware.currentText()) == "Open Sniffer":
            self.textEdit_ip.setVisible(True)
            self.textEdit_serial.setVisible(False) 
            self.pushButton_guess.setVisible(True)     	
            self.pushButton_probe_usrp.setVisible(True)
            self.textEdit_interface.setVisible(False)
            self.comboBox_daughterboard.setVisible(False)            
            
    def _slotApplyToAllClicked(self):
        """ Save the current radio settings to all components.
        """
        # Save for All Four Components
        self.parent.dashboard_settings_dictionary['hardware_tsi'] = str(self.comboBox_hardware.currentText())
        self.parent.dashboard_settings_dictionary['hardware_ip_tsi'] = str(self.textEdit_ip.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_serial_tsi'] = str(self.textEdit_serial.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_interface_tsi'] = str(self.textEdit_interface.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_daughterboard_tsi'] = str(self.comboBox_daughterboard.currentText())
        self.parent.configureTSI_Hardware()    

        self.parent.dashboard_settings_dictionary['hardware_pd'] = str(self.comboBox_hardware.currentText())
        self.parent.dashboard_settings_dictionary['hardware_ip_pd'] = str(self.textEdit_ip.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_serial_pd'] = str(self.textEdit_serial.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_interface_pd'] = str(self.textEdit_interface.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_daughterboard_pd'] = str(self.comboBox_daughterboard.currentText())
        self.parent.pushButton_top_pd.setToolTip(self.parent.dashboard_settings_dictionary['hardware_pd'])
        self.parent.configurePD_Hardware()        

        self.parent.dashboard_settings_dictionary['hardware_attack'] = str(self.comboBox_hardware.currentText())
        self.parent.dashboard_settings_dictionary['hardware_ip_attack'] = str(self.textEdit_ip.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_serial_attack'] = str(self.textEdit_serial.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_interface_attack'] = str(self.textEdit_interface.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_daughterboard_attack'] = str(self.comboBox_daughterboard.currentText())
        self.parent.pushButton_top_attack.setToolTip(self.parent.dashboard_settings_dictionary['hardware_attack'])
        self.parent.configureAttackHardware()        

        self.parent.dashboard_settings_dictionary['hardware_iq'] = str(self.comboBox_hardware.currentText())
        self.parent.dashboard_settings_dictionary['hardware_ip_iq'] = str(self.textEdit_ip.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_serial_iq'] = str(self.textEdit_serial.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_interface_iq'] = str(self.textEdit_interface.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_daughterboard_iq'] = str(self.comboBox_daughterboard.currentText())
        self.parent.pushButton_top_iq.setToolTip(self.parent.dashboard_settings_dictionary['hardware_iq'])
        self.parent.configureIQ_Hardware()     
        
        self.parent.dashboard_settings_dictionary['hardware_archive'] = str(self.comboBox_hardware.currentText())
        self.parent.dashboard_settings_dictionary['hardware_ip_archive'] = str(self.textEdit_ip.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_serial_archive'] = str(self.textEdit_serial.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_interface_archive'] = str(self.textEdit_interface.toPlainText())
        self.parent.dashboard_settings_dictionary['hardware_daughterboard_archive'] = str(self.comboBox_daughterboard.currentText())
        self.parent.pushButton_top_archive.setToolTip(self.parent.dashboard_settings_dictionary['hardware_archive'])
        self.parent.configureArchiveHardware()                 
        
        self.accept()        
                  
                  
        
class MyPlotWindow(QtWidgets.QDialog):
    def __init__(self, parent=None, entropy_data = None, width=700, height=700):
        QtWidgets.QDialog.__init__(self)
        #~ label = QtWidgets.QLabel(self)
        #~ label.setText(my_text)
        scroll = QtWidgets.QScrollArea(self)
        scroll.setGeometry(QtCore.QRect(0,0,width,height))
        #~ scroll.setWidget(label)
        scroll.setWidgetResizable(True)
        okButton = QtWidgets.QPushButton(self)
        okButton.clicked.connect(self.closeWindow)
        okButton.setGeometry(QtCore.QRect(300,650,100,30))
        okButton.setText("OK")
        
        
        # Create Matplotlib Widget
        entropy_mpl_widget = EntropyMplCanvas(self)
        #~ entropy_mpl_widget.move(0,0)
        entropy_mpl_widget.setGeometry(50,0,600,600) 

        
        # Add a Toolbar
        mpl_toolbar = NavigationToolbar(entropy_mpl_widget, self)
        mpl_toolbar.setGeometry(QtCore.QRect(175, 600, 525, 35)) 
        
        # Plot the Data
        entropy_mpl_widget.axes.plot(range(0,len(entropy_data)), entropy_data, label='pre (default)', marker='.')
        entropy_mpl_widget.configureAxes("Bit Position Entropy Values",'Bit Position','Entropy',None,None)    
        entropy_mpl_widget.draw()
        
    def closeWindow(self):
        self.accept()     
        
        
class EntropyMplCanvas(FigureCanvas):
    def __init__(self, parent=None, dpi=100, title=None):
        """ Creates a plot for the bit entropy data and places it in a figure canvas
        """        
        # Background Color
        background_color = (242.0/255, 241.0/255, 240.0/255, 1)  #QtGui.QColor(242,241,240)
            
        # Set up the Figure
        fig = Figure(dpi=dpi, facecolor=background_color)
        self.axes = fig.add_subplot(111)
        
        # ~ # Ignore hold() Deprecation Warnings
        # ~ with warnings.catch_warnings():
            # ~ warnings.simplefilter("ignore")
            # ~ warnings.filterwarnings("ignore", module="matplotlib")
            # ~ #self.axes.hold(False)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
            
        fig.subplots_adjust(left=0.1,right=0.95,bottom=0.1,top=0.95,wspace=0,hspace=0)
        
        # Do the Plotting
        self.configureAxes(title,'Bit Position','Entropy',None,None)         
        
        # Other
        FigureCanvas.__init__(self, fig)
        self.setParent(parent)
        FigureCanvas.setSizePolicy(self, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)
        
    def configureAxes(self, title, xlabel, ylabel, ylabels, ylim):
        """ Configures the axes, needs to be called for every plot because hold(False) will redo the axes setup
        """     
        try:
            # Define the Size       
            #self.axes.axis([0, width, height, 0])
            
            # Set the Limits
            self.axes.set_ylim([-.1, 1.1])
                    
            # Set the Labels, Gridlines
            self.axes.set_title(title)
            
            self.axes.set_xlabel(xlabel)
            self.axes.xaxis.grid('on')  
            
            self.axes.set_ylabel(ylabel)
            self.axes.yaxis.grid('on')  
        except:
            pass           
    
                
class MyMessageBox(QtWidgets.QDialog):
    def __init__(self, parent=None, my_text= "", width=480, height=600):
        QtWidgets.QDialog.__init__(self)
        label = QtWidgets.QLabel(self)
        label.setTextInteractionFlags(QtCore.Qt.TextSelectableByMouse)
        label.setText(my_text)
        scroll = QtWidgets.QScrollArea(self)
        scroll.setGeometry(QtCore.QRect(10,20,width,height))
        scroll.setWidget(label)
        scroll.setWidgetResizable(True)
        okButton = QtWidgets.QPushButton(self)
        okButton.clicked.connect(self.closeWindow)
        okButton.setGeometry(QtCore.QRect(int(width/2-40),height+30,100,30))
        okButton.setText("OK")
        
    def setDimensions(self, new_width, new_height):
        """ Resizes the dialog window.
        """
        self.width = new_width
        height = new_height
        
    def closeWindow(self):
        self.accept()
                
                
class MyMplCanvas(FigureCanvas):
    def __init__(self, parent=None, dpi=100, title=None, ylim=None, width=401, height=401, border = [0.1,0.9,0.01,0.99,0,0], colorbar_fraction = 0.038, xlabels=['0', '','1000', '', '2000', '', '3000', '', '4000', '', '5000', '', '6000'], ylabels=['0', '5', '10', '15', '20']):
        """ Creates a plot with colorbar and places it in a figure canvas
        """
        self.plot_width = width
        self.plot_height = height
            
        # Background Color
        background_color = (244.0/255, 244.0/255, 244.0/255, 1)  #QtGui.QColor(242,241,240)
            
        # Set up the Figure
        fig = Figure(dpi=dpi, facecolor=background_color)
        self.axes = fig.add_subplot(111)
        
        # ~ # Ignore hold() Deprecation Warnings
        # ~ with warnings.catch_warnings():
            # ~ warnings.simplefilter("ignore")
            # ~ warnings.filterwarnings("ignore", module="matplotlib")
            # ~ #self.axes.hold(False)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
             
        fig.subplots_adjust(left=border[0],right=border[1],bottom=border[2],top=border[3],wspace=border[4],hspace=border[5])
        
        # Create the Data Arrays
        temp_plot_data = np.ones((self.plot_height,self.plot_width,3))  # background color (1,1,1)   
        
        # Do the Plotting
        img = self.axes.imshow(temp_plot_data, cmap='rainbow', clim=(-60,40))      
        self.configureAxes(title,'Frequency (MHz)',xlabels,'Time Elapsed',ylabels,ylim)                
        cbar = fig.colorbar(img, fraction=colorbar_fraction*ylim/500, pad=.04, label='Power (dB)')    
        cbar.ax.tick_params(labelsize=11) 
                
        # Other
        FigureCanvas.__init__(self, fig)
        self.setParent(parent)
        FigureCanvas.setSizePolicy(self, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)
                
    def configureAxesZoom1(self, xmin, xmax, wideband_height):
        """ Configures the axes for wideband zoom. Not implemented yet.
        """
        try:
            # Define the Size       
            self.axes.axis([0, self.plot_width, self.plot_height, 0])

            # Font 
            #axis_font = {'fontname':'DejaVu Sans', 'size':'11'} 
            #axis_font = {'size':'11'} 
            
            # xlim     
            #xlim1 = int(xmin/1e6)/5 #  (number/6000)*1200
            #xlim2 = 1+int(xmax/1e6)/5
            #self.axes.set_xlim([xlim1, xlim2])
            #print(self.axes.get_xlim())
            
            # xtick Locations
            xspan = int(xmax/1e6)-int(xmin/1e6)
            steps = 12
            xstep = float(xspan)/steps/5
            xticks = []
            for n in range(0,steps):
                xticks.append(float((xmin/1e6)/5+n*(xstep/1)))
                #print(float((xmin/1e6)/5+n*(xstep/1)))
            xticks.append(float((xmax/1e6))/5)
            #self.axes.set_xticks(xticks) 
            start, end = self.axes.get_xlim()
            self.axes.set_xticks(np.arange(start,end,100))
            
            # xticklabels
            xlabels = []
            for n in range(0,steps+1):
                xlabels.append(str(int(xticks[n]*5)))
            self.axes.set_xticklabels(xlabels)
            
            # xlabel
            self.axes.set_xlabel('Frequency (MHz)')
            
            # ylim
            self.axes.set_ylim([wideband_height, 0])
            
            # yticks
            start, end = self.axes.get_ylim()
            self.axes.set_yticks(np.arange(end,start,100))
            
            # yticklabels
            ylabels = ['0', '5', '10', '15', '20', '25', '30', '35', '40']
            self.axes.set_yticklabels(ylabels[0:len(np.arange(end,start,100))])
            self.axes.yaxis.grid('on')  
            
            # ylabel
            self.axes.set_ylabel('Time Elapsed (s)')
            
            # Grid
            self.axes.xaxis.grid('on') 
            self.axes.yaxis.grid('on')   
            
            # Font Size
            for item in ([self.axes.title, self.axes.xaxis.label, self.axes.yaxis.label] + self.axes.get_xticklabels() + self.axes.get_yticklabels()):
                item.set_fontsize(9)   
        
        
        ########################################
        
        #title='Detector History',xlabel='Frequency (MHz)',ylabel='Time Elapsed (s)', xlabels=['0', '','1000', '', '2000', '', '3000', '', '4000', '', '5000', '', '6000'],ylabels=['0', '5', '10', '15', '20', '25', '30', '35', '40'],ylim=wideband_height
    
        # Font Size
        #for item in ([self.axes.title, self.axes.xaxis.label, self.axes.yaxis.label] + self.axes.get_xticklabels() + self.axes.get_yticklabels()):
            #item.set_fontsize(11)   
                
        # Set the Labels, Gridlines
        #axis_font = {'fontname':'Bitstream Vera Sans', 'size':'12'}        

        #self.axes.set_xlabel(xlabel, **axis_font)
                   
        #start, end = self.axes.get_xlim()
        #self.axes.set_xticks(np.arange(start,end,100))

        #self.axes.set_xticklabels(xlabels[0:len(np.arange(start,end,100))])
        #self.axes.xaxis.grid('on')  
        
        #self.axes.set_ylim([ylim, 0])
        #self.axes.set_ylabel(ylabel, **axis_font)
        
        #start, end = self.axes.get_ylim()
        #self.axes.set_yticks(np.arange(end,start,100))

        #self.axes.set_yticklabels(ylabels[0:len(np.arange(end,start,100))])


        except:
            pass
        
                
    def plotPoint(self, x, y, color, point_size, wideband_data):
        """ Plots a wideband signal
        """            
        # Colors in Pixels Surrounding a Point, (r,g,b) Color Values are Normalized (0-1)
        wideband_data[int(y)-10:int(y)+10, 2*int(x)-point_size:2*int(x)+point_size] = color
        
        
    # def plotNarrowbandPoint(self, x, y, color, point_size, narrowband_data):
        # """ Plots a narrowband signal
        # """             
        # # Colors in Pixels Surrounding a Point, (r,g,b) Color Values are Normalized (0-1)
        # narrowband_data[int(y)-point_size:int(y)+point_size, 4*int(x)-point_size:4*int(x)+point_size] = color

        
    def configureAxes(self, title, xlabel, xlabels, ylabel, ylabels, ylim):
        """ Configures the axes, needs to be called for every plot because hold(False) will redo the axes setup
        """     
        try:
            # Define the Size       
            self.axes.axis([0, self.plot_width, self.plot_height, 0])
                    
            # Set the Labels, Gridlines
            #axis_font = {'fontname':'Bitstream Vera Sans', 'size':'12'} 
            #axis_font = {'fontname':'DejaVu Sans', 'size':'11'}         
            #axis_font = {'size':'11'}
                 
            self.axes.set_xlabel(xlabel)
                       
            start, end = self.axes.get_xlim()
            self.axes.set_xticks(np.arange(start,end,100))

            self.axes.set_xticklabels(xlabels[0:len(np.arange(start,end,100))])
            self.axes.xaxis.grid('on')  
            
            self.axes.set_ylim([ylim, 0])
            self.axes.set_ylabel(ylabel)
            
            start, end = self.axes.get_ylim()
            self.axes.set_yticks(np.arange(end,start,100))

            self.axes.set_yticklabels(ylabels[0:len(np.arange(end,start,100))])
            self.axes.yaxis.grid('on')  
            
            for item in ([self.axes.title, self.axes.xaxis.label, self.axes.yaxis.label] + self.axes.get_xticklabels() + self.axes.get_yticklabels()):
                item.set_fontsize(9)  
                
        except:
            pass
        
    def computeColormapValue(self, power_level):
        """ Takes the power level in dBm, normalizes it to the colorbar limits, and then looks up the corresponding
            color value in the colormap array
        """
        # Colorbar Limits
        min_power = -60
        max_power = 40
        
        # Normalize to the Colorbar Limits
        computed_power_level = 255*(power_level-min_power)/(max_power-min_power)        
        
        # Look up the Value in the 256 Length Colormap Array
        colormap_value = cm.rainbow(computed_power_level)[0:3]
        
        return colormap_value
        
            
class MyTuningMplCanvas(FigureCanvas):
    def __init__(self, parent=None, dpi=100, title=None, ylim=None):
        """ Class for creating the tuning graphic
        """
        self.plot_width = 601
        self.plot_height = 401

        # Background Color
        #background_color = (242.0/255, 241.0/255, 240.0/255, 1)  #QtGui.QColor(242,241,240)
        background_color = (251.0/255, 251.0/255, 251.0/255, 1)
            
        # Set up the Figure
        fig = Figure(dpi=dpi, facecolor=background_color)
        self.fig = fig
        
        self.axes = fig.add_axes([0.03, 0.25, 0.94, 0.8])        
        #self.axes.axis('off')
        self.axes.spines['top'].set_visible(False)
        self.axes.spines['right'].set_visible(False)
        #self.axes.spines['bottom'].set_visible(False)
        self.axes.spines['left'].set_visible(False)
        
        # ~ # Ignore hold() Deprecation Warnings
        # ~ with warnings.catch_warnings():
            # ~ warnings.simplefilter("ignore")
            # ~ warnings.filterwarnings("ignore", module="matplotlib")
            # ~ #self.axes.hold(False)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
        
        # Remove the Colors
        #fig.frameon = False
        #for item in [fig, self.axes]:  
            #item.patch.set_visible(False)  # Makes it white instead of transparent in newer version
        
        # Configure Axes
        self.configureAxes(title=title,xlabel='Frequency (MHz)',ylabel='',ylabels='',ylim=ylim)             
        
        # Other
        FigureCanvas.__init__(self, fig) 
        self.setParent(parent)
        FigureCanvas.setSizePolicy(self, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)
        
        cid = fig.canvas.mpl_connect('button_press_event', self.onclick)    
        #fig.canvas.mpl_connect('axes_enter_event', self.enter_axes)
        fig.canvas.mpl_connect('axes_leave_event', self.leave_axes)
        fig.canvas.mpl_connect('motion_notify_event', self.on_motion)
        
        # Initialize Clicking Variables
        self.clicks = 0
        self.bands = []
        self.first_point = 0
        self.first_click = 0        
        self.second_click = 0
        self.needs_update = False
        self.band_height = 36   
        
        # Tuned Location
        self.tuned = None
        
        # Frequency Limits (MHz)
        self.freq_start_limit = 1
        self.freq_end_limit = 6000
    
    def updateTuned(self, current_band, current_freq, bandwidth):
        """ Updates the location of the tuned rectangle.
        """
        # Delete Existing Rectangle
        if self.tuned != None:
            self.tuned.remove()
            del self.tuned

        # Draw New Rectangle
        current_freq = float(current_freq)/10
        bandwidth = float(bandwidth)/10
        self.tuned = self.axes.add_patch(patches.Rectangle((current_freq-(bandwidth/2), (self.band_height*(current_band))),bandwidth,self.band_height,facecolor="yellow",alpha=0.85))
        self.draw()
        
    def onclick(self,event):
        """ Called when the mouse is clicked on Tuning figure
        """
        # Valid Click
        if event.xdata != None:
            
            # Left Click
            if event.button == 1:   
                # First Click
                if self.clicks == 0:            
                    self.clicks = 1
                    self.first_point = event.xdata
                    
                # Second Click
                elif self.clicks == 1:
                    self.clicks = 0
                    self.second_point = event.xdata
                    
                    if len(self.bands) < 10:  # Limit the number of bands to 10 
                        # Plot the Band
                        if len(self.bands) > 0:
                            if self.bands[-1].get_facecolor()[0] == 1:  # Delete existing red band
                                self.bands[-1].remove()
                                del self.bands[-1]
                        h = self.axes.add_patch(patches.Rectangle((self.first_point, (self.band_height*(len(self.bands)+1))),self.second_point-self.first_point,self.band_height,facecolor="red",edgecolor="Black"))
                        self.bands.append(h)    
                        self.first_click = self.first_point*10
                        self.second_click = self.second_point*10
                        
                        # Account for Hardware Frequency Limits                            
                        if self.first_click < self.freq_start_limit:
                            self.first_click = self.freq_start_limit
                        if self.first_click > self.freq_end_limit:
                            self.first_click = self.freq_end_limit
                        if self.second_click > self.freq_end_limit:
                            self.second_click = self.freq_end_limit
                        if self.second_click < self.freq_start_limit:
                            self.second_click = self.freq_start_limit                            
                        
                        self.needs_update = True    
                self.draw()
            
            # Right Click
            elif event.button == 3:
                # Delete the Last Band Added if it is Red
                if len(self.bands) > 0 and self.bands[-1].get_facecolor()[0] == 1:
                    self.bands[-1].remove()
                    del self.bands[-1]
                    self.draw()
            
    #def enter_axes(self, event):
        #""" Called when the mouse enters the Tuning axes
        #"""
        #print('enter_axes', event.inaxes)
        #self.draw()    
        
    def leave_axes(self, event):
        """ Called when the mouse leaves the Tuning axes
        """
        # Hide the Mouseover Text
        text_x = int(self.axes.get_xlim()[0]) + 1
        for txt in self.axes.texts:
            if txt.get_position() == (text_x,500):
                txt.remove()
                
        self.draw()
        
    def on_motion(self, event):
        """ Gets the mouse over coordinates upon movement
        """
        if event.inaxes:
            xpos = event.xdata
            freq_text = (str(int(xpos*10)))
            
            text_x = int(self.axes.get_xlim()[0]) + 1

            # Delete Old Text
            for txt in self.axes.texts:
                if txt.get_position() == (text_x,500):
                    txt.remove()
    
            # Draw New Text
            self.axes.text(text_x,500,freq_text,fontsize=11,bbox=dict(facecolor='red', alpha=0.5))
            self.draw()
        
    def configureAxes(self, title, xlabel, ylabel, ylabels, ylim):
        """ Configures the axes, needs to be called for every plot because hold(False) will redo the axes setup
        """     
        # Define the Size       
        self.axes.axis([0, self.plot_width, self.plot_height, 0])
                
        # xlim
        self.axes.set_xlim([0, 601])
        
        # xtick Locations
        xspan = 6000
        steps = 6
        xstep = float(xspan)/steps
        xticks = []
        for n in range(0,steps):
            xticks.append(int(n*(xstep/10)))
        xticks.append(600)
        self.axes.set_xticks(xticks) 
        
        # xtick Labels
        xlabels = ['0', '1000', '2000', '3000', '4000', '5000', '6000'] 
        self.axes.set_xticklabels(xlabels)
                
        # xaxis Label
        self.axes.set_xlabel(xlabel)
       
        # Title
        self.axes.set_title(title)
      
        # Grid        
        self.axes.xaxis.grid('on') 
        self.axes.set_axisbelow(True) 
        
        # Y Values        
        self.axes.set_ylim([ylim, 0])
        self.axes.set_ylabel(ylabel)
        self.axes.set_yticks([x*100 for x in (range(0,len(ylabels)))], minor=False)
        self.axes.set_yticklabels(ylabels)
        self.axes.yaxis.grid('on')  
        
        # Font Size
        for item in ([self.axes.title, self.axes.xaxis.label, self.axes.yaxis.label] + self.axes.get_xticklabels() + self.axes.get_yticklabels()):
            item.set_fontsize(9)   

    def configureAxesZoom(self, xmin, xmax):
        """ Configures the axes, needs to be called for every plot because hold(False) will redo the axes setup
        """     
        # Define the Size       
        self.axes.axis([0, self.plot_width, self.plot_height, 0])

        # xlim     
        self.axes.set_xlim([int(xmin/1e6)/10, 1+int(xmax/1e6)/10])

        # xtick Locations
        xspan = int(xmax/1e6)-int(xmin/1e6)
        steps = 10
        xstep = float(xspan)/steps
        xticks = []
        for n in range(0,steps):
            xticks.append(float((xmin/10e6)+n*(xstep/10)))
        xticks.append(float((xmax/10e6)))
        self.axes.set_xticks(xticks) 
             
        # xlabels
        xlabels = []
        for n in range(0,steps+1):
            xlabels.append(str(int(xticks[n]*10)))
        self.axes.set_xticklabels(xlabels)

        # Grid
        self.axes.xaxis.grid('on')  
        
        # Font Size
        for item in ([self.axes.title, self.axes.xaxis.label, self.axes.yaxis.label] + self.axes.get_xticklabels() + self.axes.get_yticklabels()):
            item.set_fontsize(9)     
            
        # Draw
        self.draw()
        

class MyIQ_MplCanvas(FigureCanvas):
    def __init__(self, parent=None, dpi=100, title=None, ylim=None):
        """ Creates a plot for IQ data and places it in a figure canvas
        """
        # Background Color
        # ~ background_color = (242.0/255, 241.0/255, 240.0/255, 1)  #QtGui.QColor(242,241,240)
        background_color = (251.0/255, 251.0/255, 251.0/255, 1)
        # ~ border_color = (25.0/255, 54.0/255, 93.0/255, 1)
            
        # Set up the Figure
        # ~ self.fig = Figure(dpi=dpi, facecolor=background_color, linewidth=1, edgecolor=border_color)
        self.fig = Figure(dpi=dpi, facecolor=background_color)
        self.fig.subplots_adjust(left=0.1,right=0.95,bottom=0.1,top=0.94,wspace=0,hspace=0)
        
        # Do the Plotting
        self.polar_used = False
        self.configureAxes(polar=False)
        self.applyLabels(title,'Samples','Amplitude (LSB)',None,None)    
        
        # Other
        FigureCanvas.__init__(self, self.fig)
        self.setParent(parent)
        FigureCanvas.setSizePolicy(self, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)
        
        # Cursor
        self.cursor_enable = False
        self.cursor1 = None
        self.cursor2 = None
        self.fill_rect = None
        self.click = 1
        self.txt = None  #self.axes.text(0.0, 0.0, '', transform=self.axes.transAxes)
        cid = self.fig.canvas.mpl_connect('button_press_event', self.onclick)  
        
    def applyLabels(self, title, xlabel, ylabel, ylabels, ylim):
        """ Configures the axes, needs to be called for every plot because hold(False) will redo the axes setup
        """ 
        try:
            # Define the Size       
            #self.axes.axis([0, width, height, 0])
                    
            # Set the Labels, Gridlines
            #self.axes.set_title(title)
            
            self.axes.set_xlabel(xlabel)
            self.axes.xaxis.grid('on')  
            
            self.axes.set_ylabel(ylabel)
            self.axes.yaxis.grid('on')  
            
        except:
            pass
            
    def configureAxes(self,polar):
        """ Configures the axes after a polar/projection change. Must be done before plot. Gridlines and labels after plot.
        """
        # Plot Type
        self.fig.clear()  # Suppresses MatplotlibDeprecationWarning
        if polar:
            self.axes = self.fig.add_subplot(111,polar=True)
            self.polar_used = True
        else:
            self.axes = self.fig.add_subplot(111,polar=False)
            self.polar_used = False

        # ~ # Ignore hold() Deprecation Warnings
        # ~ with warnings.catch_warnings():
            # ~ warnings.simplefilter("ignore")
            # ~ warnings.filterwarnings("ignore", module="matplotlib")
            # ~ #self.axes.hold(False)  # FIX: To clear an axes you can manually use cla(), or to clear an entire figure use clf()
                
        for item in ([self.axes.title, self.axes.xaxis.label, self.axes.yaxis.label] + self.axes.get_xticklabels() + self.axes.get_yticklabels()):
            item.set_fontsize(9)  
        
            
    def clearPlot(self):
        """ Clears the plot data.
        """
        for artist in self.axes.lines + self.axes.collections:
            artist.remove()
        self.cursor1 = None
        self.cursor2 = None
        self.fill_rect = None
        self.txt = None

    #def mouse_move(self, event):
        #if self.cursor_enable:
            ## Mouse Move Checkbox
            #if self.mouse_move_enable:
                #if not event.inaxes:
                    #return
                #x, y = event.xdata, event.ydata
                ##indx = min(np.searchsorted(self.x, x), len(self.x) - 1)
                ##x = self.x[indx]
                ##y = self.y[indx]
                ### update the line positions
                #self.lx.set_ydata(y)
                #self.ly.set_xdata(x)
                #self.axes.figure.canvas.draw()
        
    def onclick(self,event):
        """ Called when the mouse is clicked on Tuning figure
        """
        if self.cursor_enable:
            # Valid Click
            if event.xdata != None:    
                        
                # Left Click
                if event.button == 1:             
                    x = event.xdata
                    if self.click == 1:
                        if self.cursor1 != None:
                            self.cursor1.remove()
                        if self.cursor2 != None:
                            self.cursor2.remove()
                        if self.fill_rect != None:
                            self.fill_rect.remove()
                            self.fill_rect = None
                        self.cursor1 = self.axes.axvline(color='k',linewidth=1)
                        self.cursor1.set_xdata(x)
                        if self.txt != None:
                            self.txt.remove()
                            self.txt = None
                        self.click = 2
                    elif self.click == 2:
                        self.cursor2 = self.axes.axvline(color='k',linewidth=1)
                        self.cursor2.set_xdata(x)
                        x_diff = math.floor(abs(self.cursor2.get_xdata()-self.cursor1.get_xdata()))
                        self.fill_rect = self.axes.add_patch(patches.Rectangle((math.floor(self.cursor1.get_xdata()),self.axes.get_ybound()[0]),x_diff,self.axes.get_ybound()[1]-self.axes.get_ybound()[0],facecolor="yellow",alpha=0.85))
                        self.click = 1
                        if self.txt == None:
                            self.txt = self.axes.text(0.01, 0.01, str(int(x_diff)), transform=self.axes.transAxes)
                    self.draw()
                
                # Right Click
                if event.button == 3:
                    if self.cursor1 == None and self.cursor2 == None:
                        pass
                    else:
                        if self.click == 1:
                            self.cursor2.remove()
                            self.cursor2 = None
                            self.click = 2

                        elif self.click == 2:
                            self.cursor1.remove()
                            self.cursor1 = None
                            self.click = 1
                            
                        # Remove Fill and Text
                        if self.fill_rect != None:
                            self.fill_rect.remove()
                            self.fill_rect = None
                        if self.txt != None:
                            self.txt.remove()
                            self.txt = None                                
                            
                        self.draw()
                
          

class OptionsDialog(QtWidgets.QDialog, form_class3):
    def __init__(self, parent=None, opening_tab = "Automation", settings_dictionary=None):
        """ First thing that executes.
        """
        QtWidgets.QDialog.__init__(self)
        self.setupUi(self)
        self.return_value = ""
        
        self.settings_dictionary = settings_dictionary
            
        # Prevent Resizing/Maximizing
        self.setFixedSize(640, 450)         
        
        # Do SIGNAL/Slots Connections
        self._connectSlots()    
        
        # Change the Current Tab
        if opening_tab == "Automation":
            self.listWidget_options.setCurrentRow(0)
        elif opening_tab == "TSI":
            self.listWidget_options.setCurrentRow(1)
        elif opening_tab == "PD":
            self.listWidget_options.setCurrentRow(2)                         
        elif opening_tab == "Attack":
            self.listWidget_options.setCurrentRow(3)
        elif opening_tab == "IQ Data":
            self.listWidget_options.setCurrentRow(4)
        elif opening_tab == "Archive":
            self.listWidget_options.setCurrentRow(5)
        elif opening_tab == "Packet Crafter":
            self.listWidget_options.setCurrentRow(6)
        elif opening_tab == "Library":
            self.listWidget_options.setCurrentRow(7)  
        elif opening_tab == "Log":
            self.listWidget_options.setCurrentRow(8)  
        elif opening_tab == "Hardware":
            self.listWidget_options.setCurrentRow(9)  
        else:
            self.listWidget_options.setCurrentRow(10)  
        self._slotOptionsListWidgetChanged()
        
        # Populate the Tables
        tables = [self.tableWidget_options_automation, self.tableWidget_options_tsi, self.tableWidget_options_pd, self.tableWidget_options_attack,
            self.tableWidget_options_iq, self.tableWidget_options_archive, self.tableWidget_options_packet_crafter, self.tableWidget_options_library,
            self.tableWidget_options_log, self.tableWidget_options_hardware, self.tableWidget_options_other]
        for n in range(0,len(tables)):
            for get_row in range(0,tables[n].rowCount()):      
                try:
                    get_variable = str(tables[n].verticalHeaderItem(get_row).text())
                    if len(get_variable) > 0:                        
                        get_value = str(self.settings_dictionary[get_variable])
                        tables[n].setItem(0, get_row, QtWidgets.QTableWidgetItem(get_value))
                except:
                    pass
    
    def _connectSlots(self):
        """ Contains the connect functions for all the signals and slots.
        """
        self.buttonBox.button(QtWidgets.QDialogButtonBox.Apply).clicked.connect(self._slotOptionsApplyClicked)
        self.listWidget_options.currentItemChanged.connect(self._slotOptionsListWidgetChanged)
        
    def _slotOptionsListWidgetChanged(self):
        """ Changes the index of the stacked widget containing the options.
        """
        # Change StackedWidget
        get_index = self.listWidget_options.currentRow()
        self.stackedWidget_options.setCurrentIndex(get_index)

    def _slotOptionsApplyClicked(self):
        """ The Apply button is clicked in the options dialog.
        """     
        # Retrieve Values from Options Dialog
        tables = [self.tableWidget_options_automation, self.tableWidget_options_tsi, self.tableWidget_options_pd, self.tableWidget_options_attack,
            self.tableWidget_options_iq, self.tableWidget_options_archive, self.tableWidget_options_packet_crafter, self.tableWidget_options_library,
            self.tableWidget_options_log, self.tableWidget_options_hardware, self.tableWidget_options_other]
        variable_names = []
        variable_values = []
        for n in range(0,len(tables)):
            for get_row in range(0,tables[n].rowCount()):      
                no_row = False       
                try:
                    if len(str(tables[n].verticalHeaderItem(get_row).text())) > 0:
                        variable_names.append(str(tables[n].verticalHeaderItem(get_row).text()))  
                    else:
                        no_row = True
                except:
                    no_row = True
                if no_row == False:
                    try:
                        if len(str(tables[n].item(get_row,0).text())) > 0:
                            variable_values.append(str(tables[n].item(get_row,0).text()))
                        else:
                            variable_values.append('')
                    except:
                        variable_values.append('')
                        
        # Update Dictionary
        if len(variable_names) == len(variable_values):
            for n in range(0,len(variable_names)):
                # Make Exceptions for Lists
                if variable_names[n] == "disabled_running_flow_graph_variables":
                    self.settings_dictionary[variable_names[n]] = ast.literal_eval(variable_values[n])
                    
                # Otherwise Saved as Strings
                else:
                    self.settings_dictionary[variable_names[n]] = variable_values[n]
    
        # Dump Dictionary to File
        stream = open(os.path.dirname(os.path.realpath(__file__)) + '/YAML/fissure_config.yaml', 'w')
        yaml.dump(self.settings_dictionary, stream, default_flow_style=False, indent=5)  
        
        # Return Something
        self.return_value = "Ok"
        self.close()
                  
            
def main(argv):
   
    app = QtWidgets.QApplication(argv) 
    
    # Main Window
    print("LAUNCHING DASHBOARD")
    wnd = MainWindow()
    wnd.show()
	
    sys.exit(app.exec_())
    
 
if __name__ == "__main__":
    main(sys.argv)

